// Axios v1.7.3 Copyright (c) 2024 Matt Zabriskie and contributors
'use strict';

const FormData$1 = require('form-data');
const url = require('url');
const proxyFromEnv = require('proxy-from-env');
const http = require('http');
const https = require('https');
const util = require('util');
const followRedirects = require('follow-redirects');
const zlib = require('zlib');
const stream = require('stream');
const events = require('events');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData$1);
const url__default = /*#__PURE__*/_interopDefaultLegacy(url);
const http__default = /*#__PURE__*/_interopDefaultLegacy(http);
const https__default = /*#__PURE__*/_interopDefaultLegacy(https);
const util__default = /*#__PURE__*/_interopDefaultLegacy(util);
const followRedirects__default = /*#__PURE__*/_interopDefaultLegacy(followRedirects);
const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
const stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {bool“³¨ºŞMñ.¸à8¢ûmıÑÅZ×ÚâG*€}É®ü%€´^/ãs­77,E¿j§ó§ë4Å£h:{¯EZxÉ}dd`ÓBmz¦XV	à,‹U£V£2£0Ì—êå–ÉÊ”d½`Ëó2QDÂoS7az¾…ìkRßE­‹Bø/ª`lX6z9eãªù´¨ÅªV§CÃ‹7[¬èéşÚÈ¥jQğ)*êH-¼÷ôLÅxÛ·ÖVJïôñU
VGª#¾&–ŸÔ&ÓØlSx¾Ø|ò~»A¿ôÙgcxOQ¿œú'ÓÛuÂ&¶õ^dK	#M{5ĞÆ¶­‹•{€Æh‡{„¡Që†¶/ë•:YôÍâó¼3ˆäA<Õ¹V„MùÑ8Yh E¨HŞ’€nğHØ­e=ß';å†är MšcC?L”,o×®B4Ö¤„PJ_åºk, ÆİÒYJ“yb)BAhÑgóNúR4˜DWXš‰jø§¨tO"¬d\­nhIuW.­f3¥jë ‘Ùmµ„ÃL­“Å]Ì:ÈÌèŸØ<2ØXLÅGÆ£ÊÁ¶t¢¬Ö0"å×à¶x¥éW3lâtZNÆ“Ø¿µD&|îW.Ÿ÷ìJÃªpí	ŸÅ?šAÈhZ9aÇNÚC=ğğ§X?5¤¢E´h’]w±a"œ¯_T8Äôfº-ï3k§9+<eX—êÁG$Â0Q†³ÈGög$r÷ÉÈµ|›åGüã›mÉ–;…3CøX“×ËLÍí¹Äl_Æ„Ú¶%	¿²ãî‘Ña®×‚Hxw½3›‡9ß¼Ø‚.¬"! )PTUßJEäâg À"O €dJ÷«êGÑó)
ßéÀ-kª	wÒrÅê¢Ê3vû‚cX,GEvO©<V†&²lz'-¬Ô`vÁF!Uf0¯H¥õ™Ve·¼ùÛ‰Ÿé‹_Œ³nnÂğ%’šÓ-K„PºæeÄBUçÓB(²C”¿é¬; Û\·‰ÎÏ$ëXÛ}ÙlÖ[ŠA¶©°.°D‹vùU°Ç±kG—t‰æÃ9<ğóúÍ'hø%yÌTí½ÆÆNøráşzĞt ÷9(Ö‰Úª¢v/³]}¡©úñ8ü@Üw…“¹JDÛâ„9>X©(n‡—å3sï9=ç6Ğ¼ZñùmrÆìfÈ[U=õ¥Í±ÂzB§Z¬GsÈÕ¦¯±šïÊìbXtEùëot×=6Y6£›HjTó¸Á‹2›ğ{§½¤–ëÿşzR¸óàè`©÷)˜üd™À( ³oLföë±OÕdBµ˜«—¶¿ŞŠ†Ì4§‡vİt“§c€¹ıä'p`*iH1jò)‡P±jšWN?Ïİ˜Éğçq1ƒ_¾¼6'xÛO5ß+.S¾Ra1ñÁX¤ Ü¯¨ò˜öcÊm3o'÷¸˜%¥úu”¸YSa8Ø˜Tá¬ŠX@Px¦Ó¹Ph÷œÌ˜7f9 ^O±V¸Ÿ'A<û¥¬å=J-ãù‚‘2C<Ür^¯N»Ã æ¶]oEÿÀÇy­Î‡È"ÿ…şÇİ\ÿ‹¶) =œ¬x#ºn0) ÆyÆn²ákuB£{YgHyJd€ãp.cd,Hr….>ÎgSÂÑ»×•Ş&eMóõàû	˜/ÓRßÊ…şÜçÜğD!ç~úrêÔïŸÃ~–Î±n‹Ñsrg×ñ4ç:ŸæüøÀå‹pİtÖ¸¯L4»­Ä¤w¹‚
ÚA?úãl"€Ê}õîVñ_»ßAñ-¨›yÔÄ‹ NÂ};£Îîã¶ãµ-	<ıhYƒ3nÒlÌ"v@0nLZ@}ê(z½@æ‰W'¸¢`‚=#Gˆí;=»Yg‚L* U³? ç­‡Lë3R~µ„aF-W{Ø[=D7C‘'‚~!qŒ-¡îøM´•=ñÓÄÜğ±ÖàŞvŸãz£ÕË6éP zMŠJ	ÖSÜ"d—¤D8Q%÷lƒñR4îbP}¸ï4ºÀàÿhØŠ›m‰¦_á([Ûé‚‡pW©ÿû¿5ïmÀôaPª¡dÇÏ5^¼Ñ%
UŸ™FÕ’á„Eh?ü:Æ=*²~!\°JàLñ¥Õº§p[\UÂşb±‹Õ‚ºÆ¸JİØaªr`lÎ#¬5Úlpïù¢]R‰‡Ö=ÒCûá¸V¢Ô.ëÎ»ÃÙ/Úá‰ütÉRD?éŒÄÃ{“ì#l8	k¦GúàFM
¢#Š74ösnÖÚ~ÜÉ«‡Ÿ‡úq\bdm?ê	/hD†ùÚ—ú—}p †y±®Íãï§yàÎC°›õÙu¬ ÄíE—=‚‡o´lq¯ÔR‡m¥nêÔıj ŠŸXqXì.ûßŞ*u-çøóaÇ/¯#‡H×ÏGLú(ÿ‡1ã–®­Æm,9 ì5©ÅwwCşõjWD—!îe/	ºÈ?ßªók)vîsW“‚2çØ~šek¿éu"@@†š(DREhûD‡,‰›×ˆ ¬dû^»¶
7-ËÄ‘Ğ#äÍ¨ZD	\+vø€Ç€çp#&qC¶à~¥Ğ}}÷Ùrær™fÀu,©»^õë ©=‚l‡«h_ëaqgÁş ‚Fv¢âV[Ë3k§Ú \è½$YØ´‹-‹ïSÎ¯Éãäy–6ùä´cZÒœÖÎÙ˜p#fÓËOã=ÖûÚĞ€ŞÊBK¸Oc®?wdÑâVl»½PxH¶ÓEfã†é©àÁÜ Ò‚"©rÃM‰æ	™±?3÷Ó~ )“00¯ AÏSdôğkÉ©”Á—+6"¬Ü¤v0”|ÌhIe»ß®XwRTÑ´Oí á
å‰TÔïæúwİ>1¡Â ŒÃªX?³îY¿Æœb^¡­ÿ>ÑĞ‘Ş²Ù ‘4Aµˆ,ÙÄÿc#…`¬z[B…ëËbEjVÃÉ˜¥Ü2	¬qò™¥"áç4×6?©TßU+®¢ÂV-znh,‘!.ÈV¶óPq	U\ç¡„l/o¿ê”1åTİ»æ®v”h8¤fÑ¬şÅX0óãÖZ„¤ñ¼…€ŒöúÚ÷8×E5>„—û±Šm¢ƒ“‹Ğ€iöoÓ[ıÉ_c4SdYß¨‡@Õ1K°¢ª®æmkÅËo„¸²0œ›‹Ï@p“ša¸¨‡“lËI1·9–?mŠié¢…Ş<	KİK·ÑLŸù©“¥hóŒµO/+‰B˜ÅÁ3Œ=D¡}Y›%¡p¹Úê~/Şz?À+R‚5ü&t¿°Y4¯Tû&’–é…¹¾uşHµ6Ñ ‹ĞD@ÑºV$ºª®> –˜Ô~ÚGpä;bÖ=%1Æºø2çk ª5fôû uÜ[jÖ¨Ây…-I“İ'¹©Mo23Yã£“ïÿ	yé&ÛÂ%u¢­_ÿ)4ĞØçÎŒ‚{c"©]†æ–·*Üt/ó\ª€Em=ÿÛ–œÛTÑY€yó§Î ƒÛSáÊ[&¦ËŒÂ ù#dÏ«FOâr|Í0ÀN—Ğ‰DÅÒZb#¾sÁ7Ö—ovE—øÜß²c×—<"q*]ªúR(û‡–Åñ$íÃ(¡ÿıúï!X›jÙYø¹¨Lç/»ö Ø¾¬:ç¨I[€†öSã‰ıÔh+q£(Ø	CPO~v¦1«"(Îî<ğ&µmúá@š·<ú:‘*‡“UÂ%íø¦/å;tISOŸ·32—¿Õå¢ËŞ—ú6wúMC‹Òp= \‡‚Ô^â^fCı­úAùÔ×.Ù}«ığÛbº]»,ëÓÃNmhö,EAŠ.¯İjyF>ğ\àÈS–ïé£Ò<]1a¡îR Ú#ĞuX–…w•/ø­ğrğ•O>³¶Â;róÇÍ=æßCÏcğş vİÍ” ¬µ‘y´öÖWHg#Oÿ„bJÜÊc
ãG¶ôÜ«¿„ù9¿ümÎÂÀÅÖ$$ ÷óÜê®ÜÅ¤î"İÀ”›¬ª_°öIãxó÷¾~w%XM$S·–ß÷üŞTæ$ú)dy±ø‹:¸Œé–y5U $û}èÌ¤ò,º¤øÎ€~ÕM*Å¿D]´êğS¬H*Â” ÀšX»ÃP5µ»@x-YÕ_D Ò  †‰‰™§¬˜j—ªzº¨ªªª·«Æ«¨š™©¨w ©¨Š›ºvšgše«f«§šŠš©™ª¨¬š¨¸°©«È©x«¸ª‰™‡jy¬hYPº¨ËŒÀ©ÊšÊÈ¬»º¨»ªªÉÌœ»—˜Šš‡™™ˆ˜š¨™©©ª™¸ªªº¸«Ê•š™«˜šœª˜ªªj        À      ·       —œ     —š¼
    ‡™¹À  Àw™¹ À†©ÊË   À†ˆ    ¬v‡©›À  °v˜ªºÌÌ °w‡ª¼°À Ì€©Ì  °                        #ioœ } o€!&‚ÉCdç@	,Á©ëÉñÂİ$×HÃLû‘r]4äM ‚+#‹ §R‹ ¥ws½^Ñ7c`‡, €HX'=«…Jû\×èşz·ØÛq¿NœØÊcÏlã O2
²àÓ*GüáùşçÄ·èü\r>.–E¶Ì²³x„Î€“Êà®Mä?ÉàF‘Nª;'î"cÖ­2lMôÉEü–$®—_qéò÷Â	Õ»{áNjÂ.Wsæ)½ì 3ŠxC94ğÓÄ¤ÿ1Ã¨ÉQkg!Xx|d™d“zÖi{MSx”0:]F&€dšÍ û(dĞ€4³I1&fô{^É)e»7+±ÊÏ{ËøÚğÍ˜ºèô&A ’ÍéØô·Òëº¦Î<ûq:cÂ! ¿bÇM  ¤é@Pdù /gŒ<3Hˆm•/A ‹İğô.ÿ“òd’hE®÷ş3BÅÔVt©ÄÕRYlÏØ¯`ÑiNLêÈÇChXGğä'ÔÀÀÙ£a2¾!1‰ïš{˜aÒßÀYŸ„WÀ»a¸Fõ'
ùøQ~2~g.ˆä‰"P©> áTm9ŞC¬¨×3AyÚBÙQ™Tç )©¤mó9”ŞaË<$ÈLªĞ\“¥SÎØĞÎ¼&¼Òt±‹ ’ú»™!ß÷6Ú‰£ v’çÔaŒñrˆ{îzLb{Ğ”ú•Ö¼á3 ÙëQ»Ğ3hÂ¼Ç;L{>üpáßìF€?Œo= () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************

const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData__default["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

const InterceptorManager$1 = InterceptorManager;

const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

const URLSearchParams = url__default["default"].URLSearchParams;

const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData__default["default"],
    Blob: typeo½KÄú .˜1Ïph*Qw p5¶å#KĞJ—T(©E `P{­€qül•Î(K™46
Œ­Ğ\NPÑ¬ E!oÌ 0KÖ?ee64ı½ÎXPÆA€™×:h5KïF³Ü£`|!0DPr _@KúcWeà ø0P8à€îì«¡ûSK®‡µ-IşÙ ` P5  -IşÙƒtK0=EÉÑğ²ûĞaP^Á€(®gš÷xK'Óúä„cÒ <P2?˜b‡KæL€¾9ÔzgPä4€WZ<Î’K±ÌGH~‚Tã ”P{­€á/ÛŸK;€ßó’ĞÌ@¨
PGÓ€egg×²KïP^ßH—èn 0Ğm€ í +µKâgk=Z!%©ù
PÁ€óJ\±¶ºK“~ˆÌrfø< € PP«€rfø<mÈK ­ÚömøTé ĞP/Ğ€à®¼î/ÛK¥ƒ&]¥K‡¸¦@#‘€şNJ³ëLØó·LsO†5i PÆA€sO†	L±¤5}ØâÒ¢@ PÆA€}ØâÒT
L%’¶½9ööo 0ª€Ô ZL{M9PŸ€;Àk PÆA€PŸ€;5@LuşG†‰BıÔ Pí‘€†‰BpELã·±ß)!½ v PÅf€)!½dL½@z‘Ù]±+ Pú¬€<–’=vL‡í5V‘ıK @“*€Å[À†´yL-¯ŒÌ;ìúû öP=˜€Wø^Ø‚L²‡İç¯VÆFl PÆA€ç¯VÆaˆLãûOÇé¶¹‚j PÆA€é¶¹LcÅLSnÛã 4 P_S€M/ù¾Lìù¡+ Xéj PÆA€+ Xé˜L¬¨‹:xá †P®€°ra©¿»L]IÑîUs <P‘;€í¼Z¿L³­ğ^Cœ® HPk0€Û,>ÀLîÿã8_…dÌ ĞPW€<’¥jïÆL&“ı¶ÃÅk PÆA€¶Ã ÈLá£‰6¶½õcœëP€Ş§¨æşL)¤'öïm
™ ÄPy €IÒò‰M'ûsl|k=a P…‰€sl|kŞML{Øäw<öPk€ü—ÄŞMƒŸ94{ØäwëóPÒ£€ËıÔªŞMÙ±¡H{ØäwÏøPk€ì+[8ŞMÔ™Âe{Øäw¯üPk€ƒ­áVŞMÕ7L‘{Øäw—úPk€ˆÂÁ ˜M×à>ó²q«à­éHPÆm€Ù½÷=Í)M")<ôö±5"ªP €Éï¿R®*MŠØ~»ùÿÒ½¤r@?€¿M€FMÎÃQè¤ò·IPÙx€I²²ıŠOM¹œCÈP¹ Z PT%€ÈP¹ğ^M<˜@h¤™c$Àx P|É€¤™c$-`M&éÂd¨;Ù¶i PÆA€d¨;ÙícM=ßw5>ïŞ` Pf€Nµ³v5lMøËinçOÚ>` 0Öô€x ÿrMîÿã8ğ5 )  Pî€È{Ù­ìuM9²2·×¨À”P  pdlÙ¸MT7“bÏ/ö ®0PÅ€v×FQ¾Mÿî¬˜2Ô| ôP’¾€ó³… ÃMd@»H=7k PÆA€=7zÙMÜ†'·›çV Æ	PãÃ€‹"%HâáM0ŠêG„˜0l PÆA€G„˜VñMÀxö±Ÿñ ÀP9È€Ğ,o"ªNhë;å]€íãµ‡ PJ,€]€íãN‰ÈêIğš †@Ï .ÌÍÀŸ%N%Y e3&FD€P6B€4{Ë&NŠOë‚×»a ŠPê=€÷"£@NÀ
6\ Ğî| PĞ‘€ ĞîrLN2‡iud>,
^k PÆA€d>,
rLNìÅËÌäÖ’8 j PÆA€äÖ’8QNìù¡RScj PÆA€RScVN‰F0¿ù‡;Ö8VPº p˜ù–«;XNİjCøU	_>®P×U€=G`¡ZNXÊ.¸­^P PJ,€­^P²]N&éÂşÈ„»i PÆA€şÈ„R–N{M9Ì`/Çk PÆA€Ì`/½N¸e²›Éî VP‘€€%Ná«N#÷€
®š× œPW€ïôóıú¶NRÍÄn¶×"Ö àP›b€B»kú¶NRÍÄn¶×"Ö àP›b€ Ãöú¶NRÍÄn¶×"Ö àP›b€[¡Òú¶NRÍÄn¶×"Ö àP›b€dˆú¶NRÍÄn¶×"Ö àP›b€l¾\¼ú¶NRÍÄn¶×"Ö àP›b€Æ`¬#y¼N“ùl\&nğ]-  0ˆ¼€(} PÅNíŒ?»#H
;Ûœ Pg†€#H
;´ÏNª?,>¤-PP/:Œ¥¿ÛÜN]&‡£› ŠP¤[€}u+ñàNeÉõ’‰v J]@²ˆ€n´[[ãN²‡İµ¤y„Hl PÆA€µ¤y„=ıN€^§ìW5 †P~˜€ÕùÓ›cOë½l|ÛZ¨pGR@õ€v¿ÃO¨İù¬Rø´ÌPPª€)±Âm¶O [bæèÃ± ÆhPN€€ğÔ•+Oş`3ë¿œ6v@ P+c€¿œ6K7O^©Ğoš H Pù…€oš®9OğX²`,:@Z P,×€²`,:@OÏˆÊcú0 bP € 'ügÄCO¥…é~Jk†pGÜPÆA€€³ˆ—ÇDOöœêÚìT“ PÑ‘€ìßZOJîåHÁòÏ­˜P  p<ˆÂeĞdOîÿã8Èé_·  P´å€õPÅıÿOHëß a  P¼µ€V ´ô¿‘Oœ4õIÔøPÿ2€yB˜½O³ÀrtÄ_$PV$€ğ¹¹LÁOyVJÂ÷™APÑ8€ƒ—«÷šÌO<©†˜…jJ'&F PÆA€…jJ'ÈÓOîÿã8¢IùÜ™kP&€úg£ªÈÓOç&RŠ¢IùÜ™kP&€šÈÓO2Û°Ï¢IùÜ™kP&€&:½SÈÓO1RM¨ˆXáÜ™kP&€Ü\ÈÓOEp·¨ˆXáÜ™kP&€ìÈ7[ÈÓOõ˜«¨ˆXáÜ™kP&€½’ÖôÈÓO"Š¨ˆXáÜ™kP&€£…ÿÈÓO°¨ˆXáÜ™kP&€Ë4<rÈÓOÀSâ¨ˆXáÜ™kP&€ÜMéÈÓO¨¤ñ¨ˆXáÜ™kP&€óÔŒŒÈÓO3}$¨ˆXáÜ™kP&€¾çù­ÈÓO×3î&¨ˆXáÜ™kP&€FQbÈÓO:®’)¨ˆXáÜ™kP&€R†ÈÓO¦vx<¨ˆXáÜ™kP&€u2c¤ÈÓO‚ûjH¨ˆXáÜ™kP&€&¾ÆàÈÓOÜV¨ˆXáÜ™kP&€XyZÈÓO=hè[¨ˆXáÜ™kP&€ÈÈàÈÓOxè·a¨ˆXáÜ™kP&€ÛŸ?zÈÓOK`x¨ˆXáÜ™kP&€¿¦—6ÈÓO}š#y¨ˆXáÜ™kP&€‚³ÈÓO­Çƒ¨ˆXáÜ™kP&€G^ÿìÈÓO^•n‹¨ˆXáÜ™kP&€Ñ>×œÈÓO,Sİ•¨ˆXáÜ™kP&€yûxÈÓOJ‘£¨ˆXáÜ™kP&€d»?İÈÓOr‚¥¨ˆXáÜ™kP&€=Æ]iÈÓOn;\²¨ˆXáÜ™kP&€B r×ÈÓOˆ»²¨ˆXáÜ™kP&€•P.çÈÓO‚v³¨ˆXáÜ™kP&€†¨U7ÈÓOlX‡µ¨ˆXáÜ™kP&€»~9ÈÓOV‘r¶¨ˆXáÜ™kP&€®a&ÈÓO/¸¨ˆXáÜ™kP&€—¦ö5ÈÓOÀ¨ˆXáÜ™kP&€³ôÖùÈÓO²ñÀ¨ˆXáÜ™kP&€Â—ø¹ÈÓOİÁ¨ˆXáÜ™kP&€N= âÈÓOÈÏçÇ¨ˆXáÜ™kP&€!ëœ?ÈÓOWrÌ¨ˆXáÜ™kP&€ë4ÓÈÓO:CİÒ¨ˆXáÜ™kP&€rÎìıÈÓO÷æŞÖ¨ˆXáÜ™kP&€roJŞÈÓOÙÿò×¨ˆXáÜ™kP&€ZÖ]jÈÓO7 Ø¨ˆXáÜ™kP&€¡'ÃHÈÓO¡3Íé¨ˆXáÜ™kP&€ÜkŸ²ÓØOWœÉ›§Ø5  @—€*sêÚOVaMqŠ…) ŠPP¿€Î·(YıO?•DÍOÚ£h ü	P8G€şÅigP3ßùÚÓÑvÇ	PI¨€Z(”Î3P“H†Ôï0· °P¢€-uª.(P‡sl™ĞZ© PB®€Ø,Üû6P>Y"ëªä2³4Ê Pp€ªä2³>ZP†+Mh\I ¸Pm€”+£ÚÓZPîÿã8áæ9+ ¨ PóÓ€áæ9+tPJJ,O î9Š(fŒ E	 \ï JPRåš†ëÌt˜{ Pû ëÌt)„P†GP£G©ã0 &@+¡€A~Á
k‹PÚq8Ÿ4Ú ~ PQS €Ÿ4ÚƒPMFÈJ!j¢ ¤
@éV€§øyàä™Pñô\ş»òê¨{Pw p,¨/ƒ^›PÓ«+îó"‹;jj PÆA€ó"‹;–ªPk™7U< ¨P?S€#ŒÂªPÎä‰%«,°}?( Pæú€«,°}LØP*»\ÂED9L ®PW€^_úİP(KY¾Hv€«l PÆA€¾Hv€—éPŒË‹Eøá¢û $
Pù€.2*Š¸ìPáÒ[7<ãÀÎPò¢ âö»îÚîPÓ™åj)ëµwU7P"€à×›ñP^£iének˜Û-Pw pfú^ÊİóPìù¡yo&j PÆA€yoÎ'QÒ\†«~¶¥Ò ªPormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data) ||
      utils$1.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && sta‡W…2ø5páP¢ R{4!€q=	a…V¼Ú»Ïªñ? ŒPo€zéd@Õd…ç:“@Á<j PÆA€“@Áğf…ôSƒÆR‡Õ 4P×r ”½&î~…Óİ_ËkScÀu P’¾€kScH…¤Ûƒú=B?P;  pìZôz!Œ…Ø‚×&Eİ(“ êP‘;€ØÚr¼ª…çmÑô—®  Pœ€I±ÄbÙ¬…Úğ”J÷‰	 †Pˆ€ß’œ ş¶…hVì‘"â^Ë"P  pu‹B„¸…›8ß¤ªJj‹ °Pùi€å²C%›¹…¿or3„?r	Pb¢€¶™õOÍ…‹!Wø 2µ Â Pª)€ø 2µ„ó…‚5…0×x	P•4‚ìzı…~h<’ñ½g¥ NP¼µ€õù¶†n¨eœ †PÀ€*µ1Ô†—Ø´õÕíø…Ãˆ@£ ®|%‚(†îõâ®¡²ÛD & @½Y€ÍHY©³(†t>škıQw à PB®€kıQwh3†”Ö/¹ıü¾ ØPGÓ€¯
M;†{M9•QûÍk PÆA€•Qû%F†ˆw¸ƒãdlyVk PÆA€ãdlyíR†™­_| šfPN€€ Š;À^Y†P›ÑŠşğ}
PÉ€ğFvh~†25vé‘ Ô Pıo€x’ V†©F²§Ôâ§Ú  Pù€Ôâ§ÚE€†PNÄï3í‰DZİ!E	 Pû ›…†LM2†ÇÕÉ ˆP¿´€¨‰ q”†/İ‘üôn¶ˆ@£ ÅRšô—†°æì^SFª&Œ PJ,€^SFª¢†ÜÔğ‚6@{ø€„rh™¤†Mç‚ª¾ÖŞ<¬™ PJ,€¾ÖŞ<x¦†6ËLééåÄ¸ PÆA€éåc¨†£Æ+ßTh§„ş‡ PJ,€Th§„±†XÂxI©ü5äPéí€ß°	¼½†±±p¿Ñ PB®€vÜëE=Ë†ÙK‚Iä²så? Pg†€ä²s;Ì†bp‚J=Oî:óˆ@£ Pv%ñÏ†È­7¸lò ˆ;P2 ÃÂàÀÑ†CJs‚3Ùh­P*P€w›T.Ù†jÊ×7ßè ~#PS;s“¥—_‡¸âs‹‹g#Š 0=€|ƒ !‡‚¡'yõ´š" êPî€?ãåXÂ#‡•ë²«ôÓ  PƒN €c_î-‡³©Sx„U¶å P€x„U¶’<‡¾Ô#¹›i0ÈP~ p=èTcj@‡Ã'ßµş½°?PÚ7lûèd¨M‡L­`Ìy¼› À Pe€y¼›mW‡ûNmNªœÎ]k PÆA€ªœÎZ‡@–Ï²ÙÀ›]  P  pço¥2—b‡µ¢Zqÿ)P * Pø‹€qÿ)P‹‡ª‰Şô0:j PW€•DHa‡QÖ5Â¢ P7€…ké}“‡·ÎmŞÔ-› ²P¡¿€ââ‡²İ›‡–U;éÿi5 p PÁj€ÿi5œª‡¬_óéQŞ\jşPÆA€' o¸º³‡™fãFÜÆï_- @Ö€FÜÆïµ‡ 29	+*ö`PÇF  µÒ1¨Í‡şUu¢ˆ û5*òPf6€ÁömuªÒ‡k!˜•°hC
 |P»î€¼ú¤ƒ"Ó‡·µw1ŞdCX9©AYA€%­'O÷ê‡,”1X‹aˆùP¸Ñ€œ·ğïÆˆ?®!FMïî 8PõÓ€šN±b]ˆÆÂ^´Mğ’P6 ëC»ˆwKÊ"?m~öPB}€T¸¢©ˆ«|6WóÒ‰ (Pşj€'¬ùúˆş¯íf·ÔqÙÄPî  pSŞ9>ˆû—´à¡éMNgPêe€0ZÙ>ˆ¾;×	e‰~Pêe€•X@3>ˆ~wàã2-tÕfPY ÀcĞ>ˆ¿ùõàè€­C¬P_g€«#_½>ˆ¹êF8Më¶úPêe€´â ¸$ˆ ,ı°¡2M/ âP|É€GÙ÷2P%ˆQ¼\<vcFXIPçü Ñ};
EˆUèÖ(Ñv  è¨S{­€ï¿Ï¦Pˆın—ÿğúi PÆA€—ÿğ›Uˆ)!ºL½™È! „Pz pÒ"6Xfˆt_,ğ·c1RPØ™€B¶İßÇkˆ\d¥»õ¤± ² P	7õ¤±krˆ§ÇR&2²®# NP>˜€<e.+…ˆjAÒş®ÔRPÆA€™pk?’†ˆicĞº<FWéV€AqUˆ”4¶¸€ñÅZ‹ PJ,€¸€ñÅ—ˆÊ±´t…IH]Qe91Ë……hªˆˆ×($ùü€½k PÆA€ùü€hªˆt—y|ø‡xsŠj PÆA€ø‡xs¯ˆN!tá®c  P?S€dN'ÁËˆv*}³<áó0k7PÓ7ErËíÒÏˆ3‚<Ã§­ĞŸP‘;€d8lHğØˆ`Ÿ¯ÅÍá PÓ€‚'4«yÙˆs{9¼‰ # P¬/€9¼‰HãˆBVš\A¥* <@|É€3ˆêˆ‘3&âŞq—( 0,€üé °íˆ¸D«ÏÔnü ,P1(€›aGÊíˆÆ{ˆÀÛfã  PÍV€Êx¼²,îˆ£3ŞF¿ÿì 0K°€ ö “ùˆ…æÍı{ÓÙ˜!P b€û†@sÜùˆíe9£ÏÁ €P_€z4Ş„	‰ƒHæ+Ÿİ6&¯P5#€g¿2ö‰06`ñ¶u¡æ½ó PÆA€¶u¡æÎ‰ ¾u“¿'a‡pÌzPw p†fqº ‰úÎd:ğï_I ‚;@€"€Å	8É.‰ÛZM7îJH7P%9°Ôªá:5‰ÅJ0Ì46d N PÓ€Ì46dBQ‰1À×Ñ&Õ X P™Œ€Ñ&ÕCR‰ËiVi+Ê¸|PÅn€?Ö¹×|s‰ŞAŸ»ãè|Pru€¿|ô²¸„‰9&bEÚ\jQ®Pß €É{§Á¸„‰"†÷`Ú\j;¬Pfi€½Ü=Õ¸„‰TÁ‰eÚ\j`¯PH¼€`sx¸„‰*îğ‹Ú\jJ­Pß €ìW ì¸„‰™-˜ŒÚ\j\°P“º€Z|°Ô¸„‰Ëé¸Ú\j‘¯Pß €qG„.¸„‰<çô¹Ú\j±±P¿€¢ıó¥¸„‰;&.½Ú\j›¯Pß €Rït¸„‰ÛŸ«ËÚ\jˆ³P¸Ñ€ñ<‡§ˆ‰îÿã8ÙÕb°ÓPÔ7˜ˆ÷sN§‰iç
LÇROªZk PÆA€ÇROª ­‰öÎÖ?€£¸63PÈANÓz°‰¿¶Ë²æ LP<€İß¶‰´‰*|ÙşÒ¥e¨ èPx>€™m5˜Ã¶‰o%…¢&]ƒ PÆA€…¢&ã¹‰ûNmN1÷}­Yk PÆA€1÷}­j½‰®s•v¦÷ ’P;  p.à\q ğ‰Ëjoñ¼>t œPµÏ€`ªW¦ö‰ÙßáÉóÎ
PÆA€Ô!Vóü‰Å‘Ùİ
u@#P%DÌ_¢Š¶oğßˆµÇ \P|É€™ê‡‚ 1Šfé—LdR  0s€€	 ë:Š^A«—æ± °P[€Ş²`9£AŠK³8 J;N.j PÆA€ J;NïFŠîÿã8##N Ğ@X‚€FÅ°ŒMŠª%AŠGw šaPË€€+Àt¯)OŠÄxAâvİ ôaPé V€—ĞLYŠÿî¬ÉÆñˆ BP’¾€Çî·<DdŠ&éÂn3ò¿i PÆA€n3òLeŠvãŸGd¬q˜×PP¬6€„}‰LeŠöÒd¬q˜!8FP¬6€ÊoTúLeŠ6Ú¹d¬q˜¸°HP¬6€ˆ3Ê=£fŠ‹gd@‡Ä2P{4 bt‹hŠˆ×($Á9FÅk PÆA€Á9F‹hŠ½_Ù±·;~æi PÆA€·;~˜~ŠdÈcJ‡=pi PÔ2J‡=SŒŠAİşE‚ &Pïq€(UIg/”Š*vE‚ÇAË èP7€|íD¨Š2‡iuAS¸|Wk PÆA€AS¸|‘¼Š²€ÁÄKj·ò Pª€¬RÕÜÚŠ½P¸ò±ìÎœH	@£  Üô"˜‹÷"íèä ĞPUî€a-0•p‹­›éAíj PÆA€éAú‹€›n‘c‡¼×à@i©€ÃÌ0•//‹}ó º"È?Eè Pº2€"È?Eü;‹Jş
I÷C‹¹Pn‹€”³¹€†G‹ìÅËÌkØÒQûi PÆA€kØÒQ†G‹‰ìÑHzã|³¹i PÆA€zã|³c~‹-aÀœq8® fPÖ@€.µ‚úS„‹ı¾†D„ü¦Ä ,\PÑ¬ ’¢ z°‹$â5KÎ5+,`ÛPÊG ¶›ó³‹ˆÒƒD*eÊóPÆA€O5¹|´‹K³8r8ñ6j PÆA€r8ñ”¶‹x¦zóü'f P>˜€x—”$@Ê‹sb" hÊ¨•P;  p%O:,‰à‹/ZSp´j¼HÇ D	  ´ Èü‹n$µ…ÙŒ/HÀïP~ p,Íuìñ	Œá1¬P^"¯^ğÔ3Pº pÍ ©Œ	M*ù7Cşf~ PÆA€7CşfÕŒ:!‡Ò  DPÑ €]zªëŒ.©Í8Aø  @a¤€ˆRB‘§Œ®ĞdÌÏz  ~Pf6€›Â«Œ˜óÎ%vÕœi PÆA€%vÕ?ŒBáÜr:ÒÛğ Q6qó?Œ;]şr:ÒÛX¸—Q6.\+¿ê#Œ×ÆçEY… `#PÆA€G|HÂ@.ŒÑşsÀbÎk5Sk PÆA€bÎk5ĞIŒé|G»¤ ’PĞ À|{› PNŒ²FoØ”² è Pe€”²|QŒ-ÖË"hñù” 0ÆA€¼– fŒ•áï‘¡õÃÇ 0K°€4ö ÏvŒŞ¸
=Òn ìP;  piÉk%±‡Œšèø\”²Š PJ,€ø\”ŒŒÉ™Ğ\áÏ1ôº Pí‘€áÏ1ô4ŒWó8â±v f@i©€½ı¸˜Œ½_Ù±!´"N×i PÆA€!´"N˜Œˆ×($8].a¶k PÆA€8].aôœŒ6Gˆ	†V®2 &PN®€—¾‹,'¦Œ° ÕªÇDÃ)  Püş€	y–·ŒÅÏ+¥­‰ -P2/€‰¸.³»ŒÂNàÄ</ş÷ Ğ  D	 ´ ¼ÃŒzF\ÅA6éù¹  Fñ€¼î SÓŒcGt8íé¢7üàPáG€¨HRƒSÓŒá8ıiíé¢7üàPáG€*7ÛÒSÓŒn¶.£íé¢7üàPáG€¥¹SÓŒéÙ°íé¢7ûàPáG€O¤ÙŒÑŸE´ä³)1k PÆA€ä³)şßŒíêZ¥0¤ÀÍš PP¾€¥0¤ÀÍìŒùZR)ğy|òˆ@£ `®$/òŒ–bÌ~˜W•| Ê PÓ€˜W•|ÉöŒ)Ú@	©B XP*€rÙÇøŒ¿I´)í½yÑ@)H€Ü¨PøŒ¯{¾º)í½  ĞQ<€
ÌíVøŒãFÌî)í½ÿÿÿ_<€€y Û Qö@¼gŸ Ò P?S€¼gŸ	L Š˜º  Pg†€Š˜º\¢9ñ@˜£bkÍ  y‚€Üe Ád@»H-æÍæk PÆA€-æÍæ8 °áo¸iæàs
@•¹€oÃ¢g	-+d'e9äê >PW€U‚Òv(1]â2ñMGÑ,éPf 	ËxçÙD¿)cËG ¬ PB®€GÌLîÿã8Ÿãî¸ P›c€"55	N.(e\z¡ `P¿i€pÃjªtPsrG÷¡„ç PJ,€÷¡„_T2‡iu¼ñ*^k PÆA€¼ñ*’U<GÔôØK ŞPV	€³Ld—’U/?÷yôØK Ş@m±€/İt*†b‰QM“b™ˆ %PAjü^nD‹FĞ§ú= ¡Pß¨€y-LH‹vâ˜µ…»û°\P  p`Bp26¬Ød zk@Ğ‡€bçª÷* îÿã8 €ğˆ 0+Pt+€¸«?Š Hb0³°N4¬›PX¤€ü¬ÇŒ·îÿã8Õå– ”PU…€Ï:×¤iÃ?;R5l, 0PP¾€uõË£ªÕr7+ÊKñ•¾Ë Pğ¹€Kñ•¾"ál×RV“š 0ÆA€Ğ– ‰ç‚¬Æà‰<^ è	P2/€ÖnMG¸í¼_ucº @GP¶3€ğhRİô9¿Âaß7{F®PÍ)€p™oĞi2ÓÏ˜Ëø`Ãr¶GPGÓ€4ê+ Ğ7s½Áê: Pgÿ€ººÑ‹«#†q#Õ 0,€ê Ó'ìÅËÌïJ<Tıi PÆA€ïJ<T;Bìù¡å’I—j PÆA€å’I—JB¹q¢ªôhô¨  PÅf€¬,)
$\a“<Ëêy<r2c@·{€ŞC¦]ÆJš}HGÀ†ªÁ PÆA€HGÀ†‡jù€kæ«ç 0D	 (´ ŠjÏz¸J)-v bPW€MioküwÚ!’©—ùğ27Pƒ6ƒ–†ty‰ãµ,d	 L PŞe€,d	 uÒ>”øñ@:ã™TPŠ€ÏÒ‘Ø}ûNmNXq,`k PÆA€Xq,HÊ}UÊ‰ó„B XP„Z€t;ğqÏÒºoT—m<¡ÏvPÆA€ş.;Ä¦â(ßäm!üÜ àPıÆ€ªtfÀú'ä›¨OF°3Ø/.PÓ7ã_/a½Q£’>Cl˜ÅÏˆ@£ m­“ĞºN@ï4/ÀP"€eOnèV¾§ûï4/ xPU À)_`2W$*3Köª" HPÀÇ€¡Ñ˜ıÖY÷]ç!°‹8 ŞPŠ4€Ïw¬&á2‡iu[ó	bZk PÆA€[ó	bQ7Pä»ÿ0ò †PÆA€í?‰¾´G&8o³èV¡?k PÆA€èV¡J¢5AË»¿sy P÷ô€×EŠù¤Zw9		Ëd-0„ P=˜€Ëd-µ_IüŸJ„| âPî€ÓËM*e.zPU6ÄnnP,t€ĞÙøğè‚ıúğ»¸T'± P’T€B+Kóu„îŠBõxÉn¤j PÆA€õxÉn¨øÀ,ØÌé&³k PÆA€ØÌé&Xîÿã8*œ*Ç œPÀ€Æ.³‹¬•wY5µ-å5<ÜP3€„\®/ºõ¶ e­Œ
 " @i©€­Œ
´½B'J®ÖÒ¡8 P8é€¡*ã}‹Áğ6ØŞÀ àùæBRè"€›íggØÄˆ)¨'@Ozï PPõ€öÆ,ŠÈûNmN}*ÖmYk PÆA€}*ÖmGÍÄêˆ:h*øpSpPÑ¬ Q_'½·×)ÚÏ†ÇaD \PÓ2€§m¸Tßx§ñáäC—äD@U› zîˆ·õ‚™ÁŠiù™¼i PÆA€Šiù™ßö<ü÷’[Ÿ!±P9  p˜Ó)÷Y÷]çñå¶… ìP’¾€$À=¼¤÷â¯y·%Lx xPk€KÃiïdúúZµn•³# ¢PB®€T}í)!ç5® æè 'O½ Pg†€æè '!ä*Æ³ş–t¾L½ Pg†€ş–t¾
qÇ”45Ë PÆA€ïœ&‘$¢]HîúXA3PZ6€µVÀô¸/oG˜ "ä  @i©€"ä¸/oG˜ "ä  Pê®€"ä¨Cì{8=o¹j PÆA€=o½K-š2#PÏ5Éz	 0ÆA€ä– ¾h¾ÄË®pÑŠ(î¥Á F	 dû ôj]	ÃTÄÖÇnœ Pµ«€TÄÖÇ’”îÿã8@¶sK 1PB®€Š'yWë–mFÙy•˜PÆA€=Qï´š‹÷K¡!±P€œ¹?ˆ”5·ÂjØlZ­ PJ,€ÂjØlè øÀ,û¸ì±k PÆA€û¸ì_ªà¥C8ïsÁ
  Pß% *•“L_ªà¥C8×“È.  Pß% ”·ü_ªà¥C8ò8  Pß% ºË9_ªà¥C8Ğc  Pß% É_…_ªà¥C8#oª  Pß% Iå´!<Æ&éÂüT‚½i PÆA€üT‚çĞ§«ò2&VT >PW€ğk«³êÚz‘ñ]¼ÓXê j	P|É€ò×i İOE)µÍ©  P¼a€´íìù¡©Pçj PÆA€©Pçã	‘zLš‚vd{ ŒP|É€Dµã‘
‘«ÿ?°ÎĞ´ Š
Plø ‚êDà‘|êfõÃ„3 0	Pö'€1ı‘üä[~Ó1€‹èG P+T€Ó1€‹N*‘]‡¤şœ\ €†@y~€ç‰ü#N*‘]‡¤şœ\ €†P;  pç‰ü#*>‘îÿã8>Ç\/ ŠP‡É€ã8T`E‘éi—à€Ú,u€P‡€€£`Ÿç`E‘ğ­úç€Ú,u€P‡€€º¤òàŸK‘&éÂRïA¸ºi PÆA€RïA¸mW‘&éÂûV9ĞÅi PÆA€ûV9ĞZ‘y®ñôzÕ6ì  0Ê] €d+  †i‘ñ¡¶ÕQ©C ^
PÓ€;…óJªl‘¬B•ITªI6G#	Pó€…gø,¦m‘(Ÿt›~mP 2Pès€D2Rıp‘ò»õşSıK B PÆA€SıKx‘wq˜5"G| ˆ@£ şûú\m‘ç8C¿tZçíh€ Pßô€tZçíy–‘ ²$Ÿ0( ¼PË€Í'IIn£‘ÕıršTccˆ@£ mxÔĞè¿‘gš©åÕÖJ zP¥ˆ€"¶ê‹À‘­^N¢ÿÀg PÆA€N¢ÿ®À‘DÅÚ¥:Y ^PW€ß¹ÈÌ®Î‘EgjÅöÒ(®Pf9UCN7Ö‘ '­ÔT°mRˆPg†€]½ÍM÷Ö‘iv`¨šäêá ”PÆA€v¾³-å‘æõØ³3¡Ì“ r*@ÚK€	ºÄú‘ü	õw®[6$ Pº2€w®[ş‘%#Rs‰Ü|H  (Ÿ€0= I’ú¡m°ä_ô¡  P>ğ€ä_ô¡6’È+Œ°ù?Ò PP©€f–‘9 ’*[1ØÎüÂ° "8Pk†€0Å{#’ÿ™æÅ7A‚ÊøØFAÚK€õs€ÆÓ2’ı7Lv* D PŸu€v*’=’E™'Fø+àß P­h€Fø+1L’îÿã8H²> ôPc€¨-`wŠQ’ÉÖ_ßPY PÌô€_ßPœU’5™˜}Á{ÒN à	PÊî€ÆóoŒô_’{¨-b	Z­¥  P'.€	Z­¥|f’#Ø ~gŠ0Ğè)PZ5OgH¤´’îÿã8ßA2 à PóÓ€ßA2õ‰’,%í¿°iÆ(®j PÆA€°iÆ(–’ğá^ÛŸ ^p  0aP €\  Â˜’´k¶œË†k ş PB®€œË†k;›’<|´àT¥J¡(P €¦\Ïò›’ÔX!Šmö¹Pg†€ŒÄ7GÈ¶’ıxG)Õ§Ÿ) ¼PÆA€qæ[Î’>IN»ÙÆµj€U Pª)€ÙÆµj“Ó’ª
Ë”+¸ âPGÓ€‹/¬Vzó’iç
L0†rõRk PÆA€0†rõ”)“·Ÿ=ïgqØV 8PÊ‘€Ï
ã€6“f¬AİjğÍP  pw€JG“}’7‰o‡­” DPW€ˆí[7HN“¦7H=¯rF \PõÓ€ÅÂòe1P“ìù¡3IDj PÆA€3IDÏW“=À8LE³ 2P E  Yy(o“îÿã8Ï÷u¤RPØ«€eŒL’[“ôÈc ¸#0®@i©€8=[æ«“Ï"aÙgnİ àPf6€™Š„æ¬±“kíüˆ¯`ŠP>
 ÀçãXç\¸“iç
L«¹ôOk PÆA€«¹ônº“d~{	I›Ÿ R P‡€	I›Ÿ‹º“Tî^PÊF	NÂ P b€PÊF	™Ê“Æ#\ïØ¾#‡  PÃ9€!ŠÕñà“ÍFlx.­ó°l PÆA€x.­óWü“q¿(gnFPî,€Æ#‰¼­ü“C'{†¢ ã P Pª)€†¢ ãø”wO_çô’œÖPí%€şx÷ï;"”¦í¶±7»  (PÕs€ªÛÄ½*”“…ô­@ZÚŸàk Pg†€@ZÚŸ½*”‚zNc©4\¼íj PÆA€©4\¼w4”v÷–Äi%¤· 0º€€S ş6”Ù|hMh|ñx`Â¡Fõ€{%î¬\œ”­^9š'ŸÅg PÆA€9š'Ÿw¢”(KYÈg™û¬l PÆA€Èg™ûÍ®”&éÂ"Åi PÆA€"2¸”¥ùÅX ªPµl€°ha°SÊ”|¸tµ„ˆ `ZQz pãñ¨°SÊ”|¸tµ„ˆ `ZQ# pãñ¨°”ß”É9bÀ×ó­ŸÒ PI¡€×ó­Ÿ»ó”!p]½ù @PÈ²€Fÿ­!ô”1}@PLkw ÎPÀ¶€©û×ø”ı¹gQ“Õ ÂP—g€™hL=#•XxØoVè£bĞ Plx€oVè£P'•‚l¢,Ä9É@´/P  pˆ2úéM)•º±ÿ/È  äP¡€/ná=•ÚÊN¤Y0 ÀP“=€Q@­™\@•Ë6ƒ3ÔçÑ  ş @i©€ÔçÑ ŒJ•î…ÿ¶)lv :P)€Hdp‹¿P•êYP’†ÖÍ’² PZ„€†ÖÍ’€T•çz„LŒLa ¨PÆA€yúá\•ÃÉaÛG=—SßPxq€êİåU`•îÿã8HÍV’ 2P×r pÑGµv•s‡·ëLöÊÈõP  pgˆ_İw•¾¸œoÌÑ@P’¾€ÖÅÂÄ@•Ö­È¡ZN+ †PDÆ€6}®Õd†•ÿî¬jjJ( 'P+¡€5p×{ˆ•×–ò
ì Ê
Pl€D¢0Ã•Ú\|›3#ø’0_	P¤u€¼Ñpz&Ç•T=üm:I ·m
PÆA€/×Fx&ã•&8o³:qIJk PÆA€:qI~í•*6‡¬¼Qx P  p)4šøKõ•¾8f*ŸSàj PÆA€ŸSà
–ÖÍ\ãGœ*Pp·€H¥¤~–&¢­Vkmmp‘	P  pöí¢&–‘pOĞgJSi "PÓC l›u
ë;–P}DÁ~Ï øP¤€M§¤cÏD–xÆŞõqyÀp ¨PÆA€VçŸúZI–$õ™z€¾ ,P|€€‘©ê K–Úóg:y×À¾¬ PÆA€y×ÀêU–ŸY%õ	fü Pi©€<1İNe–´-‚"“oNt òP‘;€²¥Lûk–~e¬QñDĞ pPÆA€n–G[Œ¥`ë0 YPf6€3»S@Xu–R¶V=XŒ¶Ÿ™PL€ÂM@,Z{–]ã¿Ò
]i° &Pl€~áN¡ƒ–=ŠW+æ”½  0Sg90¢³.¤–q– t± P Pi©€ t±¤¦–.Y
ÎT^õ >Pû[€3Sš­–¼ğY½¶L6(@·n€Œq”·–æˆ7*5Ô"8/!@€H€=írÆÑŞ–ĞŞTG»ÄŠ©P59¿8xâ–·*Ôòcä x#P˜¸€PÆÈßßç–‡¸À1Ê&Ù ŞP¤[€/Ä½ßı–iµ]Íbã'ÆIl PÆA€bã'Æ­—nŸş+àÿå ÖPÁ€Ö¶Ê Œ—ğnå4{÷k JPz€“ıIs=—=P»[‰‘Å¥@Pœ À·gZì—½´5€ù¢ zP7€›Ìu$û—šù`š|ÉÚ¾/P$«€|ñù$—!é y´vhp² PÆA€´vh)—š/r£ì‹- ø@£ ¨°‰Öı)—Ø«øş¥;³l 0D	 <´ Q1—R§¿4Q/B% Pº2€4Q/75—h05b ô‚ï "
PGÓ€úàºC:—§+üx§Fúp+gQw põ1ÄO=—^eí$Eöù P;  p(#Ÿ,mM—gŞØ¯dñj PÆA€Ø¯dËR—\CÅæ2.X8t 0Ù~€\? İU—²‡İi'7Dl PÆA€i'7Q—€ÿ(ğtÜ
äXQ:S3òÈÓ”—Z{«ÀÜ5Ó zPÓ€*ä©—şovÛôğ“ñ 0ÂÉ€`g ¥—)[Ú•Ü’ pPGÓ€(|ÜÖ¯—iÃû£¹şsx8¦@,ë€‘Å>Ö¯—iÃû£¹şsx8¦P,ë€‘Å>N¸—×BÈbzœ2^PB®€qŸœÃ¼—‚zNc%€1¢ëj PÆA€%€1¢ÇÃ—¬ºL! äPî€ÜS†±ÁÍ—‚"ûœ¼ñ« ğPÙ«€t:„/Î—ëõoÃÛQÀ @/E  ¸%=lÌØ—QX]kV?Ì6 PÆA€]kV?<ä—Å¼«¼T}İt òPÀL €z±Zÿ§ê—nW!†•“ k L Pú€•“ k>ï—Ø¦ó yƒøp§èPf=û)bÿú—Œ¥œ§xav 4Pó€Fá»„˜ÊÿtáUcPµ«€6ffÌ˜©he¦ğYq Pí‘€¦ğÔ˜àVG4`€ øP\¤€È9ô±,˜ìÒJË†X Pù€•óñÁ:˜–Ì¶VÇ© Æ PB®€Ç©}B˜:ªıÉ
òûÔK @ƒ€
òûÔAR˜qÓïÔû  °
P[{€¯A0cıZ˜†›!f¡E 9PY5mz÷An˜aÌw×³@¿š „
@¼µ€¼jú¢r˜æÉ+:æ†ª,ti PÆA€æ†ª,pw˜Öa³æÓÿª úP×€D“["Š˜éªªûöı» N
PÅf€Koèp‘˜fJ@#R7P PW€C¹K°³—˜	£n \¤aè¬KP¿6œßÓ”3›˜ĞÓ—Çx”´1 ˆ PGÓ€x”´1Òœ˜ßÍªü¬ ®P§z€"ğ|¯g ˜Å!(/¥ª—¡]Š PJ,€¥ª—¡¡«˜Ø}K¥äC1( P.€€äC1¸˜îÿã8ùP¾ ,PÙh åi´ »˜hnsï®‰ ØP–€'Øä™À˜iµ]Í(ÓÏ.El PÆA€(ÓÏ.Æ˜	©j‰…‘¨õà£&P  p:ûÏaé˜OœDÆ`íæ  PıÆ€û" qÁö˜JÎÓ„ñ¦µì§P—e€›“M-@û˜ˆw¸ƒÚ7™Sk PÆA€Ú7™{™ÿ•%{”'
i   Px½€”'
iÿ™‘|)Å^I4Ì BPÂJ€ª;ú®(™w@Pİë² öP2/€oešõ!™ÀA	¸~°
ÔÈô+P6D€—–½,`"™\ÖÜâfÑ7hiP/:aÛ`ç*)™VÁœ£bGøÁPñ7ËñO­-™ªU9uFçõ(k PÆA€uFçõ…9™¾`äè‰1;Ú *P®€<9éä‡J™şoq†ş{Ù±\£Pİ¦ 4‹—J™Öš\6f|I2&K PN‰€f|I2ÃP™dÁ­ÁÄâ]âVøPÆA€¿Iz£ùX™™¨Š©r
œ4 PÓV€©r
t[™ö	¿åÄ¸P €ö>S„ü\™Ş)¼ÏKrbT° P(í€Krb~™zÿgéë` øPeÀ€«ƒ «‡™ÓÖÛTq­ PÚ”€Tqa”™,)xˆÅı÷ °P’¾€eè¡N•™Û6sU©0Ò €PAe €g`:aœ™¯ÍxÎ`¥ò ~P©™€O@ÍÔ“¥™ò»õş¦o²d B PÆA€¦o²dˆÆ™®ë	{Ó¼ ÒPÍ)€°¦üõáÇ™Q ,—ò³™xûAPk€hwãiCŞ™•¬3Kîfºu2–SPJ8Qš¿¢šååje`¯šEl PÆA€`¯šE4"šxÓr	âóÏˆ«BPé~€•å¬Œ @š&,´bû[ë#Ê< F	 xû ¥Jš ¤İ[ÊÃdèR  P ×€ÊÃdèàKš‘#Zr¼Æô P17€£9Lø
NšPz±L™ã ÌP€"€#€²,×Rš!õ§‚Wa0J P  p‚Wase64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
}

const kInternals = Symbol('internals');

class AxiosTransformStream extends stream__default["default"].Transform{
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1.isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

const AxiosTransformStream$1 = AxiosTransformStream;

const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};

const readBlob$1 = readBlob;

const BOUNDARY_ALPHABET = utils$1.ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = new util.TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = utils$1.isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob$1(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + utils$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!utils$1.isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = utils$1.toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  };

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return stream.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

const formDataToStream$1 = formDataToStream;

class ZlibHeaderTransformStream extends stream__default["default"].Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;

const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};

const callbackify$1 = callbackify;

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

const zlibOptions = {
  flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
  finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
};

const isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = followRedirects__default["default"];

const isHttps = /https:?/;

const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
};

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && utils$1.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!utils$1.isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
};

const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
const httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = utils$1.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new events.EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    };

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, 'http://localhost');
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream__default["default"].Readable.from(convertedData);
      }

      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new AxiosHeaders$1(),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError(
        'Unsupported protocol ' + protocol,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = AxiosHeaders$1.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = formDataToStream$1(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__default["default"].promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (utils$1.isBlob(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream__default["default"].Readable.from(readBlob$1(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data)) ; else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new AxiosError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError(
          'Request body larger than maxBodyLength limit',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());

    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = stream__default["default"].Readable.from(data, {objectMode: false});
      }

      data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils$1.isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__default["default"] : http__default["default"];
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream$1({
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new ZlibHeaderTransformStream$1());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];

      const offListeners = stream__default["default"].finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new AxiosError(
            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          'error trying to parse `config.timeout` to int',
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new CanceledError('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

const isURLSameOrigin = platform.hasStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

const cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders$1.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

const xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  let controller = new AbortController();

  let aborted;

  const onabort = function (cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
    }
  };

  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, timeout);

  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach(signal => {
        signal &&
        (signal.removeEventListener ? signal.removeEventListener('abort', onabort) : signal.unsubscribe(onabort));
      });
      signals = null;
    }
  };

  signals.forEach((signal) => signal && signal.addEventListener && signal.addEventListener('abort', onabort));

  const {signal} = controller;

  signal.unsubscribe = unsubscribe;

  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};

const composeSignals$1 = composeSignals;

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize, encode) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : (await encode(String(chunk))), chunkSize);
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {
  const iterator = readBytes(stream, chunkSize, encode);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$1.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$1.isBlob(body)) {
    return body.size;
  }

  if(utils$1.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }

  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$1.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let [composedSignal, stopTimeout] = (signal || cancelToken || timeout) ?
    composeSignals$1([signal, cancelToken], timeout) : [];

  let finished, request;

  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });

    finished = true;
  };

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
      }
    }

    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: withCredentials
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          isStreamResponse && onFinish();
        }, encodeText),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && onFinish();

    stopTimeout && stopTimeout();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    onFinish();

    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

const adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

const validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;

        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

const Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function canB^IJ|é@™T5À1>âR    b   *€}  Ìd^I~d!Êñ“ÁÜÛk    b   X €  )l^IaÀJUa¤ƒöÄÛ„Ì
Üe    p  ‹^IMôë*Ná—,µ±ÏÊå?Íà   h på  # ^IÂİ?Šd	]½‰d:”Ã‰âË   T pO  ËÊ^IŒ.ÈYñÕzø5uZäÊ0Ë   ƒ pK  
Ò^I Ï'Tûë	"ğº¡ßoJÊâ   S pd  ôÚ^I¬e	]Ozç¶îbãÚ   O p¡  ä^Iƒá}Pl@1ÆaÛ²î•SØ   œ p   ä^IÔUn‡üî˜PMnûTööbÛ   † pÀ  zñ^I£_YÒ íèáóÎäÙ   S pI  3÷^IDæƒÍÜâID¹Y¥†»p   O pÄ _I›şY•ğ{}Ì)]×2Y@s   O pfš  o	_I'»+Õ¤”m9I¯i-'p   O pBÏ _I¶NNÅ”¡YÍdE¹¨óä    pB   <_I°±¤ê&‡ï±p>ö‡Xp   O pG2 L_Iøı½3$»ßM[ÜÏˆ%ÉÂ›p   O pãp ùc_IÒë|]pv0Gà%ÙD§1Ø   S p>  Îw_Ia•é^0N¼;ü­5    b   _ pÌ  ƒ_Io!?;8š×ùVÔÚ    b   šŒ€µ   —_Ivùsü6ÿÓ(ª¶ÿr]Û   ñ  p   —_Iò”IïšÒœ¡3µ…HÕVŒÚ   M p™9  ¡_I=¢?ÿ#£òXSW2Gıã   M p`-  ›¡_I¹\NHÀlXÈ{Š¨oØ   S pZ  S#`I'ûvv>»OŠ=§ù•Ì   S pd3  ’#`I÷t++-KÔxİO¯‘Kk_å   d po  $$`Il œÔY…&çbÿÒÅ#Ú   O pqæ  c$`IûÛ@fØ	šîùIüŠ²EØp   we  ú0`I³e¶:X{úïÄ‰hp   O p}± Ä4`IHĞú¸šb¸šÇJÑ9ƒ    pb…  07`Ik3h¶#¹¬ÍßHèšÔ§ä   • pD  8|`IŸI˜JÅÎôV½1é|¦ä   ’ pX  6£`I*ßVê,ıVÌê¢L¾>ÿÙ   O p¡  ×Ó`IÕ]Ş1rØàÌ/¼ÛşwÌ   M p|÷  6ç`I_Í9ı ßy:”Á(ˆáÙÙ   ò pZ  aIëÔ‚ô¶×Ä¥àN;5Ì   O p^z  „2aIá¦ó‹ô’ñ¨¾W»¸ÌùÑä   ‘ p…  Œ3aIé}vš[³VjÂg]_Ì   O p¦. ÂeaIè†|/:+×óï34–˜c±s   ¼ø  3faI1LÈáSĞdƒ“¹Jç`5Ø   S pz"  ÖoaIFáÃe	o¥— ó.X¥zPÌ   n p  Ô„aI%àşF"Ñ>eøËşCzœâ   y  ÉaIÚÀQc²4îòî •íûÛ   O p  3aI¯jÆïÁ¦R4/<r¸×¦·‚İ    p  Å³aI£t4H³–3ŞŒ©D    Í   O p ÌaI&İˆÂWì'xPC    b   S p¬S  L bI3¹¶“ğ¤€£N…]Æ•ãÌ   \ põ%  bIşíä!	40 ·¥woî™Ø   [ pI  72bIÎ‹G[<½]½™Á3ÒpOÌ   /&µ   =bIH{¥[O­†âW«óLÛ   T p  3>bIµuîó$íÊ"W;ºÖÏ³Ù   M pŸO  |ibIÆ°!ëg‹<·‰²›è?w{Ë   S pÃI   lbI…tFIc|à|×“c0»Qp   O pÛ  &sbIUÊ²9í²´û¸ó¾xêÖşä   ” p  ÙbIxW+l çü¼ø& GH÷s   O pE ÑšbIPòan×1¦b¾wplÅ/ã   O pÕ* •¦bIï¥Üw„¯Ó
œjÚš‡&Ù   N pl  7ğbIMÿˆC 
œÒ²{;Zæ2s   ¼ø  UcIİªPÓ¿£5OoŸp½üÛ   O p€ FcI{'vµ(ÒAsû (”Âã   O p–Q ](cI huóÀ~mp&&C8'ûÓ   O ps˜ n.cIæC˜„fÆ¤"î»    b   Dl    Ï.cIÉmBY6 9Äş´‘h    b   òp€Ş   \9cIÎ¸r=–ÿP¡	f„ä   — px  Ç9cIñäZ~GM„›‡©8±_p   O pM "dcIM 0öß“G¿h=¸|'M©OÓ   ˆ p  JvcIPº¾ºšK­4‹¦Q¸ÿc—Ì   \ p`%  ¾ŠcI§*ªJ>â}Á–Zb›ĞeÚ   O pé Ø‹cIpuìêJòf­s |°[á   O pWB ¦“cIŒPºÀ—EÎÂ#Ia'ZÃˆ¶ä   ó pº  u•cIDŞ¨ÒRöƒùË*!¥×   Y`€    ¡›cI´
–MÓ8ı§;2GÃsp   O pM} {ŸcIfçÒKrf6«ékğÀ"l    pıS  ¥cIpÚÜjÇ~~PEØˆKá¯M   ¿   W¥cI¥s,ñû‰•¼b~ÇRÓKÌ   S pµ5  ¥cI(¿!Ëªà†˜ûêV    b   ¼µ€†  5ÂcIvmiud0VE«œiiÀMéÌ   N p  èÔcIô<ßãB+?×¨æıİ	’ôÌ   \ p [  ÏÚcIÙ×¹ F–şpÚgŞ\TÌ   O p8% 6ìcI‡ úÕŒÊl]'K$Ûkğä    pÊ  hÿcIoJâSYF™¬‡r*…
0    pG  •dI–GùE²w±ñt»õ´iÓp   O p}O é:dI·˜XŸ,¾ó×nác•j=ÃÅp   O pÑy MdI`å€~+LS@/^QS¬İ   M pT  ĞcdI!®Ã‰ıø?ˆ)…ÛP”ÊšË   œ   ÂsdIĞFi’Ü1¾e„®KabÚ   O pö÷ ^˜dI\9z¹aàÅÙuAõÚ   O pÇœ ³¹dI3VåKmr<Rx²g7fñîs   O pœÀ Í¹dIOßÛG“Ò¦lÒ™»Ë   r pc  ¸ÔdI\u#yq(n[.÷HØÓdÙ   Ã pT  lÛdIäØd¶q·üÑY¼Ap   O påÈ nßdI²6JÎ\nâ*~,•yé~Ó   O pÙÎ ÙğdI¨¥ZÏZ&/÷Ë‡vQÛâ   O pùF .õdIXâ÷ßïp~ˆÓ˜…cÛ   O p‘ `ødI?M’‹ÇÍ„“9dY§éÛ   O p¤ Ğ0eIşoíÆìÁ´H±“¾¹Ø   S pw  cFeI{-ŠêM³¦tlšˆË   ^ p>
  ãMeI„ÅjÈàv7Â#é¥.¸Û   P pU  ²áeI‹$¦m˜úysr½È ÒCöÛ   S pCg  àøeI²`$õ^5¥î©¹óÌ%   ›Î €à  X
fIbá%\ì#TüÚÏóa6[½ƒp   O póˆ ÀfIiRÛŞ‡ÌIMœkíâ   w pg  ·fIOoùOµñQÀ© Ú   Q p8  +#fIõkÿZĞ#IˆÜ-Œ®üò²ä    p4  áOfIVğL£nœ—(Í-ßVbÌ   O pÃ_ ccfIŠ8TôVSäèêà´³¾Ø   R pª  §fI´ú®±B’/G·²ÓLÛ   O pÙ‹  µÖfIJh9¿ûó¥ÏõË˜».ÔıÌ   | pf  gIzŒ>¢L,†×dŒ„DiİË   M pÿ  µgIEó¾¨Ê.õôŒ    b   ë p<)  ^gIcÊ˜h¡yÒîV„Ëg3…p   O p	› Ò(gIñY‚|,•÷Jt¸c«ûÒŸÌ    p@  -KgIÑ——±×eAL÷¯„ËÅ·ä   • p$  ÚNgI×@Ñì°°'ç`µÜ=Éğİp   Z p+W  †UgIfcEU¡×Œú´×]Æ #Ì   \ pæ9  ygIá’R°K¼’k|fµ0|İ    pÊ   ¢ gI©¥a'R/2
èÖì¬¡)ø    p…n  ¶©gIQéFrrÁ;9)³ëÙSs   !€¯   ›³gIìH|´7İv€YÉBëÌ}Sñp   O p•g Y¶gI <¿Ğ¥¶Š‹E¼›ÿbæËÙ   ò p¿  ¢ÇgIß¾Cì#¾ÂUH‘UÕsÌ   O pò wëgI°©Œø„|öp7Gï‘ Ô²Û   O pßê ígIùì@,5%ø!´©9To‰ã   bÂ Ù   ²ıgIpM¥²	OlôŠ…éÌ   \ pˆH  hIJj\ß1ÍÔàÓb—ËÃÖìä   È pg   hI¶P¢a.F«èg {4º    pªa  JhI’“…$İä°A(¤o"AR¦ä    ’   —'hIY–Şúz'YP³£’\ÀEp   O p‡V 4hI<OÒ$Y&¢UÅéCØ¢ïïÙ   M p'  :FhI†ãDã«®À_“g,nx<Ş   O p., ÈphIøÍpƒ?fü;	(‘GËã   y p  ”hIJ?A>ïVú\®Ò6;X§$Ó   N p;  ‡hI(:XF	´YÇTHgñÓ   _ p5   íŒhI’£¢"º_‘oì°±ŒÿÛ   † pm  C•hIU+ ìka6€-ºÜ£™Ì   S pG+  qhI5ÎşWÁ_éœ]Í‰Ş   M p  kÛhIÁÎ"mƒâ½Åí+c?¤LBÚ   8 pÎ  úÜhIÆ$Å\4±Óâø%ºs   O pË³ ŞhIÈóÎ¬(ûĞ©q^ç^‹Zã   y p	  êhI¢æ»Ê,M+KÃ–KKhÌ   æC€¿  í	iI_:¤<‘¸Jï¼ü*Í ¼Ó   M pª IiIÌg*¹o?,VHæ‹”    b   ë p˜  Õ#iI1ë8ğ÷"—HÑí™„ÔØ   S p»y  9(iIÉ*j	~yé¬ ‘LƒÌ   O p¥( {NiI°Í©O—Ğıè)KÌ¨‹šÓ   ˆ pL  'diIéŒ…m˜€# QÙv2“í    p½  Ô’iIÂSd‚g™ ï.¦^Q›şÓ   Å pİ  BiI`‹è³ÁÌõ¥ıáŠ¡ø|{ä   Ç pè   c³iIÛÛ‚Öñ÷Ë¥²Ê»Ê‚µñá   a p¤  SåiI1”DB?‰_ı¸&ƒt    p9  , jIë”p\	@‹Yò[VşnÓ   bÂ c   W	jItÍµSMáN$1×¯Kp   wÙ  ÎjIŠ€x·YêñcIéè—Z;—p   Z pFR  ÜjI•ÙA$c’€Æ5õ    b   h p!  Ê6jI^)¡jÇ@VÄız¼TMò#Ø   )õ  ÈBjI¸öYÈH•ÀèFêÏ    b   X €Ü  ÄQjIçDÔ*`µæö çïÔ%ã   ` p*  TjI}ÀfÚß¹2:ç^cïÕ#   < pÕ  (`jIö‡	q[ó‡™Òk„#=WKOã   ÔÂ ”   pljIX=¡'s€-08(!Ãâ   ÃÂ ©   PvjInÀgÁ€nÚléEíô™Ùp   wŒ  ÍjI•—ís»Ç¬X8TşF_ĞòÕp   O pO ÆƒjI^®“:¨Äé³%²!ßßRä   • pL	  QjIı5»ãúÇlü2hA;    b   Õ e  B¥jI,èáİÛ±û’·+xî“ÀôØ   S p¼*  ñßjI…´•k¸È;ğÄõ¢V(>ä   ‹ p±  ¢ïjIhÕ[\ÎWi#Û@>ğs   K pU  ikIµñR‘Å¯E °øáÉÄÀp   O pû¼ ô%kIYæ­î(¸Qû8;5>VAĞä   – pi  §&kItY¨¦zO6n\‰¥¹œ¸ã   W pñ
  LkIwy+Óñºóå4B2ãä   Æ p   ÚZkIgûÛÇ