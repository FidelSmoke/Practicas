'use strict'
const proc =
  typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
      }
import EE from 'events'
import Stream from 'stream'
import stringdecoder from 'string_decoder'
const SD = stringdecoder.StringDecoder

const EOF = Symbol('EOF')
const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
const EMITTED_END = Symbol('emittedEnd')
const EMITTING_END = Symbol('emittingEnd')
const EMITTED_ERROR = Symbol('emittedError')
const CLOSED = Symbol('closed')
const READ = Symbol('read')
const FLUSH = Symbol('flush')
const FLUSHCHUNK = Symbol('flushChunk')
const ENCODING = Symbol('encoding')
const DECODER = Symbol('decoder')
const FLOWING = Symbol('flowing')
const PAUSED = Symbol('paused')
const RESUME = Symbol('resume')
const BUFFER = Symbol('buffer')
const PIPES = Symbol('pipes')
const BUFFERLENGTH = Symbol('bufferLength')
const BUFFERPUSH = Symbol('bufferPush')
const BUFFERSHIFT = Symbol('bufferShift')
const OBJECTMODE = Symbol('objectMode')
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed')
// internal event when stream has an error
const ERROR = Symbol('error')
const EMITDATA = Symbol('emitData')
const EMITEND = Symbol('emitEnd')
const EMITEND2 = Symbol('emitEnd2')
const ASYNC = Symbol('async')
const ABORT = Symbol('abort')
const ABORTED = Symbol('aborted')
const SIGNAL = Symbol('signal')

const defer = fn => Promise.resolve().then(fn)

// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'
const ASYNCITERATOR =
  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')
const ITERATOR =
  (doIter && Symbol.iterator) || Symbol('iterator not implemented')

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'

const isArrayBuffer = b =>
  b instanceof ArrayBuffer ||
  (typeof b === 'object' &&
    b.constructor &&
    b.constructor.name === 'ArrayBuffer' &&
    b.byteLength >= 0)

const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)

class Pipe {
  constructor(src, dest, opts) {
    this.src = src
    this.dest = dest
    this.opts = opts
    this.ondrain = () => src[RESUME]()
    dest.on('drain', this.ondrain)
  }
  unpipe() {
    this.dest.removeListener('drain', this.ondrain)
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors() {}
  end() {
    this.unpipe()
    if (this.opts.end) this.dest.end()
  }
}

class PipeProxyErrors extends Pipe {
  unpipe() {
    this.src.removeListener('error', this.proxyErrors)
    super.unpipe()
  }
  constructor(src, dest, opts) {
    super(src, dest, opts)
    this.proxyErrors = er => dest.emit('error', er)
    src.on('error', this.proxyErrors)
  }
}

export class Minipass extends Stream {
  constructor(options) {
    super()
    this[FLOWING] = false
    // whether we're explicitly paused
    this[PAUSED] = false
    this[PIPES] = []
    this[BUFFER] = []
    this[OBJECTMODE] = (options && options.objectMode) || false
    if (this[OBJECTMODE]) this[ENCODING] = null
    else this[ENCODING] = (options && options.encoding) || null
    if (this[ENCODING] === 'buffer') this[ENCODING] = null
    this[ASYNC] = (options && !!options.async) || false
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
    this[EOF] = false
    this[EMITTED_END] = false
    this[EMITTING_END] = false
    this[CLOSED] = false
    this[EMITTED_ERROR] = null
    this.writable = true
    this.readable = true
    this[BUFFERLENGTH] = 0
    this[DESTROYED] = false
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })
    }
    this[SIGNAL] = options && options.signal
    this[ABORTED] = false
    if (this[SIGNAL]) {
      this[SIGNAL].addEventListener('abort', () => this[ABORT]())
      if (this[SIGNAL].aborted) {
        this[ABORT]()
      }
    }
  }

  get bufferLength() {
    return this[BUFFERLENGTH]
  }

  get encoding() {
    return this[ENCODING]
  }
  set encoding(enc) {
    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')

    if (
      this[ENCODING] &&
      enc !== this[ENCODING] &&
      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
    )
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null
      if (this[BUFFER].length)
        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))
    }

    this[ENCODING] = enc
  }

  setEncoding(enc) {
    this.encoding = enc
  }

  get objectMode() {
    return this[OBJECTMODE]
  }
  set objectMode(om) {
    this[OBJECTMODE] = this[OBJECTMODE] || !!om
  }

  get ['async']() {
    return this[ASYNC]
  }
  set ['async'](a) {
    this[ASYNC] = this[ASYNC] || !!a
  }

  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true
    this.emit('abort', this[SIGNAL].reason)
    this.destroy(this[SIGNAL].reason)
  }

  get aborted() {
    return this[ABORTED]
  }
  set aborted(_) {}

  write(chunk, encoding, cb) {
    if (this[ABORTED]) return false
    if (this[EOF]) throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit(
        'error',
        Object.assign(
          new Error('Cannot call write after a stream was destroyed'),
          { code: 'ERR_STREAM_DESTROYED' }
        )
      )
      return true
    }

    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')

    if (!encoding) encoding = 'utf8'

    const fn = this[ASYNC] ? defer : f => f()

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)

      if (this.flowing) this.emit('data', chunk)
      else this[BUFFERPUSH](chunk)

      if (this[BUFFERLENGTH] !== 0) this.emit('readable')

      if (cb) fn(cb)

      return this.flowing
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0) this.emit('readable')
      if (cb) fn(cb)
      return this.flowing
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (
      typeof chunk === 'string' &&
      // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
    ) {
      chunk = Buffer.from(chunk, encoding)
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk)

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)

    if (this.flowing) this.emit('data', chunk)
    else this[BUFFERPUSH](chunk)

    if (this[BUFFERLENGTH] !== 0) this.emit('readable')

    if (cb) fn(cb)

    return this.flowing
  }

  read(n) {
    if (this[DESTROYED]) return null

    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]()
      return null
    }

    if (this[OBJECTMODE]) n = null

    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]
      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]
    }

    const ret = this[READ](n || null, this[BUFFER][0])
    this[MAYBE_EMIT_END]()
    return ret
  }

  [READ](n, chunk) {
    if (n === chunk.length || n === null) this[BUFFERSHIFT]()
    else {
      this[BUFFER][0] = chunk.slice(n)
      chunk = chunk.slice(0, n)
      this[BUFFERLENGTH] -= n
    }

    this.emit('data', chunk)

    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')

    return chunk
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === 'function') (cb = chunk), (chunk = null)
    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')
    if (chunk) this.write(chunk, encoding)
    if (cb) this.once('end', cb)
    this[EOF] = true
    this.writable = false

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED]) return

    this[PAUSED] = false
    this[FLOWING] = true
    this.emit('resume')
    if (this[BUFFER].length) this[FLUSH]()
    else if (this[EOF]) this[MAYBE_EMIT_END]()
    else this.emit('drain')
  }

  resume() {
    return this[RESUME]()
  }

  pause() {
    this[FLOWING] = false
    this[PAUSED] = true
  }

  get destroyed() {
    return this[DESTROYED]
  }

  get flowing() {
    return this[FLOWING]
  }

  get paused() {
    return this[PAUSED]
  }

  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1
    else this[BUFFERLENGTH] += chunk.length
    this[BUFFER].push(chunk)
  }

  [BUFFERSHIFT]() {
    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1
    else this[BUFFERLENGTH] -= this[BUFFER][0].length
    return this[BUFFER].shift()
  }

  [FLUSH](noDrain) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)

    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')
  }

  [FLUSHCHUNK](chunk) {
    this.emit('data', chunk)
    return this.flowing
  }

  pipe(dest, opts) {
    if (this[DESTROYED]) return

    const ended = this[EMITTED_END]
    opts = opts || {}
    if (dest === proc.stdout || dest === proc.stderr) opts.end = false
    else opts.end = opts.end !== false
    opts.proxyErrors = !!opts.proxyErrors

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end) dest.end()
    } else {
      this[PIPES].push(
        !opts.proxyErrors
          ? new Pipe(this, dest, opts)
          : new PipeProxyErrors(this, dest, opts)
      )
      if (this[ASYNC]) defer(() => this[RESUME]())
      else this[RESUME]()
    }

    return dest
  }

  unpipe(dest) {
    const p = this[PIPES].find(p => p.dest === dest)
    if (p) {
      this[PIPES].splice(this[PIPES].indexOf(p), 1)
      p.unpipe()
    }
  }

  addListener(ev, fn) {
    return this.on(ev, fn)
  }

  on(ev, fn) {
    const ret = super.on(ev, fn)
    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()
    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)
      super.emit('readable')
    else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev)
      this.removeAllListeners(ev)
    } else if (ev === 'error' && this[EMITTED_ERROR]) {
      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))
      else fn.call(this, this[EMITTED_ERROR])
    }
    return ret
  }

  get emittedEnd() {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END]() {
    if (
      !this[EMITTING_END] &&
      !this[EMITTED_END] &&
      !this[DESTROYED] &&
      this[BUFFER].length === 0 &&
      this[EOF]
    ) {
      this[EMITTING_END] = true
      this.emit('end')
      this.emit('prefinish')
      this.emit('finish')
      if (this[CLOSED]) this.emit('close')
      this[EMITTING_END] = false
Bz@!JI1eJ#JK{:,IQ@
#{ڏ66"ƴri]ьh]㉨D)쳝m~*}~z&vo}c_4s3O/;C\ɍrpZZ~- 8 8 1GG=QPV$}W.;C/W𸸇^s._v\4 R.Н{{{kp%D89KQ)0($8"XYjR1XŪe2`'J,ᑅRvneTRkD}D袋F B4|ZI@%`c(4s8Aa Ha R/{@DFH)@ D t:q
vgbxoMm35?A{MZ-)NP,)Nhі'4w(Ph-Gؓw."6BXs0D{m7,wh|qdVjD>@3
|8XXx$ZuoGK
IH]8DRpeh\Yr@0ge,,n2;+ʢ,,W=+Kb,7;+:+KW!
|栁I-,>p (;W/cx<kNaclKheY..5ƤAA)rj(@T=`w_A
UUKe媕Itƪ*tb,풌%A+v]`j&yT	Pёu`MU(,J,mʴ:a0Ud8PU'ͪ2L%k)T:e61c0M#';6)\`0SV/"E<NwiІ+@E>O2xJe8_	#f.V'Z3a((7v&ShGo鲷aTZH	g)ϕV3.VlH/)_"]tunp)Y(Y$ϕS)R۬KHKe}cg,E*Yl,R$AM@gUXVeTjU*Jb^*Kxa#׉J@/:e,k:m1cMZILwx%mDQPN P[
|ٶ,CޤH$.YXCY9H AHk&XmM~Pfq޺mpX&S3T,Kpdg/]øjU3\vyڼ[<8fìf3fYu8L8U9LmruኹWy8ދ*qZi43nϚ|}ܔ [wk;TUϞg,Zo>s(qP2GsǤ索$DI"K%dt?4^*)d֋CUU)P4QTL?aZ
<F+[	.ԋF/s"|;Tm6'̅/sYL\2KbUZi݌"Q@S	P*OQPJUIڂ~2M'&?~MzԴZSekFh@C%3x>SՄ>cdKх"H->"H.coXL2ZEe"ņݶ[[N)yI4
O|~*{J1HDMRmyMb8!@##Rigޑ>@@REꦤR\@IX3 `3˷uqSzs_,3}}n;|(5n
%H$l` S?de+_ysuhv:ӝc;eμ<vw%?<.sÎkwa!(1Z'<ϥBGOV}k?XR0v brsNe0X59"nK@D7'm?&MԂ-Ɏw6ܳ66f V
baA| DAѰʪsK+3x.윟Oih?MS~OtʺH@(W~+Zh@`}Wgf&7|aÍcgweCE;}h;Hs3߹Ϝ(h=Mxs'Zdӟ)#%,(km	P(6K6l ]Lj#|q4MQ|7hqP4J#PzX+tVl3Mki=őH	>ҳTg%I	JRUyY}JA$HN;sDRYRV" |gr[nr3	
,?M2S	$Jx!J14!PBR!@鄲HD>H?@> ݑEFn6Hk*Iˉ"QRm\bU<:KhiVGvDQ^Halaƶ8Y֛ΫUf`"{Du퉅~P,
{5{x H2E\Ǥo#&0Ç/lQ5faz;wВ]y:d<'šc%!=8un&=6/KKv]S:4rԆlVٍfC3DCАu:p~1ѓ9
E?PѝHQ$rIF @@BlDcwW
&0&_1f~4JzS"~~6X0u;o?	#,,0`jKTmVH'u'|{q(9zes93*D$ŤzaUVYgGHUU%JEf*ʒ4Ha{zl R}l!0<PPꁢ@^(ًJ%hm4D 4PqԎ- 08oֆX:k^Ch nN2]jW+y`̤ubV>Y?S"ZyP?_籓<tz@Q&=P9g?[R0ٰjPRPў,czr}P(Nnȍ
)Jsw>Ύ!.,'Iv$I3$AXq!Ɍ52@\ I$IjȰ[IAI$I$a9I Aփ%Iƪj *̪Մժ({ @A;kG?i=\?oYiglﶞpcKz$Zo}"?ԼQr=A*F	_+}[~M?y۸_gm;?፯߶ͥOz=6ݶ߹͹n,b/Y23hǑxWGv׽P#;r-;.wٟ{q&ZWCP	%*US*XIIRET<T<"yTvFHޗ*IRE^XZ&U\5b)08L0Yq08gYY%&P}X'}tc*>Et'jV{ڙܱ<;]WoxLT!OKuVa&HqBB)o-	zVe&BNL@(]%bLCzbi4֥@iM|3w-El'ޖtKQ`{8uRE9px;F 䭈xVEhE;D1w4D/`8gkh0JI,G :Zq# NNϑfO\w=  39H`1E   0ݾԀ1 &aՐF1-xO pOc:1Z   ,  ʨ1gwoO pǣ}/2\ pip[02L6   K _E R2D    pHw2^&t   DZ /C2F   lJ+2Ab    祪2M   %Ar2Z\ pOSB3d[\ pZ?lB3d[\ p<4Y3  CB Ey_3Iʐ)[3.Jr pDgD3q ]`2~3ej   	 ^ Ej	4   $Ca(4+x\ pԖ4.  GMGY44|}T p4Ȥ    g14s-    pWc:4ܭ   9L=/RY4Ñ   z3z4, m#AS4ԉ   '-  !c5ЏN  925A5@d ]`rJ5ӄ;AKЁ5Ŕ   $)JJ5  ٫\t5  V5IS pN	5MM pIKmM5ֆz  es$5}\ pvsy:6)uO p˚Qw<6;P  s "HJx6eƐbV$Z1}6]e\ p|f &6CG   Z6"   >6OJ  Z| ][7X  5/ `735   )) `(z7&)'t*$7o ? 7< p7PO pK@C8oԫS p5h[8R!S p{Qȗt8Z   S |8ᙳ8ZY   ٫8=  Fp8q   $~Y 8ǌl  O BG8<BA   inj8?l  O y8?l  O '68B9<  Q 98  M %8b  Q 8x  h ץ8  O Xl9-6   $?CЭ90XM pZ9cn  =9(m    p]9Rsu Be[1:Qkf   iw4:gJx  E'ێ:h p/+:2 I 25Mu;M=O  Utt;   aܬ;qM\  +c5pJ#<	,f   2<G   8ء:=/C  +^jF=wX  q
hao=>  f6IKmzx=XQ^ p0=`.k  A /X>\ p٥[_>ҙ\ p`~j>맳<L #
(>U?lr p֋>uI   y @N>   <>C&\ p-?r 5  Kr2?DX\ p>"25?]JÅM pI%F?  qTxˇJ?   $Yj?ޢ  [{ l?(O py?grcO p%p?۲   :ʝ?;   mzy?A8   $c;:?|гO p