#ifndef SRC_NAPI_INL_H_
#define SRC_NAPI_INL_H_

////////////////////////////////////////////////////////////////////////////////
// Node-API C++ Wrapper Classes
//
// Inline header-only implementations for "Node-API" ABI-stable C APIs for
// Node.js.
////////////////////////////////////////////////////////////////////////////////

// Note: Do not include this file directly! Include "napi.h" instead.

#include <algorithm>
#include <cstring>
#include <mutex>
#include <type_traits>
#include <utility>

namespace Napi {

#ifdef NAPI_CPP_CUSTOM_NAMESPACE
namespace NAPI_CPP_CUSTOM_NAMESPACE {
#endif

// Helpers to handle functions exposed from C++.
namespace details {

// Attach a data item to an object and delete it when the object gets
// garbage-collected.
// TODO: Replace this code with `napi_add_finalizer()` whenever it becomes
// available on all supported versions of Node.js.
template <typename FreeType>
inline napi_status AttachData(napi_env env,
                              napi_value obj,
                              FreeType* data,
                              napi_finalize finalizer = nullptr,
                              void* hint = nullptr) {
  napi_status status;
  if (finalizer == nullptr) {
    finalizer = [](napi_env /*env*/, void* data, void* /*hint*/) {
      delete static_cast<FreeType*>(data);
    };
  }
#if (NAPI_VERSION < 5)
  napi_value symbol, external;
  status = napi_create_symbol(env, nullptr, &symbol);
  if (status == napi_ok) {
    status = napi_create_external(env, data, finalizer, hint, &external);
    if (status == napi_ok) {
      napi_property_descriptor desc = {nullptr,
                                       symbol,
                                       nullptr,
                                       nullptr,
                                       nullptr,
                                       external,
                                       napi_default,
                                       nullptr};
      status = napi_define_properties(env, obj, 1, &desc);
    }
  }
#else  // NAPI_VERSION >= 5
  status = napi_add_finalizer(env, obj, data, finalizer, hint, nullptr);
#endif
  return status;
}

// For use in JS to C++ callback wrappers to catch any Napi::Error exceptions
// and rethrow them as JavaScript exceptions before returning from the callback.
template <typename Callable>
inline napi_value WrapCallback(Callable callback) {
#ifdef NAPI_CPP_EXCEPTIONS
  try {
    return callback();
  } catch (const Error& e) {
    e.ThrowAsJavaScriptException();
    return nullptr;
  }
#else   // NAPI_CPP_EXCEPTIONS
  // When C++ exceptions are disabled, errors are immediately thrown as JS
  // exceptions, so there is no need to catch and rethrow them here.
  return callback();
#endif  // NAPI_CPP_EXCEPTIONS
}

// For use in JS to C++ void callback wrappers to catch any Napi::Error
// exceptions and rethrow them as JavaScript exceptions before returning from
// the callback.
template <typename Callable>
inline void WrapVoidCallback(Callable callback) {
#ifdef NAPI_CPP_EXCEPTIONS
  try {
    callback();
  } catch (const Error& e) {
    e.ThrowAsJavaScriptException();
  }
#else   // NAPI_CPP_EXCEPTIONS
  // When C++ exceptions are disabled, errors are immediately thrown as JS
  // exceptions, so there is no need to catch and rethrow them here.
  callback();
#endif  // NAPI_CPP_EXCEPTIONS
}

template <typename Callable, typename Return>
struct CallbackData {
  static inline napi_value Wrapper(napi_env env, napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      CallbackData* callbackData =
          static_cast<CallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      return callbackData->callback(callbackInfo);
    });
  }

  Callable callback;
  void* data;
};

template <typename Callable>
struct CallbackData<Callable, void> {
  static inline napi_value Wrapper(napi_env env, napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      CallbackData* callbackData =
          static_cast<CallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      callbackData->callback(callbackInfo);
      return nullptr;
    });
  }

  Callable callback;
  void* data;
};

template <void (*Callback)(const CallbackInfo& info)>
napi_value TemplatedVoidCallback(napi_env env,
                                 napi_callback_info info) NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    Callback(cbInfo);
    return nullptr;
  });
}

template <Napi::Value (*Callback)(const CallbackInfo& info)>
napi_value TemplatedCallback(napi_env env,
                             napi_callback_info info) NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    return Callback(cbInfo);
  });
}

template <typename T,
          Napi::Value (T::*UnwrapCallback)(const CallbackInfo& info)>
napi_value TemplatedInstanceCallback(napi_env env,
                                     napi_callback_info info) NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    T* instance = T::Unwrap(cbInfo.This().As<Object>());
    return (instance->*UnwrapCallback)(cbInfo);
  });
}

template <typename T, void (T::*UnwrapCallback)(const CallbackInfo& info)>
napi_value TemplatedInstanceVoidCallback(napi_env env, napi_callback_info info)
    NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    T* instance = T::Unwrap(cbInfo.This().As<Object>());
    (instance->*UnwrapCallback)(cbInfo);
    return nullptr;
  });
}

template <typename T, typename Finalizer, typename Hint = void>
struct FinalizeData {
  static inline void Wrapper(napi_env env,
                             void* data,
                             void* finalizeHint) NAPI_NOEXCEPT {
    WrapVoidCallback([&] {
      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);
      finalizeData->callback(Env(env), static_cast<T*>(data));
      delete finalizeData;
    });
  }

  static inline void WrapperWithHint(napi_env env,
                                     void* data,
                                     void* finalizeHint) NAPI_NOEXCEPT {
    WrapVoidCallback([&] {
      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);
      finalizeData->callback(
          Env(env), static_cast<T*>(data), finalizeData->hint);
      delete finalizeData;
    });
  }

  Finalizer callback;
  Hint* hint;
};

#if (NAPI_VERSION > 3 && !defined(__wasm32__))
template <typename ContextType = void,
          typename Finalizer = std::function<void(Env, void*, ContextType*)>,
          typename FinalizerDataType = void>
struct ThreadSafeFinalize {
  static inline void Wrapper(napi_env env,
                             void* rawFinalizeData,
                             void* /* rawContext */) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(Env(env));
    delete finalizeData;
  }

  static inline void FinalizeWrapperWithData(napi_env env,
                                             void* rawFinalizeData,
                                             void* /* rawContext */) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(Env(env), finalizeData->data);
    delete finalizeData;
  }

  static inline void FinalizeWrapperWithContext(napi_env env,
                                                void* rawFinalizeData,
                                                void* rawContext) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(Env(env), static_cast<ContextType*>(rawContext));
    delete finalizeData;
  }

  static inline void FinalizeFinalizeWrapperWithDataAndContext(
      napi_env env, void* rawFinalizeData, void* rawContext) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(
        Env(env), finalizeData->data, static_cast<ContextType*>(rawContext));
    delete finalizeData;
  }

  FinalizerDataType* data;
  Finalizer callback;
};

template <typename ContextType, typename DataType, typename CallJs, CallJs call>
inline typename std::enable_if<call != static_cast<CallJs>(nullptr)>::type
CallJsWrapper(napi_env env, napi_value jsCallback, void* context, void* data) {
  call(env,
       Function(env, jsCallback),
       static_cast<ContextType*>(context),
       static_cast<DataType*>(data));
}

template <typename ContextType, typename DataType, typename CallJs, CallJs call>
inline typename std::enable_if<call == static_cast<CallJs>(nullptr)>::type
CallJsWrapper(napi_env env,
              napi_value jsCallback,
              void* /*context*/,
              void* /*data*/) {
  if (jsCallback != nullptr) {
    Function(env, jsCallback).Call(0, nullptr);
  }
}

#if NAPI_VERSION > 4

template <typename CallbackType, typename TSFN>
napi_value DefaultCallbackWrapper(napi_env /*env*/, std::nullptr_t /*cb*/) {
  return nullptr;
}

template <typename CallbackType, typename TSFN>
napi_value DefaultCallbackWrapper(napi_env /*env*/, Napi::Function cb) {
  return cb;
}

#else
template <typename CallbackType, typename TSFN>
napi_value DefaultCallbackWrapper(napi_env env, Napi::Function cb) {
  if (cb.IsEmpty()) {
    return TSFN::EmptyFunctionFactory(env);
  }
  return cb;
}
#endif  // NAPI_VERSION > 4
#endif  // NAPI_VERSION > 3 && !defined(__wasm32__)

template <typename Getter, typename Setter>
struct AccessorCallbackData {
  static inline napi_value GetterWrapper(napi_env env,
                                         napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      AccessorCallbackData* callbackData =
          static_cast<AccessorCallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      return callbackData->getterCallback(callbackInfo);
    });
  }

  static inline napi_value SetterWrapper(napi_env env,
                                         napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      AccessorCallbackData* callbackData =
          static_cast<AccessorCallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      callbackData->setterCallback(callbackInfo);
      return nullptr;
    });
  }

  Getter getterCallback;
  Setter setterCallback;
  void* data;
};

}  // namespace details

#ifndef NODE_ADDON_API_DISABLE_DEPRECATED
#include "napi-inl.deprecated.h"
#endif  // !NODE_ADDON_API_DISABLE_DEPRECATED

////////////////////////////////////////////////////////////////////////////////
// Module registration
////////////////////////////////////////////////////////////////////////////////

// Register an add-on based on an initializer function.
#define NODE_API_MODULE(modname, regfunc)                                      \
  static napi_value __napi_##regfunc(napi_env env, napi_value exports) {       \
    return Napi::RegisterModule(env, exports, regfunc);                        \
  }                                                                            \
  NAPI_MODULE(modname, __napi_##regfunc)

// Register an add-on based on a subclass of `Addon<T>` with a custom Node.js
// module name.
#define NODE_API_NAMED_ADDON(modname, classname)                               \
  static napi_value __napi_##classname(napi_env env, napi_value exports) {     \
    return Napi::RegisterModule(env, exports, &classname::Init);               \
  }                                                                            \
  NAPI_MODULE(modname, __napi_##classname)

// Register an add-on based on a subclass of `Addon<T>` with the Node.js module
// name given by node-gyp from the `target_name` in binding.gyp.
#define NODE_API_ADDON(classname)                                              \
  NODE_API_NAMED_ADDON(NODE_GYP_MODULE_NAME, classname)

// Adapt the NAPI_MODULE registration function:
//  - Wrap the arguments in NAPI wrappers.
//  - Catch any NAPI errors and rethrow as JS exceptions.
inline napi_value RegisterModule(napi_env env,
                                 napi_value exports,
                                 ModuleRegisterCallback registerCallback) {
  return details::WrapCallback([&] {
    return napi_value(
        registerCallback(Napi::Env(env), Napi::Object(env, exports)));
  });
}

////////////////////////////////////////////////////////////////////////////////
// Maybe class
////////////////////////////////////////////////////////////////////////////////

template <class T>
bool Maybe<T>::IsNothing() const {
  return !_has_value;
}

template <class T>
bool Maybe<T>::IsJust() const {
  return _has_value;
}

template <class T>
void Maybe<T>::Check() const {
  NAPI_CHECK(IsJust(), "Napi::Maybe::Check", "Maybe value is Nothing.");
}

template <class T>
T Maybe<T>::Unwrap() const {
  NAPI_CHECK(IsJust(), "Napi::Maybe::Unwrap", "Maybe value is Nothing.");
  return _value;
}

template <class T>
T Maybe<T>::UnwrapOr(const T& default_value) const {
  return _has_value ? _value : default_value;
}

template <class T>
bool Maybe<T>::UnwrapTo(T* out) const {
  if (IsJust()) {
    *out = _value;
    return true;
  };
  return false;
}

template <class T>
bool Maybe<T>::operator==(const Maybe& other) const {
  return (IsJust() == other.IsJust()) &&
         (!IsJust() || Unwrap() == other.Unwrap());
}

template <class T>
bool Maybe<T>::operator!=(const Maybe& other) const {
  return !operator==(other);
}

template <class T>
Maybe<T>::Maybe() : _has_value(false) {}

template <class T>
Maybe<T>::Maybe(const T& t) : _has_value(true), _value(t) {}

template <class T>
inline Maybe<T> Nothing() {
  return Maybe<T>();
}

template <class T>
inline Maybe<T> Just(const T& t) {
  return Maybe<T>(t);
}

////////////////////////////////////////////////////////////////////////////////
// Env class
////////////////////////////////////////////////////////////////////////////////

inline Env::Env(napi_env env) : _env(env) {}

inline Env::operator napi_env() const {
  return _env;
}

inline Object Env::Global() const {
  napi_value value;
  napi_status status = napi_get_global(*this, &value);
  NAPI_THROW_IF_FAILED(*this, status, Object());
  return Object(*this, value);
}

inline Value Env::Undefined() const {
  napi_value value;
  napi_status status = napi_get_undefined(*this, &value);
  NAPI_THROW_IF_FAILED(*this, status, Value());
  return Value(*this, value);
}

inline Value Env::Null() const {
  napi_value value;
  napi_status status = napi_get_null(*this, &value);
  NAPI_THROW_IF_FAILED(*this, status, Value());
  return Value(*this, value);
}

inline bool Env::IsExceptionPending() const {
  bool result;
  napi_status status = napi_is_exception_pending(_env, &result);
  if (status != napi_ok)
    result = false;  // Checking for a pending exception shouldn't throw.
  return result;
}

inline Error Env::GetAndClearPendingException() const {
  napi_value value;
  napi_status status = napi_get_and_clear_last_exception(_env, &value);
  if (status != napi_ok) {
    // Don't throw another exception when failing to get the exception!
    return Error();
  }
  return Error(_env, value);
}

inline MaybeOrValue<Value> Env::RunScript(const char* utf8script) const {
  String script = String::New(_env, utf8script);
  return RunScript(script);
}

inline MaybeOrValue<Value> Env::RunScript(const std::string& utf8script) const {
  return RunScript(utf8script.c_str());
}

inline MaybeOrValue<Value> Env::RunScript(String script) const {
  napi_value result;
  napi_status status = napi_run_script(_env, script, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Value(_env, result), Napi::Value);
}

#if NAPI_VERSION > 2
template <typename Hook, typename Arg>
void Env::CleanupHook<Hook, Arg>::Wrapper(void* data) NAPI_NOEXCEPT {
  auto* cleanupData =
      static_cast<typename Napi::Env::CleanupHook<Hook, Arg>::CleanupData*>(
          data);
  cleanupData->hook();
  delete cleanupData;
}

template <typename Hook, typename Arg>
void Env::CleanupHook<Hook, Arg>::WrapperWithArg(void* data) NAPI_NOEXCEPT {
  auto* cleanupData =
      static_cast<typename Napi::Env::CleanupHook<Hook, Arg>::CleanupData*>(
          data);
  cleanupData->hook(static_cast<Arg*>(cleanupData->arg));
  delete cleanupData;
}
#endif  // NAPI_VERSION > 2

#if NAPI_VERSION > 5
template <typename T, Env::Finalizer<T> fini>
inline void Env::SetInstanceData(T* data) const {
  napi_status status = napi_set_instance_data(
      _env,
      data,
      [](napi_env env, void* data, void*) { fini(env, static_cast<T*>(data)); },
      nullptr);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

template <typename DataType,
          typename HintType,
          Napi::Env::FinalizerWithHint<DataType, HintType> fini>
inline void Env::SetInstanceData(DataType* data, HintType* hint) const {
  napi_status status = napi_set_instance_data(
      _env,
      data,
      [](napi_env env, void* data, void* hint) {
        fini(env, static_cast<DataType*>(data), static_cast<HintType*>(hint));
      },
      hint);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

template <typename T>
inline T* Env::GetInstanceData() const {
  void* data = nullptr;

  napi_status status = napi_get_instance_data(_env, &data);
  NAPI_THROW_IF_FAILED(_env, status, nullptr);

  return static_cast<T*>(data);
}

template <typename T>
void Env::DefaultFini(Env, T* data) {
  delete data;
}

template <typename DataType, typename HintType>
void Env::DefaultFiniWithHint(Env, DataType* data, HintType*) {
  delete data;
}
#endif  // NAPI_VERSION > 5

////////////////////////////////////////////////////////////////////////////////
// Value class
////////////////////////////////////////////////////////////////////////////////

inline Value::Value() : _env(nullptr), _value(nullptr) {}

inline Value::Value(napi_env env, napi_value value)
    : _env(env), _value(value) {}

inline Value::operator napi_value() const {
  return _value;
}

inline bool Value::operator==(const Value& other) const {
  return StrictEquals(other);
}

inline bool Value::operator!=(const Value& other) const {
  return !this->operator==(other);
}

inline bool Value::StrictEquals(const Value& other) const {
  bool result;
  napi_status status = napi_strict_equals(_env, *this, other, &result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline Napi::Env Value::Env() const {
  return Napi::Env(_env);
}

inline bool Value::IsEmpty() const {
  return _value == nullptr;
}

inline napi_valuetype Value::Type() const {
  if (IsEmpty()) {
    return napi_undefined;
  }

  napi_valuetype type;
  napi_status status = napi_typeof(_env, _value, &type);
  NAPI_THROW_IF_FAILED(_env, status, napi_undefined);
  return type;
}

inline bool Value::IsUndefined() const {
  return Type() == napi_undefined;
}

inline bool Value::IsNull() const {
  return Type() == napi_null;
}

inline bool Value::IsBoolean() const {
  return Type() == napi_boolean;
}

inline bool Value::IsNumber() const {
  return Type() == napi_number;
}

#if NAPI_VERSION > 5
inline bool Value::IsBigInt() const {
  return Type() == napi_bigint;
}
#endif  // NAPI_VERSION > 5

#if (NAPI_VERSION > 4)
inline bool Value::IsDate() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_date(_env, _value, &result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}
#endif

inline bool Value::IsString() const {
  return Type() == napi_string;
}

inline bool Value::IsSymbol() const {
  return Type() == napi_symbol;
}

inline bool Value::IsArray() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_array(_env, _value, &result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline bool Value::IsArrayBuffer() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_arraybuffer(_env, _value, &result);
  NA”F¡$ ÑRÚñQÂúşÛ(èr©Küd(g©ål9¶@(Šëâ™„øB…¦µ¹^„#pİ­,Ö„b)K;—æ­)e„ÛĞP[rõJ·¹H%›7ÕVYĞV‘=éqÄÉƒ¤ÇnX¸á GE°‚E(vûp/kv;ƒ‘A†°ÀG!ä’„F2<šQjqúŒü“^ _8ÍŠ”‘l©¶„ÅoH¬§cwDP p0."U
‡ºP\B	Á¨6$ø´¨­ç‡8‹B@Ør$ş[ºÃ=H0çd¡‹]B? 8™èø¯ ­
ZÍğøåPŸLÌMT9»^Á+P®¤2]È!ïÀ€Á(A/~¤®6'¥£œsø˜Çñ—¼):¬k·µ6§­Ÿt˜/™É‚U8É]§û9ìŞjÛp¼-j‘Óäd$Mì´¿Æ4ıM¦•ç9ãûıKjGé‰%©¨!ÄmÎ‘òÎ©$ 4öy-™N=Ø1‰|iÁÆÜÓ„“®»€z]4Ğ"ô–Ç«$×*n†-@A”»;}e„èòS!Ô=S¥€=™ŠìÏTW]¬ßdf~WÚLõ«ÅÌ*!85®GIşŸ¨÷ºQãÔÚ¼”CBÔæ" ¥2ÈşScTÿV?BÏMUŸgSëÿ!yÍ`(¬C¾T¦ÒDá“6ŞêGjé ÎÃÍ[G¹WÒKj	Hø\ÛÎ÷.\mT®B \”ì
3]Ü–ÊšŠ_„ì%¢,D µ"êÊBâ‡<‡½ø\m¤hMÈØm#2ÁÜğß àÖ\!âsÑ <÷õçw5Ø‹À•ô@ûêŠØ¯ù¸íÿ*Cöü¸J³·åôKÓhv4|‚kÚíŠ¡?$4{‚+"‚X•3ÇK”ÄP?ı¢:Tô¨r±‡L(_à™¹•ü…ò¢Èş–^òÑ2œõŠ(¯·ä÷ôæI” x?*HU)Ùƒ'h•øgÂ¿

‹ à£¡Q.ôoc‘µÔéÌ”ÛÁtDŒãÄ]Õjü[ÏPf~Ö•"¹^jy¤Ñ«¯U:>¦ÿûØ‹õhÊ‹èÀ‘[¨YººöÉ•åÕÑNœ¨Ãt¥«{ïÄé¡@â¾+%68;„)E•“wŞ!ïEC%.¿>¼î%%G>ïçUavZĞµYjt¬ªi á“ˆO6€ÜçğÄtù±]ÁQĞDÑ$Š$Š$ÊŞKâ˜d¥ÎJçj¥W´Jv ÕVx>÷Œƒï–ŠP®7İe„Û\ËÜ9»«Yk¯Ş¯úºMOs¡eİ£-qÅ­_½ş²¬Åİs`•äÉÆÎ”)1Mû¦üĞØÜ7Æ¶œ5,k5JÓ(&M¬$1“Ô0Lò×4¦ñc=±^,¦YcµÖZë|c|k‹iV+—Vè¼ Ö®y)K¦]¡¿Ü_T?Óˆ1Xvv»XÈx`?´Î÷”;„éÎL’æ’­NaTó1Éy²Û9Lw“,ÄÜpù§Ô¦ÖöV9Ñ$ÀØ€7møv{Lıvl»-r-òÇ±Ç·ó¶?Äcâ¶—=Àfì¶'ß1XDí‡ÌœKŒ“ÃdD¤´òX<’ns
ÛŒ…r!®<ÜÛJÃ³.ŞLÃOcW…Q å°xëW!	“…apFhNˆ:ÃJ[’eÖ†²eê5 òGİ5¬…›ªéÈZ‚èVÂêÅéx”}¢¿²ç*Ïî­}-!"¬k­üYXåà~„@‡C?ºMwÎí¹İò¾Êxw8×'ó3+Ïà3ƒÅ¢˜æCèJè@Vè,È­aDöbfIŞ§Ì{yòî¼åò^Ş³S{²Ïaò¢¨j6VİÊÜ5O"ï]ëÔÒTÎ©T>Aİ&³MéÑn@ÓË¦Bél§ÓlDºÑhs›Í|6Qİ†³ŸÈ>›İ\°ÉC<xo¦~d³iÖ}(:TV‹n¡ÊYu\ÑŒ’ú¥Y”Š
å*ƒKCDÅU/…Ûİr.³¹ÃŠÎËCM©³ÑÜP°´WâÑ˜“¨Û…İÑ´Dß+‚!È-+w÷êĞ¼n„î‡OW2ıš]5Á~^.GŒæÑí<¯¥:MV^±¿ï~0+êô7sLªõ3@æ“Ö\¤€&ôú™@.{è+åyº'ÜG,Æ)tÖ½şÁ.y,éô)vsÈrçqbçÑ¢ÛşÿœŸâ?n!EBà¼u×$û.¬AƒP5âüzt2“„ t4VMë8ŞZÄï=6ÕŠ_K
ê£¦÷ş 'r.hŒZÒI¶ÎC'5)ÿtš/ª[JtÛ±³Õƒ3ÕƒÃ²İ_îøYbH&@ğø®Aò\¦XÎIhŸZo“_ó×æÚ‡IÖäü¹Î£ZJkt0SİN¿]£òLÚeb+›cLßôZƒ«üm_á²Cñ¯&™UMe‘+}á* }w×Ú'ó2ÉPÆ3&wn³âÌú(*µÊwN¦çN`Æ$t-Âó.d”ó–şØ©Ì¬I¡’NXßætW´Ë¤NÁÛ§EÆzÎnÂ^‘m«“ÛÆ×1Ó­[áë¢5a8?ĞËÃ_‡Ù¬´Ù~x~¸]°›u‡Ú®¶Û,Ô€gv´ Q·‡7ØWÄ‚¼ ãšİ74ïzB÷¶=™>7Ÿ’¬ŸS5”‡qú6[´ó^ÕÎz<£­ozÃí)·ĞQ£äêDŒêûo¦HÊ_Ü%ô••O‹ÅFÒ¥ş¸ò­2†²ï˜ï¯÷ë½4æ´/˜/>Ğ>Ğ2c2ûŒùìÓæÓ3³è˜t—>Ò£WÚ¹Ó"Õ5E¥B–ºë—ÓDê9™¨cdš;¥THøÑ`Ğè4qÂŠÑq´J9ô³-¥AEÉxw‚t MX”
$òôƒ
âÉ øt¸¬CÂüSW	]*»‰{,ÃàH„Å]¾­„…Ã¡,¨4M^p´'-Ù+æğ0„ëµì$qˆÄ,¦øó§ m,]™Ã7Ÿp¯D-œ÷+£(i…pÄŒ	Õ7áC7På ØÒ]ú
ÕBÎ={5Š|øBX\#&´!wğßi‰Y»K',ÈmPe¥-*!¢Îğ³0†ë>H
ÍO/¦ZÕ¬L	¥ù}bÚa6tÑÖ\½’Í›ôØ¯neì¡¬ö^­ıÍ³ŠÆ%'=R¿°Kdšjªù*;g±jö÷ı¾5åh
:	_†ğÎâÉ“x>ÂVÌŠUàƒò	‚š¦tø£¼z¢BòçG~öÛ”uøÆİ0”z(¦;›X ÏP“rõK¶kªóÑşºqò2éû¦†³8‚Š:jôRgfåv˜Ü,SîsoMÄÃ8¢úHÕş‹~/Éè³(?@IYˆaç"gkO„3äzdšö¾¤[>/Éè³hˆêv†ù`Êƒmoú"ø?ô4.#õ‹ÈMÂıû¯×I¼vPŒ·ÙôzÙ´ì¦ËÈÿkğ—¢~wj®>|Ñ½..<":º¶kN¿ş<^PL’-ºFh¡ÂÏ)ÕÑİPhä¥Ó5¸»óø?­­3'‡OOµkùÕÑ[A4wcùı“ğ%®ld‹¿‚Ñp)5,E=ÍMVo`ïÁ®wä"õy·?J•MMõalQÔÚCEµm
™]pxgÈ@ùs\á'‰HXüó¯J‹”×	,‚ß£‘\ !—ÂÉñÂ”Ä!.å±Jk}QfoâP/Õ¢²æbpqˆü%•e
r”…¨éş‚îRaÔo÷sIi“²ØÅ.¡X!‘¸F8êb{(*’# éßèÊLøAFãMQàÅ¬OåE‘@Œã±_4÷C‰ˆâ+¡:G?H‰p!ì¨dÍ„~é­M—pe­®‚0¸®áóIZù~Œ68ewœıÅ3&šëDyâÂ*Í‰ë[÷V6^ÄÍ›Ù‚êór´¢³•’['İ” \ HÂ¡ä(~R`2	í…”@7P¤µr™xNŞëù `  deVVeww…€Š¦»ºv›xx
©©¹ª¸›x¨¹—¹‰™™ºº
« »
«««¹  
š 	« »°»Vv›¨š™ª° ©š™™™™¨¨š ˆ™©º©
›™™˜¨©™ˆˆˆš{˜‹ š˜™©˜š¸ °°º ©»º	 »º«¸ªš       °      ¹	° °   ©š     ¨‹    °ˆy  ¸ €ˆ‹
 °  €‡Šº»‹° `ˆŠ°p™ˆ  °‹kˆ¨º
° p‡xš»»ª   °                              I[ ¡‡ãh_ßå·o·ÀtXÀşÇg!oÇ
ÛÒ¹~–ÇmIÑŞ äÌÂ¿¬xFXÈ‚” TB±¡H¨*­rQ‚é0Š©ó.d	uÑ=›Çà'\´æ]™ø’¡lÌğüGØEI£ZÍjl6Z²MB®“É$	'&œŒ:‘uÒÓä:¢IÉi&”4¡ì$ÙI@“ÀN‚šÉg6¬Ï´º	ƒ8Ùê$P&pÓºÜO‘Y¹ãàú®0–;ÌLÎ°H;ïí0m‹PSµáü<	Åô®`‚Rãá¤Ÿ7 ¯úı \â\h „R9×FÈuA°
WM=˜o¥T5
6œ
Ş$\m›"DÈÕj#V’[!Ôf*á<u6–gÊÖÛåJ„ÆDáÚ‡¨ØŠ},Î@—•*¥ƒR›l6bm+”ªmêÜ”)¨©v…¸ğhœ#æ8¶ÌëNç†Ë¦½åÍ}èµ¼gi²\l/fğ.Nªğ*âÀ×·+c»ßcı$–Û2òİblw?™Ã.ù¼Lñë;Ìğ°x¢O½‹EE¢Ä 9‡ñ¼|¤¦Ã-I(*Åæ­-ÇA˜JĞi=Haj–Ï>ğH—sˆ)“¡Rğ;D¤QÃtğaëHú@˜òa¸W„»2¸‘CRu$s.I8b<EåsI»úÖÕıMêÆ~Äv?†¤ê¤.Ò\ë*¼€«sHUK¯ECG‰`ôºxC²° ]GLxü‰•±dÌd2r2½ÎŒ@Ap¿øÈc<8gdNd":#(Ø·ûUhÆrÒ©5®E%)ınRÇ<yÈ}ŒœÓ´¡W™–(Øh·ß61Ë“–rV0Ó2^OZ† gİ¢l¢Ò´ÈÙ>NË½Ò´ÁĞ»E2B±Ó>‘³–zi‚ v‹e…¤ríròñÈ[u¹UzäÇu4ªUêqêÌê¤ùö”Ìá@13Ô¶°Ï@EzŸá‚Ây¯`»ëõèkT/]ü&¶ë½¥YÛµnõú7¬+•KÉÍ‡‡Í¼/éûïƒpCh„„øÄ-²7„A
L˜ D{œÃ^L0ÅeõQOºü‘Í¥¢0åI÷%‹œq‘–Éøm1†ö0‹I[×e2³-"Çêòía»Ó}(ã;¦¤+H³p54MÒ³¥yİ¼­‰ÿÅ43?"ÔáÈ™-à¡Ÿ­„¹|¶.ÀU å2±Ür$Ì€ˆ)¾Ä7	ñ84ÏÊBap/ˆ€Š˜qšÊUˆi§ië.©*NÂ¸˜V3*Á©Q(ãü‚›ÜFÑ\t=­¤®Tîiï{ÌH\f¤Oì÷Ò=jË©å¶%ßò[RyÈhÓ¨yvÉÓ€¾x¦Y­ïr¯³§¾Nú€÷¡û|}ÃŞ\ÙìdìÑµ›ˆÆ^]I7ò”"ÇÇGVúynÁ˜ÍVÈ²	ŠÑ-ú÷ø¦croPß3QZ`@Sr7ÉáM§5®æš¾F´5£)WÔ ù¦gX¦&K5jÊfØô0°ÕñïU4·eA”EÀ©9 "ˆ¢$ˆQ&`PˆĞ°nÊ9æ(ğ¶_,­ wÏİb·)ïF»¤0ë=yõ¨ˆşËÊª0['vp¡ùiEò€¿Kß:ãX2¨ñİÆI^ktßÍ•Ún[r^Wø^ÁÌXk+1o^û'zOø5‚Âl–î^Ü¼}¦½#;’<Ğsl­ôªC¹#Iœ°Ä¦	ÏWñNxşXí?=øìé‘¼º;Ï£áåŞ1qÕ
BOóû¢S-*åçá¦,ÔùüWØog<cùØn{b?=¿ª„ê©\’RxGnLFÄa$Í¼®8¼ c*†I+Š“¯úŒÊÁ†‹‹z9ú	/$"9Ú±é¤´ÈäÂË“‰ÒåIROäˆ~Vt*è0ŞqQşIêlkõí­7N[&8Mçé~m…ğÉÔ‚Ò»¿¼<ŠüÁz0.9†ßù¯5*tİ¡ñ:tâ®«âÆ+·
r=½ŞcÕTHìPæA1ŞÊ$0¼¯@Y«•PpJÙb6[‘m÷Ù´±Œï´%5î1Ÿ$=†G]uPˆí÷›Ãb»"Ü¡“…`ÛÓ}'>Àû$	½;½Æëû×æ–NoŞö×Qz
æ3bİ
?4‰‡Ûg5öCW—×H5xĞcĞP‹şT. ½£Òº]¦;¡×»vÏİü ñÎ‚|ÿyªÀEeüˆÈz§ƒ«§£ Òfô^#úÕé+¤¯@¶Ä4uGĞÄ*|*Ø •øU£C¿ş£-C@›9­7Z”Ñ††ÆşLG%ÚóN-Î–İŞœ®–§Ş
ÚJçN™g0tùg?òÙ<kCş¸B5¾G"“Ö ‹6Ê~nk‘ü2è[ˆ†?aQğÂŸ'4øCPºÅ*kíĞ`‰WBĞ^úWHÚÑ
ˆ…İ¯h\{}€Ğæê¾Z!Dáx æK?Œ
vĞ€+šÿ3q-AËÃªE“hŒÌq¹xÅ¨çÖ	™•Â>&B+§‰ÂUá®Şo²2ÇÄ¢=~’b“H«­»èrİ‡  deVeewx–Šy†ˆ¹†˜hg‰§	‰š¨¨‰˜ˆ
©©šŠ‰™«š™™™š˜©¹»š«©»ºº«
 	º¹» «»	Wv°·š¨ºª ¨
Š
º»° »» »›‰¹««»™ª™›š›««©¹©«‰«»«ª™© °°º»  »
°ª              »      ™	     °˜«	» ›p˜y©
 ¹ €‰Š¹»» °{ˆˆª »
 `‡‰‹ »™°kˆŠ›¸‰«»iˆ¨‰»° z˜ ª  
ªŠ


 

                          Osq†(W*—eŸ¤ò:~Õ$øEéóø»S}§™'0|Ä.MÚ´™#|¾‘nBaır”id¦v£_§\‚Á/ø-pI„¿<Ø)ÖR	–LŠå“ĞéiR…½2œabó—:¼Ìì×¯ş0kbÊ¼¬>QÇGG‡üICæ(ªRYí¦C#}¾Ë¤>2¸¥£ ÛµÏ•r!ÕåâèMœë®|Ãšt£¸D™š;sşA?âJ˜>º3GÕ:²çŸ]#›o”Û#Ó«£_Óû¿—¹J¡æH°øıø¢(Bÿhø’5Ó }=L;º†¾63¸—œf‚o±^É†®÷C‡'ñ# MÚZŒğXÖ¹®ÌèÇ¸(7Ñµß2ìö'ôÜ¶hığİÓ›:øİğ›Ïæ¯&5Ö<´5óe½ƒ"~Ÿ‡ÉŞAQ„º¢(z—Ê½µbó)Íµo&İá/²‹n[PØ ™­x«N¬¦ğ.SÕùZ¬u¹:‡¸›
øi"`ç'¯2qÚş„5¥Ìhg;lCÏØHUÓ6ÌV8ZUq§,¥rYeb~ÖŠÛaÕÃf=şuY*¤1S«,¤ZAŸËByñÃÑÄÎüAf)¼i«&ûm><¶|$dªrX•pµ´ÿ¼‘-•$3ëŞ«Dëh2Ò¡!ñ™³Á47±[ğ¥Ó‡ÿà­x²¾nıÙxgı&ÿo¿ƒØÑ;^¿¥¹[Šqo™ıË;‹IÀÅĞ´VnÖªX}Ö{«ë¢{tªh]Ë[{A2{`{!-(}	ì6×¼(	.vÄÔûSár@\ÊÂ	C³†fıßfCó¬R¦fQÃ[God–„¬œSu>¹ö½wÒ{Oõ ˜ÛìŠMIÜò¼m™mnûíPp.GX=H $.ˆñ q0t„¯ ¤Š¡x4b’ÿ
—Üxˆb²o
O\9<…öîGH¤ˆêl,@ãğÈ®(çqœ Ó~/”=¢²“²Ç˜½‡3lÁ„fy  â½ˆşßB•ğdÃä0)œk“ g9 všÁ;;ˆ¦s,Z-f³ -;“` PS yJ 8› ÃS; …K¦Xˆİt”ã.ÿï8­Ì§¶O ~Œ±h‹Ïº$Ê6³ù?‰Ãq D°E`›Ùü4”¦AùK‚áq d–I²­³lÆ,Ò±ˆ´Ì™=,	å÷S§­Ü	ö•hàâÃ-”L[¸5¯õ+†ï~ş²¯ni¼ˆîø'¥eä ®MÛùx"ˆcòQtÁgÙİüBV=‹‘64‚B ÉM àì ds°·Zç®f†÷±t²‡sx.Vù•¯‡î¯T„¤6†t¾#ÿñJl—
¨ßEªCÓ³s]F)A o åÍY*î1YV(‹Ğ"šL6¸q"¾Šë¸ŒN"†ş–ì%\AQ ÉQ~]ö{¢rHB9»d¸…ºšî¡?ïŠßŠÂûïI»A¬‹Å:t‘|w7ê,İ4òj—- ¡ †Â  Xïó€&·ú3#D^û.k +IÍÒ¬!æR]ïÏçä.Ê·RBšœI [ C­CrK¢|hï‡$• B¼ föÒ× á3°IûK Gm â8Q^ìJ¥©¡3ÃÜlüœ-/ûÌõÜZú Yq9óˆÊ
\?lê³4r€.n0FŠe
F'ıaÔT_éy^JS±ßë Ošzõ„Ì)¥eW·XÉ¢BÈeáyq,o¯\&K@_KU§ØO§*ƒÑèA˜´ñÈ"'+dó’åGÍT“ÔÓëÚ[y±naÜt–éçÏÁl³„Z&Ô|ZæÓÏ{ÀVy èÂ,İ|‡õƒŸ%É+F>h©»T¿\x”$‚|'®iÚÜ ×Œã/'£Î
û’GÿìX—©±vìˆöĞÓ$«!%KQğß/ØÈº´„”‘v®ÎcûwDuÛœ«YrÄ„u«Ô˜àP]öã´§µ­F'r$Js%F78FI¦¥²,´X‰±ÉqRcK–!=æ;R˜ù´kÑ*`Œ¬ß‰éë×˜]¿ÂŞ[•Àoa}…a˜£1¾âS”N‚ıäj¡_ãOÚ±îMñ_Ø^ÓÃ÷¦î¢wû½¦W©½$‡¹[UÁ(§¬@=pzÊ€„:9M^:j¥“¡æ9$£3_¦+XÂ%ølÂáØ²ÅS¯àgBü>ÄZÎG­xÂ¹ ©¼ı—b]À@ˆ¤İIz€ä”Ó¤Ì¯spÇªË£{
:ÊõjmLâşFÑeŒíD¹g¸"4V÷£4phaO1ƒƒ{TËa5¨rqúˆvâÈT;R6ìÃ@a¸p@œÃ9ğ›öqS¬6I%”?Î™Ö‚8ãäÈ@"©Ş/xÔ¹Ì8€Üá {A¢±@‡Ã#„²X.$¡sRç$Ò`Rnç~Æã%ÙsùÁÃÚ_TÒøy¿[æ%ìóBsyO¯Œb2ö#Éˆ‘ìˆ¶°xm…†™êPÑ%UóÒÍÜLRÁ<fü†äÑyÜC´%7)ËÍWÉ—(—(GqgğÒDÀ*´šfEE¹À÷  TeVeU‡w–yx†ˆ¨†ˆgx‰§ ™ª˜	š˜¹»º‰˜˜¹
˜˜˜©	‰›¹
©º°»«	
š¸º©›Š	»Wv»·š	«›‰©¨©˜¹

 ª
 


ªª 
 ¨
      ª  © ˜	  ˜ ªš™
ª
 ªš©ªª	
 
        ª      ªª      ŠšŠ     ©
     ˜i   § pšš
   pªª   
 p©ª
	  z‰
ª ª `ª¨  ª –‡©
ª

p
ª  
                         e€Ğ²Öé!ËpòìÖ.!dX™Ó!u°’¹ï-tBĞç$!Ô(šD4Ş#­WªŒZdtÅNCFˆ\@èŠ:®c#‡ ípC§¸é(‹å‰â*õ…¾ãú</6şw‰mw>‚Ì +DÅ;$ØqÒ q$ØŸèqõqh3\ı‹Ş›e²IÁU¾*Iø4<Ğñ.u÷3ß°À0R[ãO…íBrâæH¢[èQlã|™‰Œ~!ç¿³©ü@’¤·E±¡ä\IT¡ ‰Š$‘Q‚New(env, val.c_str(), val.size());
}

inline String String::New(napi_env env, const std::u16string& val) {
  return String::New(env, val.c_str(), val.size());
}

inline String String::New(napi_env env, const char* val) {
  // TODO(@gabrielschulhof) Remove if-statement when core's error handling is
  // available in all supported versions.
  if (val == nullptr) {
    // Throw an error that looks like it came from core.
    NAPI_THROW_IF_FAILED(env, napi_invalid_arg, String());
  }
  napi_value value;
  napi_status status =
      napi_create_string_utf8(env, val, std::strlen(val), &value);
  NAPI_THROW_IF_FAILED(env, status, String());
  return String(env, value);
}

inline String String::New(napi_env env, const char16_t* val) {
  napi_value value;
  // TODO(@gabrielschulhof) Remove if-statement when core's error handling is
  // available in all supported versions.
  if (val == nullptr) {
    // Throw an error that looks like it came from core.
    NAPI_THROW_IF_FAILED(env, napi_invalid_arg, String());
  }
  napi_status status =
      napi_create_string_utf16(env, val, std::u16string(val).size(), &value);
  NAPI_THROW_IF_FAILED(env, status, String());
  return String(env, value);
}

inline String String::New(napi_env env, const char* val, size_t length) {
  napi_value value;
  napi_status status = napi_create_string_utf8(env, val, length, &value);
  NAPI_THROW_IF_FAILED(env, status, String());
  return String(env, value);
}

inline String String::New(napi_env env, const char16_t* val, size_t length) {
  napi_value value;
  napi_status status = napi_create_string_utf16(env, val, length, &value);
  NAPI_THROW_IF_FAILED(env, status, String());
  return String(env, value);
}

inline String::String() : Name() {}

inline String::String(napi_env env, napi_value value) : Name(env, value) {}

inline String::operator std::string() const {
  return Utf8Value();
}

inline String::operator std::u16string() const {
  return Utf16Value();
}

inline std::string String::Utf8Value() const {
  size_t length;
  napi_status status =
      napi_get_value_string_utf8(_env, _value, nullptr, 0, &length);
  NAPI_THROW_IF_FAILED(_env, status, "");

  std::string value;
  value.reserve(length + 1);
  value.resize(length);
  status = napi_get_value_string_utf8(
      _env, _value, &value[0], value.capacity(), nullptr);
  NAPI_THROW_IF_FAILED(_env, status, "");
  return value;
}

inline std::u16string String::Utf16Value() const {
  size_t length;
  napi_status status =
      napi_get_value_string_utf16(_env, _value, nullptr, 0, &length);
  NAPI_THROW_IF_FAILED(_env, status, NAPI_WIDE_TEXT(""));

  std::u16string value;
  value.reserve(length + 1);
  value.resize(length);
  status = napi_get_value_string_utf16(
      _env, _value, &value[0], value.capacity(), nullptr);
  NAPI_THROW_IF_FAILED(_env, status, NAPI_WIDE_TEXT(""));
  return value;
}

////////////////////////////////////////////////////////////////////////////////
// Symbol class
////////////////////////////////////////////////////////////////////////////////

inline Symbol Symbol::New(napi_env env, const char* description) {
  napi_value descriptionValue = description != nullptr
                                    ? String::New(env, description)
                                    : static_cast<napi_value>(nullptr);
  return Symbol::New(env, descriptionValue);
}

inline Symbol Symbol::New(napi_env env, const std::string& description) {
  napi_value descriptionValue = String::New(env, description);
  return Symbol::New(env, descriptionValue);
}

inline Symbol Symbol::New(napi_env env, String description) {
  napi_value descriptionValue = description;
  return Symbol::New(env, descriptionValue);
}

inline Symbol Symbol::New(napi_env env, napi_value description) {
  napi_value value;
  napi_status status = napi_create_symbol(env, description, &value);
  NAPI_THROW_IF_FAILED(env, status, Symbol());
  return Symbol(env, value);
}

inline MaybeOrValue<Symbol> Symbol::WellKnown(napi_env env,
                                              const std::string& name) {
#if defined(NODE_ADDON_API_ENABLE_MAYBE)
  Value symbol_obj;
  Value symbol_value;
  if (Napi::Env(env).Global().Get("Symbol").UnwrapTo(&symbol_obj) &&
      symbol_obj.As<Object>().Get(name).UnwrapTo(&symbol_value)) {
    return Just<Symbol>(symbol_value.As<Symbol>());
  }
  return Nothing<Symbol>();
#else
  return Napi::Env(env)
      .Global()
      .Get("Symbol")
      .As<Object>()
      .Get(name)
      .As<Symbol>();
#endif
}

inline MaybeOrValue<Symbol> Symbol::For(napi_env env,
                                        const std::string& description) {
  napi_value descriptionValue = String::New(env, description);
  return Symbol::For(env, descriptionValue);
}

inline MaybeOrValue<Symbol> Symbol::For(napi_env env, const char* description) {
  napi_value descriptionValue = String::New(env, description);
  return Symbol::For(env, descriptionValue);
}

inline MaybeOrValue<Symbol> Symbol::For(napi_env env, String description) {
  return Symbol::For(env, static_cast<napi_value>(description));
}

inline MaybeOrValue<Symbol> Symbol::For(napi_env env, napi_value description) {
#if defined(NODE_ADDON_API_ENABLE_MAYBE)
  Value symbol_obj;
  Value symbol_for_value;
  Value symbol_value;
  if (Napi::Env(env).Global().Get("Symbol").UnwrapTo(&symbol_obj) &&
      symbol_obj.As<Object>().Get("for").UnwrapTo(&symbol_for_value) &&
      symbol_for_value.As<Function>()
          .Call(symbol_obj, {description})
          .UnwrapTo(&symbol_value)) {
    return Just<Symbol>(symbol_value.As<Symbol>());
  }
  return Nothing<Symbol>();
#else
  Object symbol_obj = Napi::Env(env).Global().Get("Symbol").As<Object>();
  return symbol_obj.Get("for")
      .As<Function>()
      .Call(symbol_obj, {description})
      .As<Symbol>();
#endif
}

inline Symbol::Symbol() : Name() {}

inline Symbol::Symbol(napi_env env, napi_value value) : Name(env, value) {}

////////////////////////////////////////////////////////////////////////////////
// Automagic value creation
////////////////////////////////////////////////////////////////////////////////

namespace details {
template <typename T>
struct vf_number {
  static Number From(napi_env env, T value) {
    return Number::New(env, static_cast<double>(value));
  }
};

template <>
struct vf_number<bool> {
  static Boolean From(napi_env env, bool value) {
    return Boolean::New(env, value);
  }
};

struct vf_utf8_charp {
  static String From(napi_env env, const char* value) {
    return String::New(env, value);
  }
};

struct vf_utf16_charp {
  static String From(napi_env env, const char16_t* value) {
    return String::New(env, value);
  }
};
struct vf_utf8_string {
  static String From(napi_env env, const std::string& value) {
    return String::New(env, value);
  }
};

struct vf_utf16_string {
  static String From(napi_env env, const std::u16string& value) {
    return String::New(env, value);
  }
};

template <typename T>
struct vf_fallback {
  static Value From(napi_env env, const T& value) { return Value(env, value); }
};

template <typename...>
struct disjunction : std::false_type {};
template <typename B>
struct disjunction<B> : B {};
template <typename B, typename... Bs>
struct disjunction<B, Bs...>
    : std::conditional<bool(B::value), B, disjunction<Bs...>>::type {};

template <typename T>
struct can_make_string
    : disjunction<typename std::is_convertible<T, const char*>::type,
                  typename std::is_convertible<T, const char16_t*>::type,
                  typename std::is_convertible<T, std::string>::type,
                  typename std::is_convertible<T, std::u16string>::type> {};
}  // namespace details

template <typename T>
Value Value::From(napi_env env, const T& value) {
  using Helper = typename std::conditional<
      std::is_integral<T>::value || std::is_floating_point<T>::value,
      details::vf_number<T>,
      typename std::conditional<details::can_make_string<T>::value,
                                String,
                                details::vf_fallback<T>>::type>::type;
  return Helper::From(env, value);
}

template <typename T>
String String::From(napi_env env, const T& value) {
  struct Dummy {};
  using Helper = typename std::conditional<
      std::is_convertible<T, const char*>::value,
      details::vf_utf8_charp,
      typename std::conditional<
          std::is_convertible<T, const char16_t*>::value,
          details::vf_utf16_charp,
          typename std::conditional<
              std::is_convertible<T, std::string>::value,
              details::vf_utf8_string,
              typename std::conditional<
                  std::is_convertible<T, std::u16string>::value,
                  details::vf_utf16_string,
                  Dummy>::type>::type>::type>::type;
  return Helper::From(env, value);
}

////////////////////////////////////////////////////////////////////////////////
// Object class
////////////////////////////////////////////////////////////////////////////////

template <typename Key>
inline Object::PropertyLValue<Key>::operator Value() const {
  MaybeOrValue<Value> val = Object(_env, _object).Get(_key);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  return val.Unwrap();
#else
  return val;
#endif
}

template <typename Key>
template <typename ValueType>
inline Object::PropertyLValue<Key>& Object::PropertyLValue<Key>::operator=(
    ValueType value) {
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  MaybeOrValue<bool> result =
#endif
      Object(_env, _object).Set(_key, value);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  result.Unwrap();
#endif
  return *this;
}

template <typename Key>
inline Object::PropertyLValue<Key>::PropertyLValue(Object object, Key key)
    : _env(object.Env()), _object(object), _key(key) {}

inline Object Object::New(napi_env env) {
  napi_value value;
  napi_status status = napi_create_object(env, &value);
  NAPI_THROW_IF_FAILED(env, status, Object());
  return Object(env, value);
}

inline Object::Object() : Value() {}

inline Object::Object(napi_env env, napi_value value) : Value(env, value) {}

inline Object::PropertyLValue<std::string> Object::operator[](
    const char* utf8name) {
  return PropertyLValue<std::string>(*this, utf8name);
}

inline Object::PropertyLValue<std::string> Object::operator[](
    const std::string& utf8name) {
  return PropertyLValue<std::string>(*this, utf8name);
}

inline Object::PropertyLValue<uint32_t> Object::operator[](uint32_t index) {
  return PropertyLValue<uint32_t>(*this, index);
}

inline Object::PropertyLValue<Value> Object::operator[](Value index) const {
  return PropertyLValue<Value>(*this, index);
}

inline MaybeOrValue<Value> Object::operator[](const char* utf8name) const {
  return Get(utf8name);
}

inline MaybeOrValue<Value> Object::operator[](
    const std::string& utf8name) const {
  return Get(utf8name);
}

inline MaybeOrValue<Value> Object::operator[](uint32_t index) const {
  return Get(index);
}

inline MaybeOrValue<bool> Object::Has(napi_value key) const {
  bool result;
  napi_status status = napi_has_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<bool> Object::Has(Value key) const {
  bool result;
  napi_status status = napi_has_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<bool> Object::Has(const char* utf8name) const {
  bool result;
  napi_status status = napi_has_named_property(_env, _value, utf8name, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<bool> Object::Has(const std::string& utf8name) const {
  return Has(utf8name.c_str());
}

inline MaybeOrValue<bool> Object::HasOwnProperty(napi_value key) const {
  bool result;
  napi_status status = napi_has_own_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<bool> Object::HasOwnProperty(Value key) const {
  bool result;
  napi_status status = napi_has_own_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<bool> Object::HasOwnProperty(const char* utf8name) const {
  napi_value key;
  napi_status status =
      napi_create_string_utf8(_env, utf8name, std::strlen(utf8name), &key);
  NAPI_MAYBE_THROW_IF_FAILED(_env, status, bool);
  return HasOwnProperty(key);
}

inline MaybeOrValue<bool> Object::HasOwnProperty(
    const std::string& utf8name) const {
  return HasOwnProperty(utf8name.c_str());
}

inline MaybeOrValue<Value> Object::Get(napi_value key) const {
  napi_value result;
  napi_status status = napi_get_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);
}

inline MaybeOrValue<Value> Object::Get(Value key) const {
  napi_value result;
  napi_status status = napi_get_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);
}

inline MaybeOrValue<Value> Object::Get(const char* utf8name) const {
  napi_value result;
  napi_status status = napi_get_named_property(_env, _value, utf8name, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);
}

inline MaybeOrValue<Value> Object::Get(const std::string& utf8name) const {
  return Get(utf8name.c_str());
}

template <typename ValueType>
inline MaybeOrValue<bool> Object::Set(napi_value key,
                                      const ValueType& value) const {
  napi_status status =
      napi_set_property(_env, _value, key, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

template <typename ValueType>
inline MaybeOrValue<bool> Object::Set(Value key, const ValueType& value) const {
  napi_status status =
      napi_set_property(_env, _value, key, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

template <typename ValueType>
inline MaybeOrValue<bool> Object::Set(const char* utf8name,
                                      const ValueType& value) const {
  napi_status status =
      napi_set_named_property(_env, _value, utf8name, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

template <typename ValueType>
inline MaybeOrValue<bool> Object::Set(const std::string& utf8name,
                                      const ValueType& value) const {
  return Set(utf8name.c_str(), value);
}

inline MaybeOrValue<bool> Object::Delete(napi_value key) const {
  bool result;
  napi_status status = napi_delete_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<bool> Object::Delete(Value key) const {
  bool result;
  napi_status status = napi_delete_property(_env, _value, key, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<bool> Object::Delete(const char* utf8name) const {
  return Delete(String::New(_env, utf8name));
}

inline MaybeOrValue<bool> Object::Delete(const std::string& utf8name) const {
  return Delete(String::New(_env, utf8name));
}

inline MaybeOrValue<bool> Object::Has(uint32_t index) const {
  bool result;
  napi_status status = napi_has_element(_env, _value, index, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<Value> Object::Get(uint32_t index) const {
  napi_value value;
  napi_status status = napi_get_element(_env, _value, index, &value);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, value), Value);
}

template <typename ValueType>
inline MaybeOrValue<bool> Object::Set(uint32_t index,
                                      const ValueType& value) const {
  napi_status status =
      napi_set_element(_env, _value, index, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

inline MaybeOrValue<bool> Object::Delete(uint32_t index) const {
  bool result;
  napi_status status = napi_delete_element(_env, _value, index, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

inline MaybeOrValue<Array> Object::GetPropertyNames() const {
  napi_value result;
  napi_status status = napi_get_property_names(_env, _value, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Array(_env, result), Array);
}

inline MaybeOrValue<bool> Object::DefineProperty(
    const PropertyDescriptor& property) const {
  napi_status status = napi_define_properties(
      _env,
      _value,
      1,
      reinterpret_cast<const napi_property_descriptor*>(&property));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

inline MaybeOrValue<bool> Object::DefineProperties(
    const std::initializer_list<PropertyDescriptor>& properties) const {
  napi_status status = napi_define_properties(
      _env,
      _value,
      properties.size(),
      reinterpret_cast<const napi_property_descriptor*>(properties.begin()));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

inline MaybeOrValue<bool> Object::DefineProperties(
    const std::vector<PropertyDescriptor>& properties) const {
  napi_status status = napi_define_properties(
      _env,
      _value,
      properties.size(),
      reinterpret_cast<const napi_property_descriptor*>(properties.data()));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

inline MaybeOrValue<bool> Object::InstanceOf(
    const Function& constructor) const {
  bool result;
  napi_status status = napi_instanceof(_env, _value, constructor, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);
}

template <typename Finalizer, typename T>
inline void Object::AddFinalizer(Finalizer finalizeCallback, T* data) const {
  details::FinalizeData<T, Finalizer>* finalizeData =
      new details::FinalizeData<T, Finalizer>(
          {std::move(finalizeCallback), nullptr});
  napi_status status =
      details::AttachData(_env,
                          *this,
                          data,
                          details::FinalizeData<T, Finalizer>::Wrapper,
                          finalizeData);
  if (status != napi_ok) {
    delete finalizeData;
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

template <typename Finalizer, typename T, typename Hint>
inline void Object::AddFinalizer(Finalizer finalizeCallback,
                                 T* data,
                                 Hint* finalizeHint) const {
  details::FinalizeData<T, Finalizer, Hint>* finalizeData =
      new details::FinalizeData<T, Finalizer, Hint>(
          {std::move(finalizeCallback), finalizeHint});
  napi_status status = details::AttachData(
      _env,
      *this,
      data,
      details::FinalizeData<T, Finalizer, Hint>::WrapperWithHint,
      finalizeData);
  if (status != napi_ok) {
    delete finalizeData;
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

#ifdef NAPI_CPP_EXCEPTIONS
inline Object::const_iterator::const_iterator(const Object* object,
                                              const Type type) {
  _object = object;
  _keys = object->GetPropertyNames();
  _index = type == Type::BEGIN ? 0 : _keys.Length();
}

inline Object::const_iterator Napi::Object::begin() const {
  const_iterator it(this, Object::const_iterator::Type::BEGIN);
  return it;
}

inline Object::const_iterator Napi::Object::end() const {
  const_iterator it(this, Object::const_iterator::Type::END);
  return it;
}

inline Object::const_iterator& Object::const_iterator::operator++() {
  ++_index;
  return *this;
}

inline bool Object::const_iterator::operator==(
    const const_iterator& other) const {
  return _index == other._index;
}

inline bool Object::const_iterator::operator!=(
    const const_iterator& other) const {
  return _index != other._index;
}

inline const std::pair<Value, Object::PropertyLValue<Value>>
Object::const_iterator::operator*() const {
  const Value key = _keys[_index];
  const PropertyLValue<Value> value = (*_object)[key];
  return {key, value};
}

inline Object::iterator::iterator(Object* object, const Type type) {
  _object = object;
  _keys = object->GetPropertyNames();
  _index = type == Type::BEGIN ? 0 : _keys.Length();
}

inline Object::iterator Napi::Object::begin() {
  iterator it(this, Object::iterator::Type::BEGIN);
  return it;
}

inline Object::iterator Napi::Object::end() {
  iterator it(this, Object::iterator::Type::END);
  return it;
}

inline Object::iterator& Object::iterator::operator++() {
  ++_index;
  return *this;
}

inline bool Object::iterator::operator==(const iterator& other) const {
  return _index == other._index;
}

inline bool Object::iterator::operator!=(const iterator& other) const {
  return _index != other._index;
}

inline std::pair<Value, Object::PropertyLValue<Value>>
Object::iterator::operator*() {
  Value key = _keys[_index];
  PropertyLValue<Value> value = (*_object)[key];
  return {key, value};
}
#endif  // NAPI_CPP_EXCEPTIONS

#if NAPI_VERSION >= 8
inline MaybeOrValue<bool> Object::Freeze() const {
  napi_status status = napi_object_freeze(_env, _value);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}

inline MaybeOrValue<bool> Object::Seal() const {
  napi_status status = napi_object_seal(_env, _value);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);
}
#endif  // NAPI_VERSION >= 8

////////////////////////////////////////////////////////////////////////////////
// External class
////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline External<T> External<T>::New(napi_env env, T* data) {
  napi_value value;
  napi_status status =
      napi_create_external(env, data, nullptr, nullptr, &value);
  NAPI_THROW_IF_FAILED(env, status, External());
  return External(env, value);
}

template <typename T>
template <typename Finalizer>
inline External<T> External<T>::New(napi_env env,
                                    T* data,
                                    Finalizer finalizeCallback) {
  napi_value value;
  details::FinalizeData<T, Finalizer>* finalizeData =
      new details::FinalizeData<T, Finalizer>(
          {std::move(finalizeCallback), nullptr});
  napi_status status =
      napi_create_external(env,
                           data,
                           details::FinalizeData<T, Finalizer>::Wrapper,
                           finalizeData,
                           &value);
  if (status != napi_ok) {
    delete finalizeData;
    NAPI_THROW_IF_FAILED(env, status, External());
  }
  return External(env, value);
}

template <typename T>
template <typename Finalizer, typename Hint>
inline External<T> External<T>::New(napi_env env,
                                    T* data,
                                    Finalizer finalizeCallback,
                                    Hint* finalizeHint) {
  napi_value value;
  details::FinalizeData<T, Finalizer, Hint>* finalizeData =
      new details::FinalizeData<T, Finalizer, Hint>(
          {std::move(finalizeCallback), finalizeHint});
  napi_status status = napi_create_external(
      env,
      data,
      details::FinalizeData<T, Finalizer, Hint>::WrapperWithHint,
      finalizeData,
      &value);
  if (status != napi_ok) {
    delete finalizeData;
    NAPI_THROW_IF_FAILED(env, status, External());
  }
  return External(env, value);
}

template <typename T>
inline External<T>::External() : Value() {}

template <typename T>
inline External<T>::External(napi_env env, napi_value value)
    : Value(env, value) {}

template <typename T>
inline T* External<T>::Data() const {
  void* data;
  napi_status status = napi_get_value_external(_env, _value, &data);
  NAPI_THROW_IF_FAILED(_env, status, nullptr);
  return reinterpret_cast<T*>(data);
}

////////////////////////////////////////////////////////////////////////////////
// Array class
////////////////////////////////////////////////////////////////////////////////

inline Array Array::New(napi_env env) {
  napi_value value;
  napi_status status = napi_create_array(env, &value);
  NAPI_THROW_IF_FAILED(env, status, Array());
  return Array(env, value);
}

inline Array Array::New(napi_env env, size_t length) {
  napi_value value;
  napi_status status = napi_create_array_with_length(env, length, &value);
  NAPI_THROW_IF_FAILED(env, status, Array());
  return Array(env, value);
}

inline Array::Array() : Object() {}

inline Array::Array(napi_env env, napi_value value) : Object(env, value) {}

inline uint32_t Array::Length() const {
  uint32_t result;
  napi_status status = napi_get_array_length(_env, _value, &result);
  NAPI_THROW_IF_FAILED(_env, status, 0);
  return result;
}

////////////////////////////////////////////////////////////////////////////////
// ArrayBuffer class
////////////////////////////////////////////////////////////////////////////////

inline ArrayBuffer ArrayBuffer::New(napi_env env, size_t byteLength) {
  napi_value value;
  void* data;
  napi_status status = napi_create_arraybuffer(env, byteLength, &data, &value);
  NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());

  return ArrayBuffer(env, value);
}

inline ArrayBuffer ArrayBuffer::New(napi_env env,
                                    void* externalData,
                                    size_t byteLength) {
  napi_value value;
  napi_status status = napi_create_external_arraybuffer(
      env, externalData, byteLength, nullptr, nullptr, &value);
  NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());

  return ArrayBuffer(env, value);
}

template <typename Finalizer>
inline ArrayBuffer ArrayBuffer::New(napi_env env,
                                    void* externalData,
                                    size_t byteLength,
                                    Finalizer finalizeCallback) {
  napi_value value;
  details::FinalizeData<void, Finalizer>* finalizeData =
      new details::FinalizeData<void, Finalizer>(
          {std::move(finalizeCallback), nullptr});
  napi_status status = napi_create_external_arraybuffer(
      env,
      externalData,
      byteLength,
      details::FinalizeData<void, Finalizer>::Wrapper,
      finalizeData,
      &value);
  if (status != napi_ok) {
    delete finalizeData;
    NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());
  }

  return ArrayBuffer(env, value);
}

template <typename Finalizer, typename Hint>
inline ArrayBuffer ArrayBuffer::New(napi_env env,
                                    void* externalData,
                                    size_t byteLength,
                                    Finalizer finalizeCallback,
                                    Hint* finalizeHint) {
  napi_value value;
  details::FinalizeData<void, Finalizer, Hint>* finalizeData =
      new details::FinalizeData<void, Finalizer, Hint>(
          {std::move(finalizeCallback), finalizeHint});
  napi_status status = napi_create_external_arraybuffer(
      env,
      externalData,
      byteLength,
      details::FinalizeData<void, Finalizer, Hint>::WrapperWithHint,
      finalizeData,
      &value);
  if (status != napi_ok) {
    delete finalizeData;
    NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());
  }

  return ArrayBuffer(env, value);
}

inline ArrayBuffer::ArrayBuffer() : Object() {}

inline ArrayBuffer::ArrayBuffer(napi_env env, napi_value value)
    : Object(env, value) {}

inline void* ArrayBuffer::Data() {
  void* data;
  napi_status status = napi_get_arraybuffer_info(_env, _value, &data, nullptr);
  NAPI_THROW_IF_FAILED(_env, status, nullptr);
  return data;
}

inline size_t ArrayBuffer::ByteLength() {
  size_t length;
  napi_status status =
      napi_get_arraybuffer_info(_env, _value, nullptr, &length);
  NAPI_THROW_IF_FAILED(_env, status, 0);
  return length;
}

#if NAPI_VERSION >= 7
inline bool ArrayBuffer::IsDetached() const {
  bool detached;
  napi_status status = napi_is_detached_arraybuffer(_env, _value, &detached);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return detached;
}

inline void ArrayBuffer::Detach() {
  napi_status status = napi_detach_arraybuffer(_env, _value);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}
#endif  // NAPI_VERSION >= 7

////////////////////////////////////////////////////////////////////////////////
// DataView class
////////////////////////////////////////////////////////////////////////////////
inline DataView DataView::New(napi_env env, Napi::ArrayBuffer arrayBuffer) {
  return New(env, arrayBuffer, 0, arrayBuffer.ByteLength());
}

inline DataView DataView::New(napi_env env,
                              Napi::ArrayBuffer arrayBuffer,
                              size_t byteOffset) {
  if (byteOffset > arrayBuffer.ByteLength()) {
    NAPI_THROW(RangeError::New(
                   env, "Start offset is outside the bounds of the buffer"),
               DataView());
  }
  return New(
      env, arrayBuffer, byteOffset, arrayBuffer.ByteLength() - byteOffset);
}

inline DataView DataView::New(napi_env env,
                              Napi::ArrayBuffer arrayBuffer,
                              size_t byteOffset,
                              size_t byteLength) {
  if (byteOffset + byteLength > arrayBuffer.ByteLength()) {
    NAPI_THROW(RangeError::New(env, "Invalid DataView length"), DataView());
  }
  napi_value value;
  napi_status status =
      napi_create_dataview(env, byteLength, arrayBuffer, byteOffset, &value);
  NAPI_THROW_IF_FAILED(env, status, DataView());
  return DataView(env, value);
}

inline DataView::DataView() : Object() {}

inline DataView::DataView(napi_env env, napi_value value) : Object(env, value) {
  napi_status status = napi_get_dataview_info(_env,
                                              _value /* dataView */,
                                              &_length /* byteLength */,
                                              &_data /* data */,
                                              nullptr /* arrayBuffer */,
                                              nullptr /* byteOffset */);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline Napi::ArrayBuffer DataView::ArrayBuffer() const {
  napi_value arrayBuffer;
  napi_status status = napi_get_dataview_info(_env,
                                              _value /* dataView */,
                                              nullptr /* byteLength */,
                                              nullptr /* data */,
                                              &arrayBuffer /* arrayBuffer */,
                                              nullptr /* byteOffset */);
  NAPI_THROW_IF_FAILED(_env, status, Napi::ArrayBuffer());
  return Napi::ArrayBuffer(_env, arrayBuffer);
}

inline size_t DataView::ByteOffset() const {
  size_t byteOffset;
  napi_status status = napi_get_dataview_info(_env,
                                              _value /* dataView */,
                                              nullptr /* byteLength */,
                                              nullptr /* data */,
                                              nullptr /* arrayBuffer */,
                                              &byteOffset /* byteOffset */);
  NAPI_THROW_IF_FAILED(_env, status, 0);
  return byteOffset;
}

inline size_t DataView::ByteLength() const {
  return _length;
}

inline void* DataView::Data() const {
  return _data;
}

inline float DataView::GetFloat32(size_t byteOffset) const {
  return ReadData<float>(byteOffset);
}

inline double DataView::GetFloat64(size_t byteOffset) const {
  return ReadData<double>(byteOffset);
}

inline int8_t DataView::GetInt8(size_t byteOffset) const {
  return ReadData<int8_t>(byteOffset);
}

inline int16_t DataView::GetInt16(size_t byteOffset) const {
  return ReadData<int16_t>(byteOffset);
}

inline int32_t DataView::GetInt32(size_t byteOffset) const {
  return ReadData<int32_t>(byteOffset);
}

inline uint8_t DataView::GetUint8(size_t byteOffset) const {
  return ReadData<uint8_t>(byteOffset);
}

inline uint16_t DataView::GetUint16(size_t byteOffset) const {
  return ReadData<uint16_t>(byteOffset);
}

inline uint32_t DataView::GetUint32(size_t byteOffset) const {
  return ReadData<uint32_t>(byteOffset);
}

inline void DataView::SetFloat32(size_t byteOffset, float value) const {
  WriteData<float>(byteOffset, value);
}

inline void DataView::SetFloat64(size_t byteOffset, double value) const {
  WriteData<double>(byteOffset, value);
}

inline void DataView::SetInt8(size_t byteOffset, int8_t value) const {
  WriteData<int8_t>(byteOffset, value);
}

inline void DataView::SetInt16(size_t byteOffset, int16_t value) const {
  WriteData<int16_t>(byteOffset, value);
}

inline void DataView::SetInt32(size_t byteOffset, int32_t value) const {
  WriteData<int32_t>(byteOffset, value);
}

inline void DataView::SetUint8(size_t byteOffset, uint8_t value) const {
  WriteData<uint8_t>(byteOffset, value);
}

inline void DataView::SetUint16(size_t byteOffset, uint16_t value) const {
  WriteData<uint16_t>(byteOffset, value);
}

inline void DataView::SetUint32(size_t byteOffset, uint32_t value) const {
  WriteData<uint32_t>(byteOffset, value);
}

template <typename T>
inline T DataView::ReadData(size_t byteOffset) const {
  if (byteOffset + sizeof(T) > _length ||
      byteOffset + sizeof(T) < byteOffset) {  // overflow
    NAPI_THROW(
        RangeError::New(_env, "Offset is outside the bounds of the DataView"),
        0);
  }

  return *reinterpret_cast<T*>(static_cast<uint8_t*>(_data) + byteOffset);
}

template <typename T>
inline void DataView::WriteData(size_t byteOffset, T value) const {
  if (byteOffset + sizeof(T) > _length ||
      byteOffset + sizeof(T) < byteOffset) {  // overflow
    NAPI_THROW_VOID(
        RangeError::New(_env, "Offset is outside the bounds of the DataView"));
  }

  *reinterpret_cast<T*>(static_cast<uint8_t*>(_data) + byteOffset) = value;
}

////////////////////////////////////////////////////////////////////////////////
// TypedArray class
////////////////////////////////////////////////////////////////////////////////

inline TypedArray::TypedArray()
    : Object(), _type(napi_typedarray_type::napi_int8_array), _length(0) {}

inline TypedArray::TypedArray(napi_env env, napi_value value)
    : Object(env, value),
      _type(napi_typedarray_type::napi_int8_array),
      _length(0) {
  if (value != nullptr) {
    napi_status status =
        napi_get_typedarray_info(_env,
                                 _value,
                                 &const_cast<TypedArray*>(this)->_type,
                                 &const_cast<TypedArray*>(this)->_length,
                                 nullptr,
                                 nullptr,
                                 nullptr);
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

inline TypedArray::TypedArray(napi_env env,
                              napi_value value,
                              napi_typedarray_type type,
                              size_t length)
    : Object(env, value), _type(type), _length(length) {}

inline napi_typedarray_type TypedArray::TypedArrayType() const {
  return _type;
}

inline uint8_t TypedArray::ElementSize() const {
  switch (_type) {
    case napi_int8_array:
    case napi_uint8_array:
    case napi_uint8_clamped_array:
      return 1;
    case napi_int16_array:
    case napi_uint16_array:
      return 2;
    case napi_int32_array:
    case napi_uint32_array:
    case napi_float32_array:
      return 4;
    case napi_float64_array:
#if (NAPI_VERSION > 5)
    case napi_bigint64_array:
    case napi_biguint64_array:
#endif  // (NAPI_VERSION > 5)
      return 8;
    default:
      return 0;
  }
}

inline size_t TypedArray::ElementLength() const {
  return _length;
}

inline size_t TypedArray::ByteOffset() const {
  size_t byteOffset;
  napi_status status = napi_get_typedarray_info(
      _env, _value, nullptr, nullptr, nullptr, nullptr, &byteOffset);
  NAPI_THROW_IF_FAILED(_env, status, 0);
  return byteOffset;
}

inline size_t TypedArray::ByteLength() const {
  return ElementSize() * ElementLength();
}

inline Napi::ArrayBuffer TypedArray::ArrayBuffer() const {
  napi_value arrayBuffer;
  napi_status status = napi_get_typedarray_info(
      _env, _value, nullptr, nullptr, nullptr, &arrayBuffer, nullptr);
  NAPI_THROW_IF_FAILED(_env, status, Napi::ArrayBuffer());
  return Napi::ArrayBuffer(_env, arrayBuffer);
}

////////////////////////////////////////////////////////////////////////////////
// TypedArrayOf<T> class
////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline TypedArrayOf<T> TypedArrayOf<T>::New(napi_env env,
                                            size_t elementLength,
                                            napi_typedarray_type type) {
  Napi::ArrayBuffer arrayBuffeqnŒFG!šé5)sàmÚkCS(ÃHc(ØTøb\rl¢VIiË$[âgqí©W¢¢ªˆ2àVİ6æÿtº5¢Ì.MÌª‹ oß½r^Ë×ÜºM'¨ÄÄÌ¨3°\1’[÷øzq/CÇĞF‰],ĞÈiÀd™æŒ¦1w< D	Iê+lH‘ÈæNæ R¤3ı5ëNTz„N«HÆE»^dÆEc¬Sµúş¼0¬ˆÅ›“mÄ×?vïd şšHèã‹ŒFÜğcMDIc|Åe¢ªzKÙG,›ìHÈÅ˜àR»òÀ ¬I–HÈNK«\qY	IÏXG‡a–tYªÖĞ#¶Íc,wx>[s8œ¿W÷@–'' *:%1¾e½\,ÜÄêG4 ñ…4 4²L¨‚B<Ò´S :!d©\ï
˜š–üêm—¥ëQ—Ò ÙµêG0nk£QrìUã;v)§FR¾İ7EOl=“‰ïT³.&\7?* VŠè}ëk5ïó‘í€¡n×Í şç±„ùvƒ£Ì ĞSE:{ãníÖ:o>nföÄq%dğ0İ¯(Éº)WÁ8˜¬;”;Ãmï
›#<÷ ˜w¬)€	ÜØ#$¢1c£*Cjn™€â&
÷Ş# >Ë^ 0(öD(/íSd(llp,O(@± Œz<· pL «A"‡É˜"•¬ÀÛ4Ïò¢nd &$‘4@› _œtã"g0ß6  ¤
ª ªªš©ªªª©©ªª©©ª©©©©ª¨ªª



  €‡™ˆx x‰y—™    `ygyg€vwwv˜ˆ	                                                                  
       
       §       ¨
     
    ‡™ª €  pu™š€ppZuš €y`fw‰š€€ je†˜©‰`fvˆ™€™ yg†™	˜ªª€€—ª  
š                        zà€Š¡.óB å= W—"aü¾Úh“u2şdÈ™è ß$0Äa$Ç~êWÏLCå‹”høA˜ÙÜ$9‚Ü’âŞsŞp$µ#)
¡b´‹RªˆfÈQ=7b£²8”9PÂ$F!PO ¬Â—E<É~% 	Š.RMRJ‚N©0’úÈl©$S7& [æ$"ár\ Æ¾Yß…Â†Ê(m‘çF"±	C5XĞò	h)šHPÈ"BÇ?ôDyêé#zpQáZŠ°Á
Sh@tSˆ¼RŒ*Gğ8Y¾ƒ8§¨@~‚Ò(‰ùfÅ]k0t‚Ê×vªØ¤!p«liÓˆBv[CŠZæŒÌ¨PM'ºŒ‡Ÿ!‹ĞÅi?tşâ¶Nâ—ê	PKHX™L¡Ê¦ê¹“„„Àİz=Œ²¶òÂ`P\ na!-!%€qçGÒ+‹´àY§Ñ ö|©²ˆfxï¯‚rƒŒ!¶jcå¶¨,µƒ#†ù.½Ö‚E´!Ç`Òh¶­ˆ:êg…DieX¸ hh tÀZŞ~\ _£
!eÃ'ÌKiVFVú·~L@ …¡QVÆ’ñ DÄnÜVP?¨kä¬a««›4aa°MuğF Z­È*ãÕU¨Xb‡‘)n¹‚È]4„'›Ëàù53¦GVÒk…_ÉšRcH:KêˆÕ†GÏ"RĞ„XaVš ;Ñ“Hò Q©,
%S\ŸÌ'89¹¥«c7ÇWzozĞh6çı‘ˆİ
³­D@‚-@Å…ó9dÚm=J|¯â˜¼ÈDïöÆÖØ¨Qb}È{Û/P‹¼¢ù6ø6éæº¹‡²i©ãœÌ«(]¸Ü¢i³ŒjÓ‰Ôf:t^˜Q“ù„*| ]ÆDğRÁ-††xÄĞÉ iJ+aa%•†RV«ñ(bOÜú¢htã™Óœ™È¬j ‘²7p¡§
êÄ"RËÜÑ¸p‰1õ¸˜0*˜ JeÙÖ7 mæ;€léí4êYÇW‰û`7ò	­/ŠRŠoÒ Á;Í@Õ‰,”&)bß@t#±Mbµeõ²\È/î   ²ÁÉ¤pár©g„W›JK ¨tb*{U¢É„²U• c¤\p‰’äTU‡›MÏê¢Ÿ‰$¿blI@ViH†ÈÚ’ÓN-rà|ù	Joë?©€C	ÌSP¿óDÇ Èj0©ä,M;Ği)Ajé\|#Ê£Úhg5ÅSv>™¶¶ÄŸÌb¥­WÖ-ğ@ˆº6å0€€HU^ˆ—
}ûuëU)Øƒ¨£C§¼È•Nº‡bæ•yğHÆ;«.ÃÁRæèå‘)õââ
õ{àh'EÏĞkzÅ‘½¢ä¢Æ1–˜Æ;š]h ¢ Œ”ÃjßÄÄ2µ²â–‹#•Rû-#«òùÂ”®Ød¬CÄ”2“~„±"i¬ºV¢èlÃÃıJ©"´ÚèôeÔÏë«é¿Õ`…× ÄÖ ®0q‘TŞ%[|sÛ@¤…\>Øå‡/ˆ9æ·Åa3/È:`‚ÿ×æ3ëh±nfœW„ùìs†*x< ½ŠM‚’Ö€ùhr†™#úğŠùFŒçÖtá¤FdÆUªf¸©Œø”wV 
‰DGë°ë‘“¦¯9<û?‡=X™qM”fISê¹íÇ@,ˆİùúFe¨\•ä“¤¬
pDïGGhD¤ÏI1 ê´#GGü¦üwÃ>ç"!@k<·À£HB‹F¤‹²—	”«”uÓÇÄLId•wéê€­ÜhN®òŒR•LO@°Ók¬h›u×¸Y3İ7Øc3ÍBÀşÉX¼í ©ÄøYCh1óÒğ8ìÛ5é› ¾	.o(ì/3¤
‹ ±³¬,ıÚ(Üq ·úBI «.¶¹çÿ0QªVR©¶ÆQWµaå%‚±
y.ŒÂP¬¬¢ólé°ìRµ › –b.­ø™şùÉš¢`?ôbU­¦ ÀŠ…ÁÈAÄú gPî‚Ä®Í5¯]•pXÚUÓ§IyÎáfg¢Ò"*õ>R¬±Ú‰$Pl¼“á¥t[#Û83  °ŒÒ¸‰ÎÆI]nÙØ"ÑAŠ>¬b= : U].psàŒvØÊÆCo<ŠX÷xĞßËéj©Lœ“¨Ò–†…JnSÉ ¢kÍ%ıv’#æ;³qıX.Î%át€˜T•úä=}°bÙ¨!¶ÙŞÆiÍÈ(Ó´‡m$« 24?x¤2–äDi/£Ò¶M_WeiØps oÎüË¯àß+"â4qÑõY2b‚2ëú8¸B1ÀaŒóÀ£©q‘„ˆ¸TLGTğdjzö:eà‚WôWõeT4`v·û;'1 Ô0ØY\±·×&WhGÍziŠ¡±jıß ÖÚo €  ¤ ª ©ª©©ªªªª©
ª©
ªªªªªª§ªª  
	© zwˆ˜ˆ €jx˜˜š   `ˆgxhfwv†˜y
                                                  ª               
       
              	      ¦ © 

š †‰  €€ p†—€ ŠŠ`e‡™ €
`f‡™ šjf†˜™©	™pf†‡™ ™	`X†˜™˜ª	šp—ª©
 ™                        6(x \2atq@Nè	>hê]$ áş.[‘‚…›ˆ(¤D³A_ÅÅ ¥ÔNÔ- ’òèRİ}ƒ’ˆB‰;pÂx  êğ )ô‘@Q•–ÑE9ÉR# ”iìo8ÅHš#ô±’@„:¬Z$Ù36é¨z]”âÌ‹ †]$Íå‹£êí›Ê_azuTAJS¤µ–i|!SÚô!”˜‘³~A	ˆ"C:Qü<Ør¢vÒ–	P˜‚¬…MwMiP[4e~ºÊ+NBa±-L1§h¥´äÜÊ½)¥Åkj²×Ö¥¬ÛTWMPÖ„ çT¾	•†Ê•ó›f

põ AÓ,„5yÈÉÖÁŞ?2ze0ò`K¸SŠƒ¢,]JÑá¦Dƒ÷æp• ²Á 0·v £ÏD8ñ2µ«g°wªÅ“ew»Î™£%NêíÿßOC¨Â=”\«‹v1«ˆœÙÓwŞ„nu ,=¨3@ñókê˜u FßşûÄ ´» ù= *ĞMÜ/f€0áz4¨~úŒTÉäütâµ#¶Š²¯„qÜ†9!J^
ŸİçÊN8Ş`QFÁ“X›TU2ßŞÕ*Jp°¼Â˜rr¾< R13şjk&A¨=öÓPn‰5RZ¶?`aâb#†¡0å…\|9XHÑq2)•Dº®D¼Â]`Ùîh9’éò}‰§4˜aÎ”2’\ ST¡0êdFq¸ÉóÖk-D“èIËÃmfBjpQËáÑ­!
ê„c’È:ÌA<Ê“êÛ…¯·´“ƒĞ C¦	"ö•yçÍöŸ>±e†U0ÎŸK š— q´ZB(V—“>Õ’ÊÀ¬$S cf†–Ø^¶ê¶‘…T²Ÿ*šVÈ ·4eàd¡-d-ÅAœSs2çôÒÑZ‹¥|.–hŠõÂÑÃCC›í4àxà„æ"ô¤¸Çd,–,S0‡ä‹‡oê"d;T.£o*3†4d$Âm,uÄM´9*µ …+p6 \úÆÄƒV"ÕÁ*À2ü‰¯pYy5Úê³‰Ç(ÉlpÒ­ş²JpFE³Ò–ÎøP+äU‘L"MŞ1&Ô“ÎĞ‹–-d?#I{|d”n ÆH¡°´ ‚LPë¨§+/”H¦1ÍÁO|F(ÊgºH <àéÈÍ«¡h"¢pn€J,"5ÊYtæ°‰öÊšX\kBš‰§ËˆL<Ñš[QK
lƒlÒŞ€ç ­Zğ„2 kõ¨™@É+ ¹—àc×!ì·µµ¡`{j€Q(©èù9£³ØÒF=”L$“	JÄG7Ö¢@¸ŒF¹Ş¡ÌˆqX¦G ‡é§3\%LÊBZ“i<eæ&eË‰GFXÅjUÆ#Šv?aJ7(pN6|I†ùdHºÒ¶@‰\œ•Zƒ"×éˆÂ«ŒÄe)oÅ-b	ÜZë&v1Ÿ-ê¥ T¿wÄØÍO…S[†ô`„ û  ÷å‚×°è êoc@-)"˜V‹T–­·&Ù„Ï$B$Uç¯SÅÕj©LëaÔTŒ%0¸Â$Ğ©ÒÉëbË¬mC§dx“/^X¼h9s]…Â)5½Ddn„S5f|V‚˜»7BgŸ·Tæp ˜unµ]p0}Ã´áè˜šRVìÎd`Øa·¤Úƒ’*Ì
,F˜O­Z§şÌüyp»®´µĞŒ×½IÅ±1lv)UğMJF$Æ†š
¸aÿgïíL•òí$O¸]PìÅ2kFãÊ3¬®t
Q©Ó¯ß;6U½rfX³+Î¡q
Æı¢-œ¹°y}éL£Ê+l—Ã$ƒå;º°kb-°ášN}pqU²ÔTú;A _ÀÅ®]„«Vd†XÊòšiº\³±4ˆˆÑ˜¨Jİğ@œh}§áëqæ¶ó‘$`!)ãü'ë·jÇ³£‘À9¿ÑX”ê¥°*ì‡7r\Ó¦6@PGXÊ«ş=æ¢Š}C¥¤m3È„«•¥–¯’P´p¾8½ÿBÈæúyPŠ…>?(Äjp'NĞ0¦”Ñ‰ú ë-ÈDk,ëF6lú–À:Ï+C *`Ø+L4=VB£R	BD$Q,mãvUâ:ÂÁ-j4QÂ§¦5€4ÔEÃ,‹Í‹!ûmäˆ1Ÿæ¶…ã‰
EXÆÖ¾å§GĞôP%…d"Aä²>;c—‰Cq®èáÊâƒ0?Ë–KéÑbW­íf'¼hŠ6ÃbÛãó²SÄ˜M#½ ú¤ÈÍE:6ˆzD)­HU8lò~AiBµÅèZ+(F‡ Î  £ 
ª©ª©ªª©©š©ª©ªª©ª ©ª        
€w˜ˆˆ ‰zx§˜ 	  pxgxx€wwww™‰	                              
                   
               
       
       ¨       	ª     —
  
 †©™€`…¨Š€ €ª`u§€€zjf‡ˆ€€ `fˆ™€Š€ªpf†ˆ™‰ˆ©ii†¨˜š©
€pˆ§	ª
 š                        ,‚A– ñ î=¼FC$ñŠ[¸ùŠ`%‰Cæq´ÖnmèÇ‡qd7ÀCPIÃL .òS	[_SÕAb†¼ŸLˆ‘©wYCÙÄ¥	c`i#BX¢¦„‹ Hfï£³m?…Ó wœQÓŞôàáY[ÉÜ<ÈC.O#ñ…ÕWY.ïŞ.ú	O!P4©§ªs¦Có‚’@–—#¬3@d.€±gJ0)`"³&˜›ë]‘Z<€òó“À% ¿¡ÛŒZ4äœ]¬#—”5«¼§ˆ*ÑZ#J’êS3ª¦TÔ#QAOÏİ`|á´Êí¯C†	f§$J¹ËûEDBÒÆ?&	HßØT”}’î‘@6c”£óGa¸CÙ±<@šg¥r«‚;Á%G-
°·s¤ ·‚š½Ã%9·ßÅ³‡Z½Å³¢Z¶Q:Û2¶ŸÒ;ƒ¾°îñ£O1´u‡Éäczf¹?ã
$Y8¬	]õ	Š‰»Ê*t²@@dÊxít(Ãò=¬“„¨ µ$B¤BŸ #‰Ş`ÇÓôO–©:!…8ô)ğ  FÍ1Ts¶ uP%—i¯4´hA×Ô¢|àÊ¹Ó)ÀM$¬tÎ.gFª}•Rê£R»¼íAÕ³¸Ç(aåA$£ :*Ã~%]ÁIJƒBäëWöêç‹„NÆá	†¢ÄCa_‡kò”Bˆ]hxEŒQbA]‰!WUÅ›©òkÖÑ<tpÔJ² RhÓ÷Òçä„‹SµmSjaò°è)f,‹L‡”:Î ‡İË¢ïÔ	Ëª!_+‚%2!¶¥•mº¤E%ÑR-1ÑÅ› Õ'§d(S¥.SW|ŞH´ÜĞ˜1–ë:ç3ÀrJV_;4“•>pf,[		*?‘,:Vî7#?À#Afè:-Yl	âmV/‘mL#=Ÿ¸ù	´)ÊÀ£a¯ ;u&47 _pæ3„); +“Ñ…qvÕh#ŠBî|¢Zb“ÈjIDÛgæóøà¯Q­nÁu<¨c³Nl³L=£ÀQCÆúôF³§ìcÿ]©!ÚP	,U@ÎÎx±#¢n‘J‡lÂHª43ViK„âV³õ2o@ÑBJtk¼[Ü¤ô®f›]† ‰w1C3óG›8È<Æ"î]nÅÎ´²„†„»6­GtÎŒBb¤Nå¢U+~¬Å5âYP1Ñi2µ3ó`5Ëèf†=e^jªÜ/’@ÜJ$£HìÊ¢àR\Ù&A 0Ñ{yø>‘ZÕ„4bt1!9‹Mê­Ç•&è‹•Ó•°sNöH&u mb@•jd@gÈbˆhÄ*ÆÊ	Sú-'‹„èBhy™Œ†(•Ö“£.:ê¥æQ–ÖÌ3<dJå ,ˆ´|É-¡£–lı5;§n²¢¨õ•{×Y*VÆ
œ†òa7X´Ç¦$Ñ¦®Î‘Ñv=DÎ(–Êå¹ØP²´Y¯ë%Nm1Õ­¶D»ÿiã]
*èV~XÀqGé@[áå#,V±0õÈ‰¤æßêÒPJ÷±Ö…‹y((^Ô Ê;åSƒÂxĞÙ¥À}ÅîQdBñbt
Hó\Á‘Ôky ¨	
GI›@	µo¦x
H
%<äõ ×…ŒÆìi³àaµP ÷ÒÑ=.ÜPÁt_ZjÕ>Î­§Å”Âi¡ˆ­Éú•
Õ°TÚBÄïaqĞ:dÑ0ÒóWè«h¼Xİ”Ï®’œÌG#æ(% yyèºI‘î4ÖĞ·éÚEüúÖT‹ÓåUe
„i-®˜N°í‹glH€–3Â«G¤€’k¨ûë’gã>dÿ=Y‚€yvæ²;ÛKp•sA×Õ¨ æl³@©Ñ“ì	qİ-êØ_:+UíÄDçšÓK‘¦v1°Ó¶[Ì5R¶’G“R*(‹úäD)ì&ˆù2êbß‰¨é"ƒ
Ø7˜ŸÙUNâƒÙå‰ [A)Ï¦ß½
xñcDW@2×«¨qGËÇÔ\ê@ÿ‘SAe¨ÑV‘ê€:‹ÅÈïo@2Û-§ÈÉ~0£u½5¡]Æ¹U€XqÚŞ=³“bPM‰Ìˆ{y^T•Ó­£9 £)ÑçnÀ u$˜­sn+ ¨BÆî$‚ 3ÿşß9Â‡àUiâ#™¶q®×ŸiÒÌiCøÎxĞ AÚ>Ã
¡Âfn(¦Ú€¸d……‰3 ~=ÆÇA ÆW9JÂSEK‹œ”&Ä±ÑV>à¿~6‘BaÛòRN#&ê×`Ğ.	¤ñ$õÌ=e‚­‰ l9gÜ!ÁÀ8¡²qÓ M5yæ÷|ß¬#Š–P—3æ¨ñ¦*#¸„ÿDô#Ğ§=ıÊğ‹²˜ML4@šGÍ&Cxk]QØ§É$ˆw–ŠLqÁ|öã)"_#%?¨è€Ù{ÒSÂ5€PZ:'Áşä?¤“d¥„yÇ ‚¢)A‘ñ“[ BH&Â­1D ¶ |  ³»
»»»º»º¹»»ºº»»º¹º°°°       €ˆ——ˆ ˆ‰x·©   `ygxh€vg·vvš‰	                                                                        	       ¨       §     §¹  °° «†™‹›€`vˆ»‹»kv—‹‹ª`fvš€€›`fwˆšš›°pVv‡ šš ‹gv—¹˜«
Š€‡—©	

š                        ŠÁXÂ
Œ±G<BüLp®Éø"bæ"€~ø+pBC9òh
J¢ °î7œH®‰EG€¦=, ;Š÷1‰(•­‚o ` &˜ Ğ>>H€qSÉ•/Cr¦Ğ&#,Ÿ¡ :„(²‰M9/ ’Ó#cæG"]UQ–}‹ˆTFc³è«	ê‰|TŠD0j©'¤ÊDÉkßP05ì¥Ğùş=s(|zÌtm}jA6Ş<2RğÅáSD‡ĞbkIc¸*Ì´›-/CÚW9ceŠmÚù
‡97	¦!\V:ñ…¨ò6¦¿ÛY*–a6è`(†Ö<%]á‹]ÃnºÄaØeHÆú v«ëµ]5“ÈÈà*vúı2ÇX	ÍHå…Âğ†FØ6§ÉÈ“NÃ‰ae _MGWã6ú’|tºW¦FßŒ0“‡'‹Çdª 0A§¥³ğõóB"8}¢
p‡“×ÊL|ÿ”
ƒ®ÁT-¦1°ÌKØ19á‹Dz§— ÿÙØTşÃ‹Šş)kÆ)=-S’Zò)zÆ æ€^ú&µ®œi uµ‰õP;C  Í2âÒöÁuØ%.µÿŞÇĞôL% =ª«¡°¶Õ”Ú*1÷Şxã²/1ƒ‘/¢!éHÒ^ÅWI‚CMâo„u0DÚ-`zç-]R{˜¡/V&£[Éñ†œj¾n#ÒâÁáìÒQÕFÔÿÑÆ£¥Â˜XÄï.Y’Ó®'V¡}F+—U[~š\× ÇV5[û	ĞkC ªÇ†bò†¢[%RFf×¨„…¥´úY
¼ß‰¨Ğä (ÛŒqaóYıA´qQÂ+K|·÷Ò,lGFpå@¡ú¦çvl“ÍAº<$x,DvŠ˜b)Ğ*)|«4Éõ¢TöCç°Ñ2²š¨P«¨”Sæ?Ôw\{¬.¶8ZÖ›Õ*
Y— ´î„½…
7CÍ‡	Ğf;â]€V"åRó!€…Ï9±{À•2B¯ e¤W¶)  EÃÿS–T’È|ˆë ·ºÎóH–'ĞÛbèĞ.9ÀIp£ªJÍ~"¥q&šV“¦KTò§Y‹èäBNÌ›=kpA…8–‹£["ƒ3WW
¿uÖç£®ƒŒÆ1¾º‹@e¦½ ºH[]yE„µ+Êi‰&2±•öx#ÀAè£MÊ@µœ¼byXh›–@V¢ğ¤bÇ—,àc¨kE@c‰]MõLKÃMk¾+/œµE¦ ÷Ï‡p#£„BÜiğ†Úõ½¸0€Êİõ ‘Nm£:ÚQéÃvC¥—ã’ñˆ;ÍÏ|	“ÿåº t”òÈÕªs0FäÈ~ $«Öø“Ò32êzN~v¾Ïêü5 Û¡V–fÄ[3Qëå7U‘'Š—q“0GR˜êœÕ …Í8ìQ×7r%&ƒ¢a= Nä€t¬ø0¯òtàX„äu‰:y€JVN©ÆıÈºÊéŠº
M=•µ¡3ï‚{ô’$ûÓ¥L	B«¼IE÷ÍQ£NMoœ=@ÖG'ÎG9äÀı€å¾L´Ê†/'ZÆiV}Æiuı§Ø®iäI-²4*¤a3Z®.š,Sn…şFi)ÅdSW¥k`{èC–¤ÁÙ¥&¾ùanÃN°›pÂ£á4gèÂWll’ ‡Åm6G"UğÕÂ|ÚÅ¾àSëÎº•¨ÚU¹±¾)…EÔ}Pf
‘‡ë„sK©ˆÜj×¢)‚Ñ¹#·¯„}qTv!§×˜FâEÒ\ûqñĞ`ãºÄ)»ˆnŸç¼˜tàşR¨1­Rì5jSšî ğø…ã‡N\%÷é· ÑAß½m™€Ëªª›½ÊóP"øS…YvºFB[Ü•©eoßŒ3ïúê Öpï!ıä•æ'£#xW9ĞìŠŒÊM
îÆG5D~†XF|)³ÃM¶ãÜ}€ŒË«ËÓ´ğÓ ‡mõp
ÉEmğ&XÄ‹BÆõ.$ w×‘ƒ‹DâŸ³/¾îª×lYxô¤Ê™ıaªïÁõ²fjHææÏ·ªt¡nl—l5­-n‰ŠofİNö(­(„Í"— 8n˜mDa-ª¨”îÅu'mÁ–ÁkØtm+¹c0hA÷"o˜ÛìD‹JiõÁ è6?Ç7&6³ÕA—¨.±˜´eiÊã“»ôQ‹…­è8Éï¡„ÿ±´=ÓÚy-¡‰öÊÍ·‡›qß-†~98¯d 3Œã^ã&6•"<Ë”ÜK‘Í"—5‚œÛ1HøTUæä<‡4‚÷y“ƒ7ƒu[W˜²Cèeé´nnÜ>ÑöËaàc¡À‹nv˜íMQyÈL›ÈK•ô€Ùìï!•ÌÁˆE ø_Ğ«`™9ºäš¶¸»+= ÙbŒÙ|	~j£ED½#É“ãHy)*âÉf°Jİ‘Äá¢‰+Ÿ3Ñ0®ãÚu<%K`ã‰Æ[šfÏ–ƒl%P`æÛÑ,üá'°k­Â£YtW= üº>˜PAØcVĞB«à¨¨ªz]§cE“hğ¬{á×:‰öUše«a3pBÂû¥·•‘E”Ë$X*øİIØéP~+ë0ö mª‡ş¸¤x„ûd­¢™FŞ iİUWEa|  XM{+E5²j$1W4 )ÈïcR-Í­û9¥vtøgQMZaÃõ>V¿rôúb‡ÛáÑØ‡@†·Íƒ|KKõz‹úµ´$,3ÎÛ2[¥›±Ê¡Ïw*0G¡ÏÉeÌ  |„	H"H,¡ A2ôÃ    ³»»»¹ººº»ºººº»»»»º °»  °   €‡ˆ‡ˆ°xŠy¦˜º  `ygˆhvgwv™‰
                                                  °                                    »     §» p‹  «†™‹p{º`v˜Š‹€›pf‡©€‹›‹kew¹«› »€fvˆ©› ™€V†‡™›˜
zhv§
ªª Š€—¨ ª 
                         G@	@IÊÃåˆÚo‰‡#wkUŞ˜MÑ©Å$²ñ¢HÔ4iBßx¿¼Ò,YúA$ 0|Œp ¦¥¬$Agÿ;ğœå*aªpäÆMåÀ&„|vİF¨û¬r8:¯&üè“<§Æë[#åä&bŠXÂ‘9-,‰qÅRÏÀÿ"	–XVº„É_Ú§LTİo.eaÃ5td‡Ğr^Éaîà]ÆX‘yh:Í; LÕ ÁYâQÁJš«fL€etùÙùP|@ÁÄ@tˆÃÇ)er€Ÿ¿ÕÒ:Zú`
dÅJf’pò©ŒŒKœ:(&G O¦úSqÙœKè0×³xqY¨YgšèàçªÑG46#Ì2£©B7~2f=Cí#pé¿Cå´Zd¥$Å$’’xHÑ‡Ê&Ò)´0­Ø–¸ÔO„?ìeáRŸd:Ñ-³•I°]Ï5Êµ)`Ğ­’c +éApÌcNÙJ,…ËÜ•7f¿qG>eRH±	ëUè†á„™Z¾)Æ#Aı³&y‰6ŒùNKrdøûzò Ê3ÆŠ ĞÊuñ»µ¦E-œŸ>Ó;¨™µ<(²Ã‰#·ş‘%‰ç,ó¢\ÔòÎzğ x66˜¦[ìj &Å¥U¾<ó 94ÎS—ÏEP ¥KõóÙî÷YIÖ®i—=XâV¦ºÓ(#9%cEåb †¢ ÁC0ôfƒU¬­£lHÖ1dU÷asªIZ“DÃˆ[š“$[:JU«/~¤¦˜~óiîj/c!µçk½1” ÇC”ƒêINÂó >åz¦3„&r"(œŠ¯ñLÉF‹uhHß¤¤ÕñW„óİ 
õÆI™’^¤ÑyØpTûfeHgŠõ•/Û rBæ&¸PùG~NÑ˜‹ßp °	vó!Ô \ğ¬º ƒL
)}P í4 æt¢‡ª¬X|Eˆuk{ÆI4åÆ
-¥Iº$òiéÀ©fÂ.FÚÜl>Ö£xÙ•±1²Â²àØ Zª’`!÷ç)cƒÈ¼Åk]£¸y¨1ÎG”nÄæÖ‘&9¨BÛ'†'ªœ,šL¸:Ö*}Æ(GĞ
¶ªp2G9
,N¹'§³äKš'œU GÏŠ¬b»¸ÌR2®()‚¸TdddeñÑòÎ©"!Ç‚îXÊ÷@Q|€®W7M‚Ù¤mŞ’#‘s@[‰1IS†!H®P-Pë‚³(ÃaÊ¯å%ì›^9ÛE¨ §ÄÃeğZ¨Ú’#Cc’hZi[ÃßŠÄeè´«ŞTòà2jÿC˜`$W,Ş®ˆnp‰cŞ§ô¨{¤ÑÊqÓBL¼şé¶ş	]ªÒÎ³‚Ïöx5s)9¯x†ó™õh—¡ÛÇ°¤ÚZ›œ¶m%)€;5ûoŞİC{äƒBœlë`àøÑf*;Hv‘fØ‘ø-	ºu‹=QÎ­âøu3ŠâÑ
u¹ÇŞ„d%1Ö¢oÊ´fK ÑÔÚ¨|Í©E}q-)¹6PÒä#Uë:t×æhkx(¡¡:‘CøÇRµò¯aH,ä€á+>šu|ªqÓ;·Ä%½EÈ‡šÚ×u˜X.´ã6ÚÎƒ¡ÌÍ$•thÉ1Wt =ÕG?ªQXå%ÁŞıÿÑA °•ëğGB³ˆ‘"‚ÔstÆ‘L¾»| R¦x2 ë,Cï#âvŒì+<±_d$ı´§'±eCŞ·Ê°ÅçTĞ'ø¿Í½ócƒäyçæ¸<y<ùà†±xåUà±˜4=GI§G$í³(Ÿ ¸ß!ÅÆ\(M»#k‹ THş íğEŠ¥A,q»‹*.fÈ‹HšFTé$Õ÷>	îNØ~r}0/ÕQ¶ü| ]=®¦ÙJ¤›Ô°s¿è‘›Zêö¾EÅg)˜EÄ§‡-Ø´×ã„(­ÎJÒØ8rAÔ'i!Ş‚J–ü ÔFÒb¼H²Å[äkPÕÅ ‰šµÈ9Z„ŠÑ«÷l'(0‡9ÿ1
uHB@ˆ×³¦9•c3ÆGÜdı—YUŸóêôl®ºV*\"wØóy]ÂvtZ)˜fİˆ™›<™; H6ĞS0à4‡’ÈO²hÁIwmTÚ#qïzÔÉ.ÀC+]Ä#ì×iÙ×ÌéÙ8+‡ñ0!*Ol”ºy‰o‹·‹‚ÉLvĞİ”˜ÁÄÀôM‹Mb£¤fœ´Nì6,ÔJ{= XÔšånÇ®zt»4Şt×w²²V’C=©H¼@/ÌL{ÃÏ§Y/µxX¿’GE?Úµd‹áär5rÆùN´ (W“â.d¹L3‚m#ŠT>B¾Úä6kT†Œúî.¸bªNA$æ¤x
7àÌûE\5j-Õô˜¢\¨é±&+ÅÅ2İÆp1Ô§Î>[I0%È™#a­oAzRh(\¾9Œ:z°ê	¶ÍêÂ¼<"QÍ…{›ÀœÒ!^Âº€‘ÒÍ3¤¹v:ì—œÂî˜£§Xt3ˆü¶ àF²qm·%$©ë¤ŞR¬‹Ÿqc´±H~åê†;À•ÆğK†Aè4«†ıÅª
'k³R÷†Fé­o©ıX>® ğª-¼|Ü¶FìdíËç†„a‹Ì¹p×+8š	ÔIŞ-…tÙÁ’®-R2Ñ`pmK×“ hœ*ySĞuºşÙNºY	R­	d!’4¹hƒ¦|Ü<ì9í†/ÀKÁi ì¹“°WÆ%”	~AKdën7ÆµX€ØqŒÈ%œ+=
C#.4 1\¨ACK•g_c­m0qf,ÃaÁéCúpp(3\>À)DKg¯ÿédv ™A íƒßNç:|Nt¡æš®
Â‘ëÂá
×£¼ñ	Œ‚hB61Å`š
äÍFğa¹ô*Ğ…nF‹Ç-šçQ)fğPÆd¨4‚XL 
£Â½Ô
‚1 Ì±ˆ tLÂ
Ì£½–¢JÄ…æ²Ã¢²P p_Ä‚Ñ|1hÇâ@’%˜…Ã
‹DÁƒ0PJF›ò‚†Xd šLƒH
¾»XP@ä±Ø LËá
Á'<~ã˜â	Å`š
 ÃŒÁ5Tr!.Õ Ò²*Ò ë_d`Æ‚¨X” §LÂ
Ø£xrÆ(€
0#Û,+¤Å0N
 ,f·ü*ş ÄmßEÜNUd©nÔ(Æ¼êbe¯:)Bÿ³È+Ö..ØÂA“WCÀoyÅcèì½B<AÁÜˆ€Eà\¨1–$)­Åè×†yªòÌf'F!ŠIñÏq0åÇ“’[®¦’ İ#œÇŸ_æ©­ì|ê0
E†ybi(<&o•ğ'¬E¤XÒ™NP©À\r@Â–²@pkò§?`T’ V›´•OÃ(*-&vŒEÒK‚”Œá¶ÃbáœËXú
‹NÇ‚nL1\MT9Âqb5âÃ³¤D

 †ÌÀ\F}ÔÇ˜@Á1
£Âˆq­0NâEoùH¯‘QË`¢Ñ
Œà±s÷ŠIæwÇB@|-˜Â
æ£Äá	Vƒ„ AI,&¾
E.ŠÚ¢((ŠŠ¢¦(›wuî™"HQd¼½‹ à  §š˜š¨ª©
¨ª©ª		
¨ª ª¨ ª ©Š—ª¨ ª©¨ªª ¨Š
 ˜	ª§šˆª¨‰˜™ˆ‰˜™™™‡©™ª¨ª¨ ¨ªª©ª©ª©š¨ 
ª¨™ª¨©˜
™™™
™
˜
	™
©š©	˜™¨š©©©™¨™š¨—©‰š™		 	        
      ™       … •     ˜
ˆ     Wª… ¥ 
PVu`– PP‡ª 	€`zŠpy‰ªª  
Š˜Š
  ™      	                              ™àe2Ò×ĞüS—ßÕQì{€ş„µeSà.õ¯¨ ®™ì»àëš kÙşô£²$Fğ‰„ĞA‚
xGXÑ2±˜ÁïØB–
	NX½z CûÀT …!p— ;ìØèœ:XÁ%ÑhÇ0ÕcD$
‘à[Ìà±ì}T6ƒ†v$Â'ğâ
QqÁ*£
/G	ùØù
$8Öhh‚dğD{ÀÕÍ¨B™
$8¢c¿ fW8°Ç®B_¾¶eZn¼ BP8rØPÕÌtŠñ~/‡JCÄôeşå—4×&™óÇ[	 ~Ú0‰ ÙêkØ‰|Ü(-ub$vö"˜‡@Zìyò`H!BzMÖ!¨¢VÓ(*Omª,"ÏlV X`ö»{Ã“bƒ‹j‹8Şj³2yJEVµb ­  €TÃô0}JŒ\‰U±CB.õDc†ŒUØÁÒ¥•‚%›Æf}ı, ‹Pˆ˜	F>‚…çØn–0;"NXˆ!P’\ÌúíÖ([Ãeßz¸Îd¸ÇQv3bÜÁ¥!Xa"áx-  B“±
D‚tTõLœ	Ò9>¹8@„œÔ
¶ÛÕ#îÖ- „ØùBå±)Ùğú\C‚Uğ,/J:-v!™
$8RsÁ
x:(ÀD;‡œø
8É€`İìB8 ĞN\ÜÅ›"×iJƒ´‚‡xaN%ğÅ!D
F‚åZ°x@íˆ»˜<v„ğˆA^
ÍM!Xc o^ØQDp2
¿Hİ`‚NğŒe@ÆN!d5'
İ‹XÕãp @8hĞÆ"œ›Oğ¯ì²¬‚gxQ4,|,!'3
‹ß=ßût/]O¾e7ˆf7Êáiµ X¢üâæå|ëØ™zŒk¼öZšÕÈçüòG£¾ù@'‚³¶'pbb„¦“CP¢eÌíÚ9-|¸à·~o0£…
£Z­g‡Ñ“eµ™å ßfĞµä¾Ö’®ï ï–#šò§6$‘‰ ¼‡ÅªØoeÜT;ˆ1ˆ]ÑŞ VAÔ!"b×†ø‰îM½(Å*ìôMBŒaiÄf(W-Xµvlî@jŒœ]µˆUE!`ì¢¡O‹<zÜe	ª€OèŠ§Ù$IÙô‰’â2èVrš—‘¹Á,%@LĞ€Ù~a9¡³:#²²6ÖH\ÑËÜY—2ò¬d›Ä1ñdîYš1R>êå¦:‡#è ’ª+† bÈ 2‹¬/cCg…B‚”LiªĞÄ˜•xiøâ7Ìi¥qYdØPxÂ°˜~Šínµ‰ÓøªxÁ£¢dğÆN!X?•
Å¶XùÏ%(L„ù¢ØD-
UùÙ€)bdè\:®ó`Èø,«rO#–µä8€ãü,åƒ‘c^Eá–äÒ<:J²œ–é¸ÍlŒ
aäÎïl† 8^ #zæ#@J»HÈ™`ò{ªHò0]hfÕˆ`MÂc¢H©û¿øŸAh‚’DVÙ'ùÄf,­JbˆŞúÊ•åÃ§Ê7$šğ„k4êù
Ş¸•88oxÔŞü¡ŸQ²`bXE9£À¨Bç -ü/œÇ!ƒÆ`¤DÊ8Sç·Ó;ÒÁúN./3C0æÆtcËÉy©—ƒ3„¦L#MN—ö™Xm~,` È²ÉU€6r9/çÿŞ ±£lNsğcç£iêÔbµèÇC’Rè0HÀmGKÄÙí°8…	¤è`˜`Œ`Éy ¹Œ³ĞFk)(#J8P³= ©JOÓpx‘ô9˜šaH…sN¤êšãìnÀGOÊ#ÀOHÔ°„ÃÁzÀr¾‘‡&<%‘rù1¥øzğ™áğ0:a˜tx¡4l€·„'(­`€ÂJÉ
î<Õ–=Oä¨dF:#4q	 ¦á¯íÀš }O	p.Ffİìø1¦4¥˜O¼#)V¿ù„gdJÕ!•A}ß)@àğX‡¦dB”P»&ƒĞ)w,bN?yb ¶=+³1 ×™4ÒAK”–##“$…ƒ s C‚%6B++gÃ 9nÒ!?ŞEô‰Œ	`RÆÎl<IH²lH\ğ—„`Ì´‰Œ	,)ÚAFP¬¹ÑÄ	a7ã¸J‡Ê9vµ$2)$çI	9‹VjGÓ—ÑÁ&!L‹È˜™“"v<ß+\!IÔT7±Æ#„¸‚ç(Z2ŒB	‰RE!‰!±Ê$üÎÀl	9ƒZFc„D)Ÿç2Fc$6İ#ØåæC¬Šşxn À,Ú2c Ó¡jI;bãJB•ÙÀ9äç	•A¨êi‰š	2)c'F,ö>Âã3eoØ•z–Ø/ĞÀµ¤#·Ã H:cÒ¡ ²¾§›¹’ùœªÄ}‚á!N€I!&ŠYmd2jÊ›‰	^&“zXm& u  Su˜‰ˆ™¨™™š™š™š¨©˜™™©©š¨ª©ª‰©™©‰š©‰˜©™©˜©©ª™šš™™™¨©™š˜©˜™˜©˜‰˜™˜š™™˜˜¨˜˜©ª˜™™™™˜™š¹™˜™˜™ª©©™©˜™™™™©™É˜š™™™™¹™©š™š™›Éª™š™š˜™™™˜™™™              txÌ  °…»©°™° – ¼  š†¼¹ ©Ê€v«© » ‡°« ÌÌ –¬« ÀÀ°–¼À À   Æ      ¼—                                       0½9@¢I9³®29æ$ëØ_ xõ‡ß™T«9@¯¦ Õéù‚Ô·ğOÆÆç±Q,IQ^
[¿ÔŒìx¤Äf'€ ƒ38õ^˜:¤xøª‰ÓXâíùó¶|Aş¶ªÀ:sH€AÿJÿhÚ?Nb%×–XQ|>,® Ø¨ÿBŠÍ@
U$`~dIê33leÿuÈtùøØúıÿYg‚Iç'´(íÚÿàMqGgE’?KËARR$’¼.ë‘È|1’²%ƒHŠú:uã#»…Fş†$£3ü92éÿÁ¡ë0>¡Æ’cÖ(±ï^¢öA´ØüPê!`Fù"±ùÜşò¨ÙE:CH&¦>t™íƒø4“„sO4÷tÃ¡àşÜ;”®Î”8}­ÄÿnS¤GPyºqz$$‘·tö ud!;I“è"ûNN ¨"OzJêd=Xt~ ¼ƒ®ı.u YäĞ1fJSFG£™ºhÙ)tèÀ˜QiL~£ÎÂ«D*²’dİÉ3 Õ1¨J)’@ã‰„t§æ¦×#GHƒÎ‘¸<ˆ‰I$ézû øàş^T±Éı?[IAEq¸¢ÕMuÔôÄ‰àRÓ«ÉSŞ#_M’@KÕ [»¾pŸÌ–ç ×F†æä÷7ÈÿÀ&Ëë.Ià¤ 6¥äçşI9Â:áÏPDºÈÏ/îdb¾şîc<X#¨¤’+ĞâÀâ±a¬àg;`áù7„oh(Æ–HÙx„½ŒS¦'NÁØúæa0‡pôùvƒÃ÷u-Œ/8,Í©²ƒM‚†ïìàØ\ŒĞ°Ø;1	“ôN¯Â0»ïÆ&Œ<ì
†i„g:aãxY†Ù4ö4ãG&M`ÌğfF#3ĞvÍ¤ÂÌGNÛŸz˜C¤[‘»")C€äµöøÁ>—9X¨Š@1 •øÔP“b¤0”VÆ rDËç_´ˆus, "Error::New", "napi_create_string_utf8");

    switch (last_error_info_copy.error_code) {
      case napi_object_expected:
      case napi_string_expected:
      case napi_boolean_expected:
      case napi_number_expected:
        status = napi_create_type_error(env, nullptr, message, &error);
        break;
      default:
        status = napi_create_error(env, nullptr, message, &error);
        break;
    }
    NAPI_FATAL_IF_FAILED(status, "Error::New", "napi_create_error");
  }

  return Error(env, error);
}

inline Error Error::New(napi_env env, const char* message) {
  return Error::New<Error>(
      env, message, std::strlen(message), napi_create_error);
}

inline Error Error::New(napi_env env, const std::string& message) {
  return Error::New<Error>(
      env, message.c_str(), message.size(), napi_create_error);
}

inline NAPI_NO_RETURN void Error::Fatal(const char* location,
                                        const char* message) {
  napi_fatal_error(location, NAPI_AUTO_LENGTH, message, NAPI_AUTO_LENGTH);
}

inline Error::Error() : ObjectReference() {}

inline Error::Error(napi_env env, napi_value value)
    : ObjectReference(env, nullptr) {
  if (value != nullptr) {
    // Attempting to create a reference on the error object.
    // If it's not a Object/Function/Symbol, this call will return an error
    // status.
    napi_status status = napi_create_reference(env, value, 1, &_ref);

    if (status != napi_ok) {
      napi_value wrappedErrorObj;

      // Create an error object
      status = napi_create_object(env, &wrappedErrorObj);
      NAPI_FATAL_IF_FAILED(status, "Error::Error", "napi_create_object");

      // property flag that we attach to show the error object is wrapped
      napi_property_descriptor wrapObjFlag = {
          ERROR_WRAP_VALUE(),  // Unique GUID identifier since Symbol isn't a
                               // viable option
          nullptr,
          nullptr,
          nullptr,
          nullptr,
          Value::From(env, value),
          napi_enumerable,
          nullptr};

      status = napi_define_properties(env, wrappedErrorObj, 1, &wrapObjFlag);
      NAPI_FATAL_IF_FAILED(status, "Error::Error", "napi_define_properties");

      // Create a reference on the newly wrapped object
      status = napi_create_reference(env, wrappedErrorObj, 1, &_ref);
    }

    // Avoid infinite recursion in the failure case.
    NAPI_FATAL_IF_FAILED(status, "Error::Error", "napi_create_reference");
  }
}

inline Object Error::Value() const {
  if (_ref == nullptr) {
    return Object(_env, nullptr);
  }

  napi_value refValue;
  napi_status status = napi_get_reference_value(_env, _ref, &refValue);
  NAPI_THROW_IF_FAILED(_env, status, Object());

  napi_valuetype type;
  status = napi_typeof(_env, refValue, &type);
  NAPI_THROW_IF_FAILED(_env, status, Object());

  // If refValue isn't a symbol, then we proceed to whether the refValue has the
  // wrapped error flag
  if (type != napi_symbol) {
    // We are checking if the object is wrapped
    bool isWrappedObject = false;

    status = napi_has_property(_env,
                               refValue,
                               String::From(_env, ERROR_WRAP_VALUE()),
                               &isWrappedObject);

    // Don't care about status
    if (isWrappedObject) {
      napi_value unwrappedValue;
      status = napi_get_property(_env,
                                 refValue,
                                 String::From(_env, ERROR_WRAP_VALUE()),
                                 &unwrappedValue);
      NAPI_THROW_IF_FAILED(_env, status, Object());

      return Object(_env, unwrappedValue);
    }
  }

  return Object(_env, refValue);
}

inline Error::Error(Error&& other) : ObjectReference(std::move(other)) {}

inline Error& Error::operator=(Error&& other) {
  static_cast<Reference<Object>*>(this)->operator=(std::move(other));
  return *this;
}

inline Error::Error(const Error& other) : ObjectReference(other) {}

inline Error& Error::operator=(const Error& other) {
  Reset();

  _env = other.Env();
  HandleScope scope(_env);

  napi_value value = other.Value();
  if (value != nullptr) {
    napi_status status = napi_create_reference(_env, value, 1, &_ref);
    NAPI_THROW_IF_FAILED(_env, status, *this);
  }

  return *this;
}

inline const std::string& Error::Message() const NAPI_NOEXCEPT {
  if (_message.size() == 0 && _env != nullptr) {
#ifdef NAPI_CPP_EXCEPTIONS
    try {
      _message = Get("message").As<String>();
    } catch (...) {
      // Catch all errors here, to include e.g. a std::bad_alloc from
      // the std::string::operator=, because this method may not throw.
    }
#else  // NAPI_CPP_EXCEPTIONS
#if defined(NODE_ADDON_API_ENABLE_MAYBE)
    Napi::Value message_val;
    if (Get("message").UnwrapTo(&message_val)) {
      _message = message_val.As<String>();
    }
#else
    _message = Get("message").As<String>();
#endif
#endif  // NAPI_CPP_EXCEPTIONS
  }
  return _message;
}

// we created an object on the &_ref
inline void Error::ThrowAsJavaScriptException() const {
  HandleScope scope(_env);
  if (!IsEmpty()) {
#ifdef NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS
    bool pendingException = false;

    // check if there is already a pending exception. If so don't try to throw a
    // new one as that is not allowed/possible
    napi_status status = napi_is_exception_pending(_env, &pendingException);

    if ((status != napi_ok) ||
        ((status == napi_ok) && (pendingException == false))) {
      // We intentionally don't use `NAPI_THROW_*` macros here to ensure
      // that there is no possible recursion as `ThrowAsJavaScriptException`
      // is part of `NAPI_THROW_*` macro definition for noexcept.

      status = napi_throw(_env, Value());

      if (status == napi_pending_exception) {
        // The environment must be terminating as we checked earlier and there
        // was no pending exception. In this case continuing will result
        // in a fatal error and there is nothing the author has done incorrectly
        // in their code that is worth flagging through a fatal error
        return;
      }
    } else {
      status = napi_pending_exception;
    }
#else
    // We intentionally don't use `NAPI_THROW_*` macros here to ensure
    // that there is no possible recursion as `ThrowAsJavaScriptException`
    // is part of `NAPI_THROW_*` macro definition for noexcept.

    napi_status status = napi_throw(_env, Value());
#endif

#ifdef NAPI_CPP_EXCEPTIONS
    if (status != napi_ok) {
      throw Error::New(_env);
    }
#else   // NAPI_CPP_EXCEPTIONS
    NAPI_FATAL_IF_FAILED(
        status, "Error::ThrowAsJavaScriptException", "napi_throw");
#endif  // NAPI_CPP_EXCEPTIONS
  }
}

#ifdef NAPI_CPP_EXCEPTIONS

inline const char* Error::what() const NAPI_NOEXCEPT {
  return Message().c_str();
}

#endif  // NAPI_CPP_EXCEPTIONS

inline const char* Error::ERROR_WRAP_VALUE() NAPI_NOEXCEPT {
  return "4bda9e7e-4913-4dbc-95de-891cbf66598e-errorVal";
}

template <typename TError>
inline TError Error::New(napi_env env,
                         const char* message,
                         size_t length,
                         create_error_fn create_error) {
  napi_value str;
  napi_status status = napi_create_string_utf8(env, message, length, &str);
  NAPI_THROW_IF_FAILED(env, status, TError());

  napi_value error;
  status = create_error(env, nullptr, str, &error);
  NAPI_THROW_IF_FAILED(env, status, TError());

  return TError(env, error);
}

inline TypeError TypeError::New(napi_env env, const char* message) {
  return Error::New<TypeError>(
      env, message, std::strlen(message), napi_create_type_error);
}

inline TypeError TypeError::New(napi_env env, const std::string& message) {
  return Error::New<TypeError>(
      env, message.c_str(), message.size(), napi_create_type_error);
}

inline TypeError::TypeError() : Error() {}

inline TypeError::TypeError(napi_env env, napi_value value)
    : Error(env, value) {}

inline RangeError RangeError::New(napi_env env, const char* message) {
  return Error::New<RangeError>(
      env, message, std::strlen(message), napi_create_range_error);
}

inline RangeError RangeError::N+áì–â ZZâXÌ´Z]¸÷¥úÂ²qGÎûî9íLÀ‘ñ^ÔĞ^5(>/| u¢céióÎz$>£?sŒ9æ:ã)	¢ş(¢«÷|å¼bàm;ä‹”y íÔy©;åëFT|ÃÃ¦PjÂŒyé
=ÚŒö¯(ğûÚc¦€‡ õK¨Óº
ôÅí[°e¬–Ô]™éü#…Õ£iô%LlŞWPq²"ï…ç‡¾¨Íd6ecCÄÁÒYxÓ$Î[rÛ¿:WXrê™"‰3Ê•W»ÆvÕKvwŸ€æ×µ@Á{¯õıfÙ{/æ%“í$,a™4ÉÿÊ½Wpô™}[«',[qµŞ»íŸ×zù¨©779â¥ã|P9ÖÆW÷¦z“Ü‘+}äíuşúıF!u>“ öNÁ5™Bb<Ù.Nz¶"céi#Mö7Ûãt›ûS*¿‘Àr1¢j6D…|zKd‘Ö İÿ×ê~ü£1«vH_Š¯<uªí€_êB‰IÒÙ6YÿêU[CMå•w5ì5ÛqñZåQ35!K° ‹T	™.;Ú)&¨[m¦%ô æÔŠXÊ'–8ó¢oµöfs¾Ûí²#¿xµÑñnóøóôUwºŠóEvÙ¹òvHĞ»ğ}¬.ÿM_Ì<°»À¿ñ3ÌÅTñÓ®Zg·Ë¾_ê gJ×½»H„L„Èr:2ÊøY“šMó>M\…íJí†tÑ0«kY/RW,­„„qYD	j›7Ba»³å;…,J§ø-¹Ããâ³‹2õ8.”XiÒÄÈôÑ¥Úº(åèˆ2JpÀK´´³N¡—ş¼Ï›p÷@PM-Õ½kV|Ù/TûÏã÷\¤‰ƒ
ÿùB«ŒzÆëNúôÉe¨òÛ§bª¯Û¸(H”%ÑÈAß3 )‰x‚è®—×'YàPk7@+¦-6ùY€Q+9ÆUæe$†(Ê–?¯²©ÇQå*ŒZä6 ×0Oõ(˜¨æ 9§>^~Íd~‚Á€Ïë ıó×»÷fzÛ‚aÀX3~rËşÛ«“v¶Òr®ØãœÆZåüó9-½Ê&N'§(j¸ìªùƒíeê	É=ê*\J£ˆã2¶;Mád™æJ!c„¬®­¹€¨n¢™*à+%¨Zü,6„¹‚7®·T™Zê€}ş Ë)üùzP9ãœ‚â¹ÛÒ31.?üñ+Wİy~gë*˜dR.güÂFRÌ¼Ö/—¢¸Â~júÃ¸5"-ê%/¯Ód²mŞ»Ìÿ¥Ù.\,­q¥´kåFECY£Ó¢\
Ø‹ƒj[M¤Œ}~¸<™Â,v2µ¬ˆ%õø¿jµe±²„²ù»É.ß##½É¼³}äÄEXî+
4é2'¸³Û2İâ»lï°ŒéZ-Â=oîÃáƒéoÈñà®Í]ÚÙ‹¨åÕ{>­]Ğ._ó¤'›öSø$|çq”¿N@wLbA£ˆdlè(2Å¿·xZ8ÄãĞÒŠÄ¥5¹Dæœo_ÜÙ€³œÀş×úOº^ù=|ƒûÒ‘ï5cmÛÙÎiŒU™ÊØQ0-yñœÚ˜¼6iã5è‡ØÈMÍqúÓã§r|4Í©cPsÊ¹„ÖÎØÅT(S±`ÏiD3åĞ¯”‰5k¢UÕt%ØŸ¤aZG¿ô¹¿H)ğ«<rM§ûcK®is›ˆs*öv-¡˜ÒOĞ¢œüŸ„áŸåæ[M§ ~ÖÂp/ù˜Nm¨á²‹-•]Ó”û/Pmª gÙšì±wÿÀıeJ³—Iæ(>"+” ’/¶îÃUF›óÔF6P-Ç!Ğ3Øgp±‘;{¤2!ç’ş|Ì²›ßkÊ+šØOÁ-ú*a©ÉƒÂ·J-Ğa+iÄ÷u–ÕPİb6³n>S±èŸ‡¨y¨Fªö}¥VB%)™bPŠ}Ñ×c±ª¬!:YÁÀÄ*=Õ&ç*Äğ'M*ÆD,EŒ‹ä	˜cršŸËe4Æ”ı„Zl±ÛL‰"×öÙ*Ä±"•Æ¡ÂÔú2ğÄcì¯MØ™»Xá9W Ÿ'Nf ş Fkäı°r„g÷yOœªš?¼Ñïæñu‡‚äyå•ùB‹Ínô/ 6JbóğÂ-xì
æáÃ+n©G,
<xM&xláçz
Ëa'¡…_f/`¶é;¯–‘“.n'
5~x¸­µP
R¡
73ÃşÓ:	"4æÎä«­÷úÅ…

Xığp“œ°
ópá•íîDÅÓf
¤O¥VÃv^,¯ãØÌï	iÚjô„ÔŠYâ
–åÿv¼ËÉşËJJqò¿›æyüÈy¡õ—6xaá…[l|
b¼Å=»¸¬
ï9ì„ r]óÀÈ¾Ùg`Û³L@ªVMŞÈñÖ˜úAk}Ä5¡34%)D„Œm.v? ËÒ#_©g‹Üµ14’\s.Gbj4|'î.üÿÏ.º+÷UyñçÈ"æ®¸f7_™üáÏ\D‚ïÿŒ[*[9ÿ{œû_¨`£¯µàÅ›½o-ü9ğ`øFDMÄ\t.fŞo]&-ˆõZrM)ŸöŸŸKÃˆéÏ(g¬ÚM^ÂVİy-†n-„aŒ"%,!´Xá‘7œ»ç¥·*vA÷H÷)ƒoV|õ‰À‰[„·uŞİÿbü`˜¹bWƒte~]¾úÓv‡P|Ä.©éîQµ`·ŠÄíE4ôi 28ï¥L¥›T»åüuŸGh‘üaÛb2.ø×fæS¦JJ¦ÁÉnğ¢y^¾ÛK)I•fz:‰‘…ã¢É)÷¹G8Ooø# ïƒ¹$AÏ“'ç¯jR™œæ‰êáHSÚD´§õÉâoâêÏ;“©©L;>cTÓjg©~#‰ıJg“ƒí%­‰öÚùdòr®…Ø=ì]t…œ(›(qª`»?‰Y5ÙŠa÷¾¥_ĞWG„¼ {2ÎŸŞ‚·^ûvu7
Hl”{SïêáÁo€aúC%‚"ìê–/-UV¼¡ïêÛøÅä¿úªhŸ}»evÑ¦ù^<ü½è\v…1¶¬·ÑI:É¹°ÌF‹F^àü,‹¶ÜPº Ã‚FBåŒ$B0"[ı<X%I!C8 ‰2a ı  †ˆ™š–™˜z–ª™ª·›ª™—ª–ª§Šªª§Šªª—z©ªv‰‡™d›vš¨›™‰¸œ©™˜ºÊ©ª©š¸º‡œ¨š™š˜zxÊgXjº©»š«ÊºªªÊÌ Êª»ºº©«°°˜É¬š‡y©ˆ©™Èª©ªªª™šªª©«»¬…€ª¬˜Šª¨™©ªi°             ¨Ì      xŠ     ‡©¹     v‰šªÀÀ ‡™« º¬w˜ªÊ¬v˜º¼ À Àvˆ™«
Ê  v¨©¼   w©ªÌ°  À€¹Ê«                          -	P÷# Ö»˜gÒñC¡Ûß'äQWr%ÀHáYwÒF£n›t“4®M¤:îÏ’7û p$$°€°å…«|ìÚ±Kzö£1üI`Æ¨Aº–ø-¡7;`¡Û¢`Æ>—k«¬Qh¾?‚
´ïÛ½µîoŞTBfŸ—–7‚®õRqı‡®èKòAn)âá/ğ”å¶l-¼¾K®8ÎD¾x °/ÀMœÛ6&_xFk ŠÙİË@›¼€ğ—I”K]7”û“áØÓ-•L8 ô5ß›»œ%-=ã»à,=úÂû&¼°ÿ–OD”Æ"& ™Å-°êF†ç¼×ÿğå¬èçAîß–Í¢9¿Ğ¨œÎšeËYŞfÂñi5¡¢I62Ğ,Ğ©ı¦×j Å2{o+¦’[BÎsù-s—QYÍşåÛl!øT¸íZæuŒV¶¦Nâš^ÔÒ94UÒ 
,é¨ÑŞHE|Ò‹Æ¸Á1H^m«DEíÍ9b¢·p…š‚Ó%k€EGB	†Ñ!öT@Ût]>i¹Ğ…cv¯iÖ„}¸dŸ:š‰‚?ˆ`&`|ÏÏµ zÃiTÁ0aì²lğ–ğ¬i{;oÑås åhYÎ„d•¤»VÂã\d¥)üfQ?Î)´¨Z•Ğœ>JÛ¼øqÒ«l’ª‡’“Z9`ßKDªoCúõéäl0_ÃVå¥w–ÄM‘o£ç’&ŸD«ZËJäë’˜ÍÎ—XÀì?N(ñãZë’9+?d
o|£r]°ñ€`U±Ú5ó!æº†>“)âˆÎ°Èı² âu¤;²W&f]¢±“é‚*Æ}4JÍ0Ù@'Jñ›–âÑ)ÓWCÀñH…w«å, Û¢LÕ|Zş€À[›Ñ)“0n…ù8çEJ=Á°CMZhà=l2.¥üsSpü“pÙ9NrÁa}³áÎ¦¹r!—ÀQ+˜];^Ó Ê‡ä­„=A~§	x İaäîq	ÀdÍ$z€€Ä×Lñ[õ> Hú4³ùçìÏä³¹İ€¹Z¨g9Ñ±Éfï9~$İ8û¹çîÁ~ e3²ùÚ3\âµÅºMÚÌÑ	òÇUee#]SA#'’±YPCÄ3,‘CÀğjüBĞs]<G¨<¬¨5‹Ösµ1SâÌH1RŸäfTì”^İ•«,q*)%a¤L6£¯ó×äÕöïf 4’Bâ™¶—1Ÿ€¨ÂË„–zËÅHBeg2^±ÊØ…ó>}—¾ˆ¨•”2©ÃĞÎÆ¼)Ô@œaNÛƒ‘³Uåg±l@H©ú-GKï%7Q¾Åî$eFÃ!_ß£µ€cMšŠ'!i	¥\Íº4u¸¯³ÕÚ·ÏFjµ~Ø¶xdâ$0Úw¸Â·w]„÷ˆ0ïY16‘­7Cì¹^Âä¬æJ N—;ˆ°FÚo‚ÄRrr‘Y>Ç‡>Ù»]©µÛGkC3!èjÄeR–üš /éÉÑJ€úLr'4¯Òïo!"âÄrvbŒ^î}Ä²²xÖ+zºôØ¤ÎÙ¤‡ÃN´ÎnÏÎ^fFX`Ì›pÚ¥¯~iQ Q¸-§l¼€r†‚b¤ş$J}Œ.r™Ê+£±VûQ5µ§HÍóø µÒ|<à—	¨öİ›xFH¿ã9&+É*‡9†ro $šã{ÉHËŒ14«©iÉE¤zwÉİ^ó)—Ğ4^Úw±çpIKéXÒ+zör¾æ:\¦Z,öûW,aüì÷WbRš4Ç£?*ô-‡–ÃèĞáÔŞ&Ìÿ!€Ô¥¾h4Øvíœ¼Ãƒiu¸ oƒ¶8ë0à'1Ë» àb@8P\_¹*O4ÈÀ¬çÚ2A¤1~–t8Z„ƒêbU@Acnê»ŠC´»$M²¡äÜ«Ÿw3aíÉŞèµKÖd²ˆ:²}ß}È«úÍ(ÓJ¡yM®¹ë>Õ3¶â„èuÉ~Æ›«·ß¨$/¹*JÁÆek'À^ŸÜ gÃK»u£^ÍDïÓzÊĞYÁáª­åò8Q¡ƒÚN‚[,íXÅ"NV¶v•0Ã’µQ}piG˜pöÚsú8·÷ôïz-ÔQVÇ7ğ³œ’Yº	 K(ŒhÂ\íÅ–ã¥dàs†k¨>2éo¤í(,…Š'™^bM.}œgß@`“‡¬²Øšïz52š$<³~P‡åq†àúW+4Í{ãExÊÊ$©`·m¦Âó}ş¢È÷e:§šcèÓè|oãy2+¬¹1»óÓq°Û *ßmSU½ÌNk¹?¶oÖMÄ¶é¡×£Z‰ı	p€˜ ¦R{8•IQ4¥íÿ[”ÈŒÚ"ßö8Ê:ùô-Ó±Ğ{İ
FØØØÜˆŞdÕnIEn^J_7ƒ:OŠ¦¼:C½ôò¡¾ItÔ;§/­{"\Ç±šXósO1ç[ ¢„† µTq‘2—-BÅTu!î¥§” Û/×!%ZwôÑçà\Í='‡ƒNÄv2k1zŠÜ‡¨¸‹WÜ£¸«çÛ˜œ.İ]I:';/Rl Ù3¥3´J–ÛÛbê©³§Áğ«´šîô€)>¨­@*±§#E‘'Ìä˜YíñÉÏ¯˜–'ìêà‡jò¯ñ'¯Ÿ/ÆÔ¼–Rşh²N®FScFn¿~™0)¼Ä¸.+]åìÂõçuFéÙN²y97«p]›ø[êÌaäGš}Úû¯—(ÀßkSÃÃ93—¨…0GÑfßš_hbáß©¯\$$c[¯e¦Kù„üĞ^çN^=¨4*aªÊP‰¼?/ş[ñMhNœ¨M´æàf ÚĞËİ%b)Yh‰†«×q¬ î2Sh2ë¯àÑJo2oƒÁ~eŞVTyJ)
ç½SÛéqÍ©îµ%)¡µId}ôú½	Û>Û=Fd¯m²L`_Øª¼dœ°yÉÎ:aÃ“Uß4Y'YIØ9ÙDîy9Ü4¯6“N&Œ¸I^Èºäµ^ãGÚ&2ÿë„Åüy´,ë%ÿ^À°ˆ)óùêjóví]wÀ2hûH&Ãw!˜ê.¡x—ËPF´ãšc\nÜAC¬ÍìI[²4+çN”¯…cF¼™]¥<Ëª®XîÈlÍ™¦CË•° ÃeMÏ”[pB½Š«rêÃŠ?×È”yïâ„‡æuûÆhj?[cíúŒÙfÑ)S,°ƒºäÒİ·¯‚NÈ¦[­}&Ì—~†„bVÊ§ZÔ´+…:…OMqZ‘óg§VR­Äf3¾VÙI±•Ûl•ÙlïÇì³ÄƒMöz;ËJrdÕnø2×¿‘h[y{şÆ³àéU] İ[ :LËù"QÖûÎìvòË÷!‘")â15„–ò	&ëäQV¿„@w÷ã®“®/áé&A\SÂ+Üq&¸äÏU=fŠ´6l8üK²WDãz²3š³ÔÁ/±°sÇ<„ïU~dwñÑëû’RnïôÑ|ÑvÈ†N¯! ]Ñq$BÇ |E3ÆjWl÷AV®‹ÈLùÖ3gN^äMÁ:îßöÆ&*çÎc:Ëò­
nä÷¸ÿü~›ı†İ`³Šı£"'T]RGõ'4ØşJHmQÈ”Í¬Y¨Æ›/¹—÷üsyäç.‡+‚ÿˆ‡ôÂPFƒ¥'>HÙz yy2½yS¥Ú³|y7ìÆ[E\ú .OÜ÷ĞÂ±=¥kèˆÜIşÜ=’ÚQd¸>çQIÇÔ8ÿ š8¤£…Uúí@ÓcÜ‹ÀP¿Ö~À(¿ãÅŒÃjp	`I…–7BŒõkEíç+’ƒ»ñ.ä¶r…J«~õä¡­›¨ì²ş&
èŒ-‡sIñbWq˜ˆŸ>W<¿ªƒiÚ[æ€˜(°°e4@¥£µv>°…àïƒxVÂ,$<AÒ—îÀ>É‰€Â@ö¤|îDÿ¤>3¤A-omf¥Ö„zı£&}C¾\©›@4PFê‚ä„JTÖ—<³©±¢AÉuHò' ³8
ÑçÕYBY8üÙ¤•I(5öû[Şìwÿ1ë_5ÔïêY¶éôäi¶^E è¿YãƒŠ®m”òËÛb£eã:#Õx÷ıÈ¶“€Ò–"”F]ñÉ’½~*Uƒç[Q u|Œ 
ÕüíÃ³˜á×2ˆZñ½Ctâô×Ô‹}½ÓCiĞ‘¨Şpâc$şå0Í2,Eã×ó.šÿ3íĞÅ÷_m[ùƒÆÜ6ZO2zñ&Ü6§¸6•~Â>U,–±ñ›TÜÖ3u¹'†Á…NxÍ=ÚÕT«øà1†Œ GC%©ÏãÖGGhV}µUµÖu¥áOËwÂÿbqò£äµS€çÅÂ˜˜ı7ær4Ze†·_kNM~@i!-ë“!ßHÒ&j,e´¹,°OJ­Â}š%Ô óVv9 ¿ù=â)Èà491Ğ2Î=*¶ÙŠ_Éh¸ çô[ûèJz{¨”ßï™^ûÿÏHü¥isp‹ğŒå¬ÁU_OAgŠ–ÂEFK´h‹&Jñ’*&î¥ğV•~Éö^±2v¶èG~œG|öÌo‘o~ó@8ÄFzqˆ4»D¯Êöî)B‰^ı%£Š€í˜°…ã<ú ¨¢×îğ¶su¥Ìö=yºŸ”ÕØÁSÂß¬ï›ÎÓ¶5Ìôi•«¤Şoñ¨ÕJ*ùpå.àûáèÉï¹*¤(•UâF‚Î0Û¤ÓGµ®>% Tø£%òÕ5Ñ ÄQÈÇæ¥bö~R-ÕF±-·±Rpù=V¥ò?ñ7ìN‹ïŸ°Ï÷ÔıägÙÈš0F‹&t3]11Ä‹B˜`<&=âãã§hN=•Z÷ htE•‡%¡ªMÒ 2@æîŞâì®>(ß¯¸¿{²”qz8Rñã®…ÈË­Ë©…¢¿€¸8O…ö¨,‘¤Ÿ7P¡RL…s¨Í›6 C#oMZÅ°€²Ä•Çâ7¤ 	¢î¢âÑ|í§èŒÄ¯K‘ZãfnÒ¼© voCGßÆ¼†U—&± ¨bÎ~«[¯Wº¦bÿ‰3P!ÃÍBûfYn:Î?S‰€ó ’T7$Àu	°¼KÑ­Î4h’¨¸Ü¶Î:³	,ÒT- ¬6€¿%Œá7–€ø×r¡ ‹ I ß¨ÊĞ÷?¾£ößãnZëÕ~
HNé,k! wù>MO,ò´§ÁÎm—¶7Jj/DSg7“mòšäÔ¶qO¢—ÏÂÎo 3›áóSœ_µù™Ô›Eş²Öûı[ÛÎVİ]îR±&¦ÖY Ü\
U/N]ß¼K†pŠå-"²JâB¹î¦ßP½ƒï]E$ÖëoğPFÔ2ÑM° °å´´[Ä×æÖ{(`L â$ÂÉ³ËûÂo³·Öş†4jˆ•ãå[C hšûïÛ|)¤–'¡HÊ‚Ş–Ø€¤€!(ú7>h%Ôy±?z¶éí…¬ˆ-3emT5á¸v®Sµ¶¾=.¦Ñ“ek·¢NÍÖ$1¨€TÎ–±„RÑ¼ìq"Œ¸#NÎg• ÑXìšPy½>˜	4(ö!n4şB"š4¾ÓjÃaO (´	\L|3`Ôj›²Bâ¤	gá8P3œx×›Ú¬òŸ¯AWõÈ™Ùìõæ3ş/3»D…ÎpW!ı— “ –bÕ²mÌwiï	h(B'*…øVöğİl€ƒ~€şo2OÚÖ„¢¾ğµ?5G…ï«¦ÚFy>‹?Aè@CfÁ)Õ5¾gG³AV»„R^•ÿ0ô0ƒvå_#TÍ?	—Ìı.¾C­9ã—ÔjK2~™0:¾*èÚcœql#l(N»z™œ—#NäŞ÷
x6rVôLQ{û…eë]ºYz?Yqº¢ø…ª¿µøî¡ŠÜã³_1—¹*AX¨ya¿RD×ùïG¬rã•Pk_I_©½¼gbåVÒ^/Ö#øıÔÊÇş8’W¥5W«:k‡áªêß´¼…iË?SºåT`ÄÎl,c•Ò}0ğK£:är6t¼İĞT«['”r†”8IöµK‰9Tóš¡ÚÙËEAŸø¡üåÍ˜H±'ã¸Uæö1.¢èş,_9Üç›hÙ^Š$iÅYÃ×ëFKöE½Z¨‘œÅ­¿CW~J\7İ«R³¿ü„ïA˜~ßxÆğÏxe-Àît¢ãUëxŒFQUß“Ã
œIŒÓ‡UË`ËÅŒQòD
H“X\óq$tèÄ@Ë ü    †ˆ‰‰—™˜i§ª‰ª— ¹š—ª–É¨ŠªŠ¸Š«™˜Š©Šwˆx™dšvš©š™‰©¼˜‰˜Éª™¨ª©È™w›Èªš™‰{‰ªhZjª¹ÌªšÉ ºšªª»™ªº«ªÈº»š—¨ªœ‡ˆ™x™™¨‰¨«ª‰Šš¬™š©ª…Š©Š˜ª¹˜‰‰ªz À     À       ºÀ     ‡‹Ë     ˜©¼     ‡‰™¹Ì»Ì‡™™ªª¼
‡˜ª   °w¨‰  ° €vˆ™¼ËÀ°‡¨ªº ÌÀw¨© Ê   €š¬Ì  °                        € ¨7"‹(Ò%¼Ùdâ`t%§Z‹ : ´"i<‹x¡İüúøC"1Ï4º+…úÈ­
úx
L]—ırˆ‚ ZrC¶;‹Ã¡¥/ÒÑÃÎiRêzXÒ‡ô£„>ˆ™ú—êÁæü”˜áSà†y
Ø0‘RÆ?rà ù£†Ø0 tÑiÓÔÓìÉÔuz{æá¥
@ëu)
 @CCOv‡VVÆ³êC`½øÁñ»ô“Lg«;¤*biïù‹ÅHœ´Xaéá’ÂRaÃådReğ_(8¸D¸¸°$ßŠ<™xsç €¦Y]m]A(0Wt¾b°Éš â4Èb>ÓêQfJ3F+Y˜«Ğ)–ôEÌa6d¸B4ÿ!' sqÃ@èäVß;&™‘_V1Ò:ìÂ,Z0Z*5!ñ±úÒ‚mé§7‰ÇÒKZÅ}P¯’5;–CîmXuš ;ï»Wğ²ÙQº*X˜fğo6Sô8ùÏã­\<dÈZ b †©Qâ;GÏ¹Åâ¢BºKŒË^hûÈXÂ'~ŞUĞ~œd«4ÂÂfú|…¶ÚhÅ.U9–®‘%ëÌL¦©9RŒªà Eçİ•šØ¤yå4_Réé§y
 ÔàñQÄ4ÉÇ•ºòd´ël¢³z
sdìQ@
e
àCHFQµçÆô¸E¾­¼â2Êzn©ñu|ä!=;@…œUİ i…{HA7a~D±ÁÔò«<|D‚2ß¤)ïJ¤[¢z+=‹«O]¹ôŞi¿–¢O–fYÀ¦fÈc?	rlWöùİb ÷TÂu ö\wAÓè{æRÛ‘Èèš¥âJ ÄŒ¦¡åü]cX+ÖÑG®-_¬™’_·êékxüÚ«q³y!WA7[ªöİD®{”AÕšH÷â·lÃ­`N-v\QÛøäHsZ zæIÎÄÿƒ£”‡ƒwbˆaj-èh÷3ÁU¡Bˆ[C¥€¤;òsG;Ş>=ôÑ<¼ø<6şµÊ'Gş÷ŠEBßE…"‰{
6o$fWØ¬€’&	ÑD#õ+£OPãÇ°åÄª3±ç&ÖÉO(9u@Zûï>JUAl¢Ş3öÀÙ”­u9ñ«#Wú1ZmäÇ÷ş¨\p£ÛÎs`-¯ë×—VrôÔä€`=u09  zè4ñİÑ×;1Š.²éRêC0´Ÿ¾Jx) öÏ?¨pİEP=o]¯Fé Î¨¯}éê$Y£ü‹’€lXÃòb7S˜íÕT8‘«£G6øš+c¨æKƒÕ)à )ŒÈ·È6¸|;%çr#İV÷»T¨~Kº09s®V­¬Ø@«iWD…Kµöaî>@ïÿ‘§èî§>² Pra=NÏ»é£«}¹E±¸ àÃ³ûŠü ÎX
yy<ÊÂ¶©ËÚhBË¹XEÄ‹µUŸWqÙÃd 3Öd'Ö´(.O|H2²™ÇÌ5è°Ñ«4û%O¡è¯g
¸Şa±7ˆˆ’3[z']¼H¦úw÷¢N¤i·ÍÁ-ßÚÇ8^»kfTz„¦:ûœ”ÂÃŠmk³%ÑÕg¦Ô÷gÜ[¬û œ=Sµ€¹J¬•NLúHª}3¿v?ªbe©ÆÛÈÀ˜”`€ÜöWRå‚™™Ëu
²A¢;V÷0ÉIş1KyqºJ›ü™-Öª@	Múo9eœê™7ú'vM€æ;ÚNÀ9í%Ø…:›|8¦>±–½ÓrËA&)‡öcÚ9sp3LM-0[.¼‘ò0~aóåÉy‡-û±?İÒ›ËV8ÓvÇ;W«‚´Ä¦„ˆĞµ0RÃ>şsİµ RWZKìJ
;&?¡æVİÎŸd}XØ7é7ù%¢ª‹qNõÅ‘‘Ñ J½“ìƒË¨ZòkÇaÔœ¸h–.ö„!º©Út5
I~¿Íü÷TAr÷Lmæê“ı3º0yø˜7Ë\«‹İµy¦ğğ¤tÑwí^oHäê9\5‡í±ŸE ë®"Ôª«Œ ö*ĞQæJ6‰hœƒ5u—©ná­¥mÕMüš Öv§Û»|Ñz4Q"ÓfÊÁ³ĞT©fœ­e€Ï	©o;a’„gÂ™éZ.ò¬×â,®³OX-Å<õR++Y%Çi5x®r«À„f÷Û'm•Ë móßÚÊÉ}ƒU×·74+J=ü=?T
ù9“·ïò‹…~Ÿ&ß¦»r„Ù¶V²[õ©Ì”jøÖj\ª·ªÖt ÕŠ™NµîJSZû©F©juQ§­lËTûÇ™ŠúURµa´YÛi»›ğ:àM«A@B=Ã¡uÈfqOš/?:s#Ÿsn=úéiœ!ûïğ¢m|¼iÇoZ©qZ±…oÖµó›·½o¸_†M«•Äå×uó¿e l›Ë³h_aX²`”üvìØ”ÒV½‡XÜ¾GDñèóÑ½á/ùß0ôz„¾z”¾F¬§NlµX2I‹Ú[çg¤ êZ~8;÷Nx8&@¾Ò±-ˆG‹:¢kåM*xÓ!ÑÔğb¸A†<ôaK×¡i°j˜ÈlM-)›:ÇÂEÕC¢t‹D,¨6––Œ$MOK,lÊ Î‚œÉl)/¯ÖÖ)ØËÑaàhí dÄ(–ª|šNŞc¼'ªtšŞ1ñZó§˜¥®Êa,fifDÎÎÆÏ©†S¸İ“qÇVÔu4ƒ„Ÿ{z×Ì&äpÁúòí³är÷XÜ[µÀ“Ùğ¨|ƒ¹émŒ`× kš°3ì`İíÊ’í¡ñe„°‚»Ï.`4VÀlõ¥]h–Øœßû.	²}§IÂ4ï%w3RPE8ÀuWì\™%Æ.}¬5€ÚáÜ¡~?}àS	
(mƒxù)#JE â~œ€Oaˆƒ¹vü?˜Té´÷‡JzpÂğ†FĞœ“(aìŞÖ›ı…‡=kKÃ#Æ:ƒpÚÕìÜÔ¶X)0PI%àD[67*)$Üèaº<’õâ¯„Du=ÆM² PD
Áó”gp‹‰Ìo‰\ƒy)€)ŒD7œgòŸ¯ó(/ñ—,³ûŠHngÕN U âÈ±¹Áìä•¤Úm9¿~uø“}ˆÄöñÀgÈö$Ú8N€úmÇ*ì^K‡[r€„T*<Æ”L
ø%3½ƒZZ)«ã¤Ïï(· 3L­ï<Såæ¦wÃúñm$¦¼&vÿ”§ÊîK½gŞ†ÌÖŞó$½£úòlš°NíÄ©ZÿjaÑ¢,!˜âtR>`İ0¼Æ—ç5¯Fı³¹eì#à×\eu}pÓí\ß|¡^8ü×>oÛòmV$©à¿¡4Åá4Fœ1{u¯I´ÍnÙ *ê™çk×ØI7)à•&`î«‰„BY²¤:İuÕìCq{Şû‘r2öQ'QFRğA\Il-xb[K®õ=L<ÕúK5‡Ù=wsÄìm×¹h
·èWT³ŒÖyLÜúúw®F¨¡Z7şAºö­¡æĞx„©}®Û-ÚòÛÁ¤{¥8=êÈC3´Ó€³£Øl¨Â/dœfû?åñ³°šÿwv¶b6Û4®~Ôd”EÓI‰òİf.2ƒ§Ë$©&Êë>J3–Ñ=èrŠÕRp­d´òª¨£jÌyèdÀdHV†Ë—ï”.UóÄ©ıÇŞ—p„ä¥;ÅÁ</—ìØX
ŠyÛC¬g^°9UBH&¡C®ü=ÜdGß~ì¤\çÂSÈÈÅ_t_~7²~éM—âølÔÕñöÊ1Œ…cqƒ İÇ*?;)i»4âVš›Œ”h½¤dd5"£èS’/Ö|zú =ŸêrÁ¦£2_ë8
ÙÃ8÷Şô!½1X¶#«¢Ó+Ø˜l5}Ë!¡r^Î=2Ö{c+¦sd¨cGÁ.,e¯fÌÎ×kâ­Î3lâ	Ç›·Û›;rHGÃÌé÷§9ò«º9Š1V2EÉ¤Pf¢|¸óCŠìKãH¤jJÈë¸M_Šë/[ÈrHşÃåuˆ®ul M)¢ìJÕ•Àµ›8SO)@ç“ˆw'cœ?¿®#Û«íäë%+6<Îè~ÈgŞƒ`B7‡%¤v°=Åøsæˆçñ+÷”ç¦é+9¹°×á{şæñ¿÷şÿğó…Gqã›ƒ«©íğUVZp93‹S&	ÿ’×ºÔ€¯£{+ğò õ¾°î2¤ß2³é)¤][hªøí5JîÆc%üÇ"ıÉ†_`Ø“Æ§ïİá©—OË[²;tÖÿ9³ë9å„Ğ‘nÅC¼šyÏ—Õ~¹y¬iÄF#v™U}-âÓ™5À- Fªo6ÍªÒ[ºŸú"ß#? ¿jãS-ûÀp{dá ËoŸRãp¤‹)ÒÎcQÄh‘ÊvşòªªZŞÏùÊ©P¤ı¾¶›yòˆ”[Î“(+L¦|‹F…díl®?‚IÕŞ=Çzm!÷±@Ó.ÿDOœU” èá-Hf’R
«˜C¤Ó¾w–ˆ(·£ğºè'	6fq_á6‹øô°X ¨(\…
²¸%'±Ù\¼â–°P@Äî·sĞbşâä"ÁY0üä(Gø?Ó¼|í|›ğeÛø‚.l9ç}W„øx*âôcD‘şGò¼a
€€únÃŠ 	ˆo³\”%‚Mr·ª±¾€-Şß3nŠ‰E<%iÃŒ:Z€`ÉóÁ	3B•áÌ/ñ‚şqÊO6ì/·!rãç,vy[C‹é;ídÄá3aAJ­Fb®Úo’„*İrÀïHº>zó”i€4’oàráÿc2†„+çj	¦;¼^ ¾§•gÕÃ½MX¶òöÀ!¬à3Ù:[ûÇ§¹µì3ÃÿŒø7ïX¢ªÑ*‹âŞB§I‹EJ-¢méîôò.üc7Ö["øòÆÉ#½ëÚ¢Í{AFã†…(‘`sXq Ï«â­ ©-E
œ 2è€œSÎ™Äï£öKÖ±)“ÛR©ÔôÓ >ò‡”ÄNÔXú4î[Pÿ×qpÄ$X±"f<00ç*Óö©p·ÄÚêœ»ƒ.Ş ²é,KoKÎ~ô7»ÅâYÿA;5'ÙÁQüƒˆ6ïjlÊ©*ÏRe#Hki©ìuºÛr²fÊ÷>e¤SôÆ0vRÜ7‹ÙÀ–¡QtĞ×Ø9OÒ*hsø%¿ÂëkÉPøD¥óxÖK-w)gô<&^·Í573|¸›…
şOFŠ^–›ï5
ß>.ğ>2‘i7ìU@×©ı(P{K¬±ä(–+–(Ğs Ròn‡¬0Â 7(Sf‚ Şm<Ş¹T®ª	y"
¤Ûp l”)’Â=ÏîB—(ìæ*¿
©Y¬EÀ~H°7üRâ¼ùU¸MV#ÚE×€KiÚÏ)í›•·ğ[“vÁ¯òºšHİ•²­yS>â˜¥,7Gİ™0FöN{Z%ã¬4ä
˜¤“¯Tñ±ºT\*›0sb´½ª”ÏöÕŒ¾ø©½“
æ¸û{ğÅ|:ŒŞ`½tË	—wS	D p.é®9÷Ÿd\Ø~4Fû‡cî&r•rÁøÖ&ÉÃŒzµ|½%ïšwcope(_env);
  MaybeOrValue<Napi::Value> result = Value().Call(args);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Napi::Value> FunctionReference::Call(
    const std::vector<napi_value>& args) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Napi::Value> result = Value().Call(args);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Napi::Value> FunctionReference::Call(
    napi_value recv, const std::initializer_list<napi_value>& args) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Napi::Value> result = Value().Call(recv, args);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Napi::Value> FunctionReference::Call(
    napi_value recv, const std::vector<napi_value>& args) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Napi::Value> result = Value().Call(recv, args);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Napi::Value> FunctionReference::Call(
    napi_value recv, size_t argc, const napi_value* args) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Napi::Value> result = Value().Call(recv, argc, args);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Napi::Value> FunctionReference::MakeCallback(
    napi_value recv,
    const std::initializer_list<napi_value>& args,
    napi_async_context context) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Napi::Value> result = Value().MakeCallback(recv, args, context);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }

  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Napi::Value> FunctionReference::MakeCallback(
    napi_value recv,
    const std::vector<napi_value>& args,
    napi_async_context context) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Napi::Value> result = Value().MakeCallback(recv, args, context);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Napi::Value> FunctionReference::MakeCallback(
    napi_value recv,
    size_t argc,
    const napi_value* args,
    napi_async_context context) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Napi::Value> result =
      Value().MakeCallback(recv, argc, args, context);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()));
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Value();
  }
  return scope.Escape(result);
#endif
}

inline MaybeOrValue<Object> FunctionReference::New(
    const std::initializer_list<napi_value>& args) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Object> result = Value().New(args);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()).As<Object>());
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Object();
  }
  return scope.Escape(result).As<Object>();
#endif
}

inline MaybeOrValue<Object> FunctionReference::New(
    const std::vector<napi_value>& args) const {
  EscapableHandleScope scope(_env);
  MaybeOrValue<Object> result = Value().New(args);
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  if (result.IsJust()) {
    return Just(scope.Escape(result.Unwrap()).As<Object>());
  }
  return result;
#else
  if (scope.Env().IsExceptionPending()) {
    return Object();
  }
  return scope.Escape(result).As<Object>();
#endif
}

////////////////////////////////////////////////////////////////////////////////
// CallbackInfo class
////////////////////////////////////////////////////////////////////////////////

inline CallbackInfo::CallbackInfo(napi_env env, napi_callback_info info)
    : _env(env),
      _info(info),
      _this(nullptr),
      _dynamicArgs(nullptr),
      _data(nullptr) {
  _argc = _staticArgCount;
  _argv = _staticArgs;
  napi_status status =
      napi_get_cb_info(env, info, &_argc, _argv, &_this, &_data);
  NAPI_THROW_IF_FAILED_VOID(_env, status);

  if (_argc > _staticArgCount) {
    // Use either a fixed-size array (on the stack) or a dynamically-allocated
    // array (on the heap) depending on the number of args.
    _dynamicArgs = new napi_value[_argc];
    _argv = _dynamicArgs;

    status = napi_get_cb_info(env, info, &_argc, _argv, nullptr, nullptr);
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

inline CallbackInfo::~CallbackInfo() {
  if (_dynamicArgs != nullptr) {
    delete[] _dynamicArgs;
  }
}

inline CallbackInfo::operator napi_callback_info() const {
  return _info;
}

inline Value CallbackInfo::NewTarget() const {
  napi_value newTarget;
  napi_status status = napi_get_new_target(_env, _info, &newTarget);
  NAPI_THROW_IF_FAILED(_env, status, Value());
  return Value(_env, newTarget);
}

inline bool CallbackInfo::IsConstructCall() const {
  return !NewTarget().IsEmpty();
}

inline Napi::Env CallbackInfo::Env() const {
  return Napi::Env(_env);
}

inline size_t CallbackInfo::Length() const {
  return _argc;
}

inline const Value CallbackInfo::operator[](size_t index) const {
  return index < _argc ? Value(_env, _argv[index]) : Env().Undefined();
}

inline Value CallbackInfo::This() const {
  if (_this == nullptr) {
    return Env().Undefined();
  }
  return Object(_env, _this);
}

inline void* CallbackInfo::Data() const {
  return _data;
}

inline void CallbackInfo::SetData(void* data) {
  _data = data;
}

////////////////////////////////////////////////////////////////////////////////
// PropertyDescriptor class
////////////////////////////////////////////////////////////////////////////////

template <typename PropertyDescriptor::GetterCallback Getter>
PropertyDescriptor PropertyDescriptor::Accessor(
    const char* utf8name, napi_property_attributes attributes, void* data) {
  napi_property_descriptor desc = napi_property_descriptor();

  desc.utf8name = utf8name;
  desc.getter = details::TemplatedCallback<Getter>;
  desc.attributes = attributes;
  desc.data = data;

  return desc;
}

template <typename PropertyDescriptor::GetterCallback Getter>
PropertyDescriptor PropertyDescriptor::Accessor(
    const std::string& utf8name,
    napi_property_attributes attributes,
    void* data) {
  return Accessor<Getter>(utf8name.c_str(), attributes, data);
}

template <typename PropertyDescriptor::GetterCallback Getter>
PropertyDescriptor PropertyDescriptor::Accessor(
    Name name, napi_property_attributes attributes, void* data) {
  napi_property_descriptor desc = napi_property_descriptor();

  desc.name = name;
  desc.getter = details::TemplatedCallback<Getter>;
  desc.attributes = attributes;
  desc.data = data;

  return desc;
}

template <typename PropertyDescriptor::GetterCallback Getter,
          typename PropertyDescriptor::SetterCallback Setter>
PropertyDescriptor PropertyDescriptor::Accessor(
    const char* utf8name, napi_property_attributes attributes, void* data) {
  napi_property_descriptor desc = napi_property_descriptor();

  desc.utf8name = utf8name;
  desc.getter = details::TemplatedCallback<Getter>;
  desc.setter = details::TemplatedVoidCallback<Setter>;
  desc.attributes = attributes;
  desc.data = data;

  return desc;
}

template <typename PropertyDescriptor::GetterCallback Getter,
          typename PropertyDescriptor::SetterCallback Setter>
PropertyDescriptor PropertyDescriptor::Accessor(
    const std::string& utf8name,
    napi_property_attributes attributes,
    void* data) {
  return Accessor<Getter, Setter>(utf8name.c_str(), attributes, data);
}

template <typename PropertyDescriptor::GetterCallback Getter,
          typename PropertyDescriptor::SetterCallback Setter>
PropertyDescriptor PropertyDescriptor::Accessor(
    Name name, napi_property_attributes attributes, void* data) {
  napi_property_descriptor desc = napi_property_descriptor();

  desc.name = name;
  desc.getter = details::TemplatedCallback<Getter>;
  desc.setter = details::TemplatedVoidCallback<Setter>;
  desc.attributes = attributes;
  desc.data = data;

  return desc;
}

template <typename Getter>
inline PropertyDescriptor PropertyDescriptor::Accessor(
    Napi::Env env,
    Napi::Object object,
    const char* utf8name,
    Getter getter,
    napi_property_attributes attributes,
    void* data) {
  using CbData = details::CallbackData<Getter, Napi::Value>;
  auto callbackData = new CbData({getter, data});

  napi_status status = AttachData(env, object, callbackData);
  if (status != napi_ok) {
    delete callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  return PropertyDescriptor({utf8name,
                             nullptr,
                             nullptr,
                             CbData::Wrapper,
                             nullptr,
                             nullptr,
                             attributes,
                             callbackData});
}

template <typename Getter>
inline PropertyDescriptor PropertyDescriptor::Accessor(
    Napi::Env env,
    Napi::Object object,
    const std::string& utf8name,
    Getter getter,
    napi_property_attributes attributes,
    void* data) {
  return Accessor(env, object, utf8name.c_str(), getter, attributes, data);
}

template <typename Getter>
inline PropertyDescriptor PropertyDescriptor::Accessor(
    Napi::Env env,
    Napi::Object object,
    Name name,
    Getter getter,
    napi_property_attributes attributes,
    void* data) {
  using CbData = details::CallbackData<Getter, Napi::Value>;
  auto callbackData = new CbData({getter, data});

  napi_status status = AttachData(env, object, callbackData);
  if (status != napi_ok) {
    delete callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  return PropertyDescriptor({nullptr,
                             name,
                             nullptr,
                             CbData::Wrapper,
                             nullptr,
                             nullptr,
                             attributes,
                             callbackData});
}

template <typename Getter, typename Setter>
inline PropertyDescriptor PropertyDescriptor::Accessor(
    Napi::Env env,
    Napi::Object object,
    const char* utf8name,
    Getter getter,
    Setter setter,
    napi_property_attributes attributes,
    void* data) {
  using CbData = details::AccessorCallbackData<Getter, Setter>;
  auto callbackData = new CbData({getter, setter, data});

  napi_status status = AttachData(env, object, callbackData);
  if (status != napi_ok) {
    delete callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  return PropertyDescriptor({utf8name,
                             nullptr,
                             nullptr,
                             CbData::GetterWrapper,
                             CbData::SetterWrapper,
                             nullptr,
                             attributes,
                             callbackData});
}

template <typename Getter, typename Setter>
inline PropertyDescriptor PropertyDescriptor::Accessor(
    Napi::Env env,
    Napi::Object object,
    const std::string& utf8name,
    Getter getter,
    Setter setter,
    napi_property_attributes attributes,
    void* data) {
  return Accessor(
      env, object, utf8name.c_str(), getter, setter, attributes, data);
}

template <typename Getter, typename Setter>
inline PropertyDescriptor PropertyDescriptor::Accessor(
    Napi::Env env,
    Napi::Object object,
    Name name,
    Getter getter,
    Setter setter,
    napi_property_attributes attributes,
    void* data) {
  using CbData = details::AccessorCallbackData<Getter, Setter>;
  auto callbackData = new CbData({getter, setter, data});

  napi_status status = AttachData(env, object, callbackData);
  if (status != napi_ok) {
    delete callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  return PropertyDescriptor({nullptr,
                             name,
                             nullptr,
                             CbData::GetterWrapper,
                             CbData::SetterWrapper,
                             nullptr,
                             attributes,
                             callbackData});
}

template <typename Callable>
inline PropertyDescriptor PropertyDescriptor::Function(
    Napi::Env env,
    Napi::Object /*object*/,
    const char* utf8name,
    Callable cb,
    napi_property_attributes attributes,
    void* data) {
  return PropertyDescriptor({utf8name,
                             nullptr,
                             nullptr,
                             nullptr,
                             nullptr,
                             Napi::Function::New(env, cb, utf8name, data),
                             attributes,
                             nullptr});
}

template <typename Callable>
inline PropertyDescriptor PropertyDescriptor::Function(
    Napi::Env env,
    Napi::Object object,
    const std::string& utf8name,
    Callable cb,
    napi_property_attributes attributes,
    void* data) {
  return Function(env, object, utf8name.c_str(), cb, attributes, data);
}

template <typename Callable>
inline PropertyDescriptor PropertyDescriptor::Function(
    Napi::Env env,
    Napi::Object /*object*/,
    Name name,
    Callable cb,
    napi_property_attributes attributes,
    void* data) {
  return PropertyDescriptor({nullptr,
                             name,
                             nullptr,
                             nullptr,
                             nullptr,
                             Napi::Function::New(env, cb, nullptr, data),
                             attributes,
                             nullptr});
}

inline PropertyDescriptor PropertyDescriptor::Value(
    const char* utf8name,
    napi_value value,
    napi_property_attributes attributes) {
  return PropertyDescriptor({utf8name,
                             nullptr,
                             nullptr,
                             nullptr,
                             nullptr,
                             value,
                             attributes,
                             nullptr});
}

inline PropertyDescriptor PropertyDescriptor::Value(
    const std::string& utf8name,
    napi_value value,
    napi_property_attributes attributes) {
  return Value(utf8name.c_str(), value, attributes);
}

inline PropertyDescriptor PropertyDescriptor::Value(
    napi_value name, napi_value value, napi_property_attributes attributes) {
  return PropertyDescriptor(
      {nullptr, name, nullptr, nullptr, nullptr, value, attributes, nullptr});
}

inline PropertyDescriptor PropertyDescriptor::Value(
    Name name, Napi::Value value, napi_property_attributes attributes) {
  napi_value nameValue = name;
  napi_value valueValue = value;
  return PropertyDescriptor::Value(nameValue, valueValue, attributes);
}

inline PropertyDescriptor::PropertyDescriptor(napi_property_descriptor desc)
    : _desc(desc) {}

inline PropertyDescriptor::operator napi_property_descriptor&() {
  return _desc;
}

inline PropertyDescriptor::operator const napi_property_descriptor&() const {
  return _desc;
}

/////ÆA€‰a‘©|šã€^âj ‘—m PÆA€j ‘©|šã€^âá”£m PÆA€á”©|šã€^ây`R™‘m PÆA€y`R™©|šÕ²znhDä™—m PÆA€hDä™©|šã€^âû1û m PÆA€û1û©|šã€^âäÅsŸ˜m PÆA€äÅsŸ©|šã€^âÊ»…¡Ÿm PÆA€Ê»…¡©|šã€^âYŒ§–m PÆA€YŒ§©|šã€^â=Ê§•m PÆA€=Ê§©|šã€^âõÏÌ©—m PÆA€õÏÌ©©|šã€^â’Ü'¯™m PÆA€’Ü'¯©|šã€^âö|Œ¯–m PÆA€ö|Œ¯©|šã€^âø ì±•m PÆA€ø ì±©|šã€^âc»•m PÆA€c»©|šã€^âŒœ˜½–m PÆA€Œœ˜½©|šÕ²znY¾”m PÆA€Y¾©|šã€^â{s›¿–m PÆA€{s›¿©|šã€^âQ=iÀ–m PÆA€Q=iÀ©|šÕ²znaavÀœm PÆA€aavÀ©|šã€^âØ•¿Ì¤m PÆA€Ø•¿Ì©|šã€^âêrµÍšm PÆA€êrµÍ©|šã€^â¿"Î”m PÆA€¿"Î©|šÕ²znE¨^Î›m PÆA€E¨^Î©|šã€^â¸HÏšm PÆA€¸HÏ©|šã€^âY®‡Ğ—m PÆA€Y®‡Ğ©|šã€^âSw]Ó¨m PÆA€Sw]Ó©|šã€^âÜE‚Ó’m PÆA€ÜE‚Ó©|šã€^âğ~.Ô”m PÆA€ğ~.Ô©|šã€^â(lÑÖ—m PÆA€(lÑÖ©|šÕ²znBÔÕÙ–m PÆA€BÔÕÙ©|šã€^âÃ"Ü™m PÆA€Ã"Ü©|šã€^â•Àå–m PÆA€•Àå©|šã€^âÉ3jå¡m PÆA€É3jå©|šã€^âÀnçm PÆA€Ànç©|šã€^âª"ºèm PÆA€ª"ºè©|šã€^âÆÃ~é“m PÆA€ÆÃ~é©|šã€^â7gÄé£m PÆA€7gÄé©|šã€^â×±ìê—m PÆA€×±ìê©|šã€^â<çåë—m PÆA€<çåë©|šã€^âp~3í£m PÆA€p~3í©|šã€^âëtğíšm PÆA€ëtğí©|šã€^â¾g{ğ—m PÆA€¾g{ğ©|šã€^âš µó m PÆA€š µó©|šÕ²zní]Ãô”m PÆA€í]Ãô©|šã€^âûH‚ş—m PÆA€ûH‚şêˆš>mÏãÆJqhoP<€{: ©“šûNmN”^k PÆA€”Ã•šîÿã8Ó•¬¶ÿÿÿ_ÆA€@h Zš·Ö_½Ó ğ­Q{­€7[dÏ~š¬×íí\M
X  (Ÿ€H* Z¤š«v’Ø\Y¡¤€
P.Ê€ÛÅI¯šU@0²—ˆ¼^Œ8@â¯€Á§.2I·šp$ÿlØ@à¥k PÆA€lØ@à†Çš‚FY@©¸w $/Pm€ƒÓÑzäšå]òrŞ‡~‡ °P;€ù,äšİ–§Ó!ïÎÁ °P;€«‚­ãèš (T®Ééğ  PÀ€5ª‡]ë›h&3$W´À ÌP‘;€2»ş›Ü ÒîtZ‹À}PÄ€Ë »”›1é`”£{\óC¸Ä@~<€dd‡^8›-
ƒÇ¸©|÷ nPÆA€ÄÌ}4œ+›?A¶=ÄK _Ì.P×L€ì-nK/›ºàâ¯h^P  p4@xÍ:›pÄàD7`;èP]<chÀ:=›áòƒß’·]N1 @Öô€ß’·]0?›8_^_PÓ¾¡  
PÆA€ëxx¢@›áõ¿ÛBtíÿ¸ÉQD[°¢©vB›îZQÖj<c½4PuH€ =4¦D›÷%Ú6ØGA?¨Œ<P  p*¿öñD›,ºH¿
Ä~ Œ	Pî€HçÕ§”N›š/r£bÿÂå ø@£ 
«ı²ÂS›û#`ƒ17°‰cP;  p¦nz?ÂS›û#`ƒ17°‰cP  p¦nz?(a›|Ÿóc	Ü Pš €c	(a›Ó³0ğ R½
Ü Pú€ R½
(a›ßMê¬oÀÜ Pú€¬oÀ(a›—IhŞä¨å$Ü P‹ €ä¨å$(a›ñ‰İi'Ü P‘€i'(a›¸«@×ËJÍ-Ü Pú€ËJÍ-(a›Äô(Ô·¥.Ü P‹ €·¥.(a›K;6Ë8Ú»1Ü Pš €8Ú»1(a›ëíDÏ˜É5Ü P‹ €˜É5(a›@ù¿³32IÜ Pú€32I(a›!×Æ§R6K]Ü Pú€R6K](a›ü¶ßŸWReÜ PÓ €WRe(a›¾‘‹ŠÍppÜ P‘€Ípp(a›ñ€?‚a²{Ü P‘€‚a²{(a›gU–{´Ü Pú€´(a›ÛF&s¨§«‰Ü PÓ €¨§«‰(a›.Fœa]§›Ü PÓ €]§›(a›±aÂæ†›Ü P‹ €Âæ†›(a›|Xé¢Ü Pš €é¢(a›á·}Y’Vğ£Ü PÓ €’Vğ£(a›±UfP¯Ü P‹ €fP¯(a›„J÷òŒ°Ü PÓ €÷òŒ°(a›h©\;HÑÁÜ PÓ €HÑÁ(a›ÕŸ9¦ùÃÜ Pú€¦ùÃ(a›3!?@ÀÅÜ Pú€@ÀÅ(a›V¸¿7%Y2ÍÜ Pú€%Y2Í(a›sÄ´( %9ÒÜ PÓ € %9Ò(a›ÜMî)¯¬cÓÜ Pš €¯¬cÓ(a›©À®Ú!#äÜ Pƒ	 ÀÚ!#ä(a››øèâuíÜ Pš €èâuí(a›«Ó:
Ø2·ğÜ P‹ €Ø2·ğ(a›q¨™IñÜ Pú€Iñ(a›	B	wèÏóÜ Pú€wèÏó(a›‹N‡ ø¯
úÜ P‹ €ø¯
ú(a›Š¥MùDÀÿÜ Pú€ùDÀÿ{z›”¬%˜T àPî€twÏœ×›2‡iu'ïùTk PÆA€'ïùæ›ZÓü¡j'$™	tP+Ù€@|uĞ™›:OäŠ˜érø–P±€Ÿ¶%a½›RØ³‰{rãL PÓ€‰{rãÃ›‰­cíü‡— \£Pz p8¬œ˜Î›FJ%ƒ1PòÛaPô€¤ËT„$ä›íh¿"xÿ7 P×ì€J¹‡®“ä›#*æ“çK ğPCB (’¡0´ç›‡Ò(µßÍ\3 PÍ‡€µßÍüè›	–ñ¯Âš$¼ üP7¿ ];ÛYş›G(¤ùçñ™ 8P—ì€ƒnM7œ©ğö=jÍ  PÑÔ€=jÍ–œŠÁQñÔ PB®€CØîud%œ3h‡å‡ËÙÄ PJ,€‡å‡Ëe(œâ„Ú$U¼Úw Š PO=€U¼ÚwY=œôEè^ Q  øP|;h Oœ yÖ—÷†3Şğë(Tw pš¦l	‹lœ99ù7€%óE šPÎÄ€ºx±<pœY')6rÿmPuy€:´àğoœVb,’Q	™C LY@P…€°Ë!®œä(nM3yœŒ ¢P˜2€XÈ…@tˆœîÿã8í¤ ş	P…¡€»×ì:ŠœTõİ’ìz€ïPK;‹<Ehœ@`œ‡S=‘ @åe€t³f&K’œ>bó€®z¶’ã PŸf€®z¶’Bœó©ú‘7€œğP`>÷ªÄï¬œ :Õ¤¶ç/ÉJF PÖô€¶ç/É®œ¶*M &QÑì‹P3€Éö¾‰6µœY#µ5ºKš‘4P:€·L@ÕœÜ›(êñò äP«U€½4ê<Üœm¬7³¡kó` ˜P €|[ÅsÙéœ U‚&†ĞVêhPö5€K“ŒÙéœIOòV†ĞVêhPú4€TQãüÙéœï¨G†ĞVêhPú4€ò¶V'Ùéœæ˜†ĞVêhPú4€ø‰$ÙéœÜQÁ³†ĞVêhPö5€ÁOĞÙéœ	‘.Å†ĞVêhPö5€?oCíœÛJåŠn€ P6€òD$IE÷œãv®°µŸT<g 0mÍ€h£ öùœ3m²õ?ÿ°ÊP;  pSõõ+d@»H1õ ©	k PÆA€1õ ©=‘;8O×!0 FPW€Qi:îÌ!1€>Z»ğâP 8æ—è èÈÖs lTı¨@P@}€Üÿzí§&SÑsúYÙ’æk PÆA€YÙ’yCOCh3°ø°‰3­ PJ,€°ø°‰ÎZğıÚ3š7O¿´ PÆA€š7O¿	fS¸D>0œ¸  02m€8] œªÖWĞ¿Ÿ rPÆA€­ø÷‚g»ÛÖ±ÔßoP- À£HĞÛ‚g»ÛÖ±ÔßoPf6€£HĞÛã«ÙOE« ë#fŞ…Qw p}¥PƒÖM«º Án*:‘&@6y€Ló¡ÙØHw3Ñœüˆ| 0PGÓ€T…ñ6ìÚgJM•¤lÈ V P±X€•¤lÈ€ìßÔø›Fjc¹‘ PÆA€Fjc”úİ<¿ SE1*PÆA€ùdšvÛêé„°¸-˜ ‚P7€šùQUÄ›=ˆ3ÌD%Í—Qw pÍIİ3¾#÷­Äëad£ .@+¡€ıXKàP&Ù<Ãië­PõÓ€|¬Ã‚.PóÌĞ¼üJ¼  Pæß€«XœXDJ,=ë¢
‰ı 8 Pzk€¢
‰ı6X>bÉ"ù” jPµ«€çÅ‹BüY÷œ!¶Ø[Ã  
P1ø€‚Ùbæ4wÌ~Ò-T „ @,õ€-Tüxn^Hßu’´¹ jPF7€2©­GÏîÿã8
Åòğ €PB®€OôÇÏ.Wú‘
Åòğ PB®€¬èª¡G“sËH™{NXPÆA€Dì=QSšË…½…% ÂPõÓ€°¸bòº¡Âèo7Rõø vPóÓ€vËâ=Âë^ïµö› ¦ PĞ‘€ö›ûÉÀß:à¼LÅtPÒF€|túÈîÑìÅËÌõ²ÀÅüi PÆA€õ²ÀÅÈİ´R[,ëLÈ¤ŸP_50ÚHÂÂá
"iK3Ã  İAéV€§±bNâE°÷>@1k1lj @h"€@1k1Sëp»0-›ÅƒS ºXP{­€œ&€äø¨ê;†£HU	P[€Ã»tŸ.Õ²ìç÷E @Öô€²ìçŸ.Õ²ìç÷E PÖô€²ìçõŸP”=ù©úq¨_PÆA€ÙV$–Ÿ$:ªHŞxÖWöPg†€<Ÿ.A$Ùúl;À«?P~ p&|òÚŸËÏ¥¹âÂä¡Ö¼ Pa€âÂä¡ŸØëpc»¾Í	  º2€pÿ	 Ñ,ŸA%°I†˜vP  pá¨ŸBŸöÇƒ{qû“ @P–g€	¼ 6VŸ‚zNc`£…çj PÆA€`£…VŸøÀ,7°zÛ«k PÆA€7°zÛ1VŸ°ÅBŠ@rI¹˜  Pg†€@rI¹[Ÿ||ÆZ€¼\ ò PÆA€× ][“]ŸQú˜qHÛ, h@#‘€Š»w”dŸ&éÂ¸“_ºi PÆA€¸“_ËpŸØ®uÔ^€ø 0K°€Pé ÖxŸ‚zNc4ú'&íj PÆA€4ú'&ó€Ÿƒkšd6l @3På8€Ê^‘Ÿ­aısvH/³Î$PG €Üİ`ÿŸ”
0$,³„–ÈüPZ6€v4‚ê©Ÿoß›&²± 6PW€ÊO¤	n¬Ÿ7ºAyÜ\ñŒbP$«€;â‹ï·Ÿ‡½Í“6ñ·8Ph€6½†ÁÆŸB®¸/+ÅY,¨gPº pšm"ò¨ØŸdZµ0Ğ¯æîP…ô€b{I™äöŸ½Aùgæˆ *P|É€A˜è~[øŸÜNã="F°X <PÈ€Bn*Ó &éÂt¿‰½i PÆA€t¿‰9 &8o³°ğ³>k PÆA€°ğ³H àQãrşQ r Pó3€rşQ¬$ 8Ò&5fŠ BPW€•ã¯ì; eËäíÄšhPU^€Fî”WS &éÂUÆÂi PÆA€UÆü`  8–Œ$=Ú«k PÆA€Œ$=Úu Ùn~ÈIØÿYz	PéV€¢™T‰òu ²‡İµ¬GO;l PÆA€µ¬GOŞ{ îÿã8_áñu ŠP‡É€|¶âÌ –ÖÒòé¶¢Puš€’íÊª ú"¢©sß¿ nP[`€	hCñ· %êM¥I 	PB®€¯M‚Á ÍİİY¶«P P± aÑéÀÕ ½°¢%`C ÚP1ø€[ßblRÜ …"–$—²@TP{4U–JT0ß r ÌšBŸ PÙN€nšø &8o³_	şpKk PÆA€_	şp\ı üàvÔ‡|I;ÓPÆA€¹W:¥ı&¡…dN„Í6:  PÔ~€Í6ı&¡İË¦/S¬%:  @Ÿ­€S¬%·1¡²‡İF =Jl PÆA€F =oc¡…*?rˆmèú-P  pƒö‚sn¡¢… Ç !C ¸P7€Aã(…q¡­›¬&m‘éj PÆA€¬&m‘q¡­^¯”ã°Âg PÆA€¯”ã°6}¡ìÅËÌ(ëÜúi PÆA€(ëÜ6}¡2‡iu¿ïkgXk PÆA€¿ïkgé‹¡’ù”íŒËrPç'PÆA€ñrÚ52 ¡ß_é¬(Ã‡ @PH€azTZ®¡ÊQTSN h Pçü TSNc¯¡¹v œ¢—c¸Pº p½4jQœ±¡&éÂEzÃi PÆA€Ez9Á¡Òı~t
½ò) |P4{€
#Òf‰Ğ¡qî5€}A# ş PB®€}A#-õ¡@]Rø–‡j L P@,ø–‡j±÷¡ÓŸtj4u7Š PÆA€j4uÉü¡ÛšíƒíŠXoQz pf)Ó¢­›ÊéTêj PÆA€ÊéTÓ¢­^.6ÅÃg PÆA€.6Å6¢öÿ\¢WÓåÇ 0PW€)Ÿ£u64¢q¶/ùøï:™uPº#€šÜ5%³7¢A9;²¾õÎãm‹ PJ,€¾õÎãÁ9¢Ô¶À/ xø PP*€†Ğ1÷XE¢a•®ÍÒÔÏ’&JP €»ÃÀkE¢ºï®¥—,>â	Px>€XPkE¢ˆÿüà—,> â	P›!€$I ÿJ¢¤ƒ0ı³ˆŠ‰@£ WõT¢W!› Xğ rP&¢€ƒàÜT¢1³jÇQò— À
P¸£€ƒGãbÇX¢5¶ñİW&G PGê€¤ÄÀe¢
kúŠİ¾‡@í€Ë—©h¢&8o³¶iJk PÆA€¶ioi¢äoâ‚° °P|É€Ï,íñp¢kç£Iàò1¼  ûU€Œ •¢°‚²Kû™¬E PÀ€¶|;Ìz•¢îÿã8:½×.ôîPŒ€ú9„“&©¢Ï¤¯ò„œK]Mg PÆA€„œK]!Ş¢ğÛ‰••ne P=@•n‡á¢tîĞ7gAîÙ “P7€C.Mî¢­ª[«Ù‚¼i ªP„`€Ô³¡eb£Ë/:½L³ƒPÅn€f=@=)£.Íš)‡*¼¹ PÆA€)‡*õd£÷¾Š­¦‹ {Pº p@¨&g£]ã¿Ò ¾  &Pl€'Ìı"?k£…›ÎÏô³Ü³!P  p“*x£ck_G¯4ü€İ$PÒô€¥]E¶*€£ù€-¼uèÄ ÜÕR{­€dï0ƒ£o¢7 IÂ âP„Z€:šS£SÏGÜ†Ú)‰ PJ,€†Ú)S’£š]s”"´ hPoŞ õyYÛ–£jtî•y9É¹5PB®€k]û¬•¼£g#ùÛä ñ‹ PJ,€Ûä @¿£b‰-òKUsÈ8PÆA€ßfo }Æ£±œùÍ28ô®” PJ,€28ô0Õ£Ùàu¯á@ˆÆ 0¥“€¬N #×£Fg'—¶²Œ°Å	Péy€Iü–µÛ£&8o³÷{l:k PÆA€÷{l7õ£|?Œù¼j/Pm€¾¢ÆÎş£%íµÆ8Z=e P·Ù€ö£bıÙş£+1LÊai0 °P ·€ñØ5yÁ¤OpSºœ€éq–PÓ€!Uæ¤qèJä
g¡ºKµŒAi©€_gûm¤›É1Z(«ü XPÄy€	ƒ%Ÿ`&¤u½]‡UXd 6PW€L4~.¤È'n†ï`™ú@M²€È©ê–7¤€(?Ìñ FÑb+F	 ´ì L¤šFSJ^v‚Ë 0K°€dé qR¤2‡iuÔQ}ck PÆA€ÔQ}ˆT¤xQy\"%F ÒPÆ&€ Û™¤îsC*Øú) 0ÆA€D‚ Ä¤OhÊ	È *ŸÓQ”H€Ça®úXƒ¤}S}¶ñÑMñ{ Pº€€¶ñÑM‡¤’WÒ£ÇÍ tPéy€U>…L¤ é¸µÕÛ P¨_€›Htj•¤&éÂË5AíÁi PÆA€Ë5Aí¢™¤ÍFlLá‰ ªl PÆA€Lá‰ YŸ¤XŞÀâ›‘JFª Pí‘€›‘J¦¤Ğ*ô8Vşq: P’€8Vşá©¤ßÊı°ïõÕS@P>Pº pŠúÀƒà·¤x´z­®ÅñHøPºú ş«wV¾¤ü?Ğ¡Øt‹’{ Pæú€Øt‹äÂ¤ Å*ëŠ—í  Po"€Ô‡™ÿË¤ÿx.U÷“k3_Pg†€/¡ª°à¤Å÷/Ó©b­ ¨PØ«€âš…÷¤Æ ˜V@ù¯ 
P|É€Çz‘WÚù¤!Õ¶*&Ãk0¿P2?­‰Ï¾¥÷ .˜Êm>Õ8™w@ès€E\#R¥0WwœumqË™ PJ,€umqËI¥8Î›YÄ¡X$í@	r€~^†ğ°¥6W]ÀOËå Ÿ
Pí2€ÇpMğ¥`j28Ô—¥(  (Ÿ€\* è#¥I„ËÿK¼Íg @y‚€ÿK¼Í)¥¬_óé.°í±fşPÆA€ şâZ)¥Hi~~·=/ ÂP“m€`Ïf|7¥•P•–c8+wÕÀP2‰€†™vcÖ7¥åE «,(!î Ê´@+˜€˜»~.ò>¥îÿã8Qè‰š ğP²Ú€Í_sÆF¥ÈY_µo‡[–dîP…£€¼	Óë>H¥DÜ‚Ìœæ=àı¢Qw p7ÛYÃ:J¥´ÛâĞOSx:P”6ó¿dìQ¥{’’Øğ¼iš °Pù€* ±º¥êğ´ÕøJú PÆA€´ÕøJ¥Û©àÜ«hşŞPk€Ò±Âòó‚¥R;ş?®v.( €APõ€u3µ„¥%y<©Éï„PA¢€çv‚¥WfíWÉú/Ô ®PÀ€«îô“{š¥5µIm~³„~s/PÆA€u/}ó¥Ü~Ï'v¶İŸ V|R9jÖ‘¦¥gŞkw‹/éj PÆA€kw‹/iº¥K¡¾’JPİÙôj PÆA€JPİÙ™Ä¥%“û*ñªÏd½Põm€¢ºQSâÆ¥½ZNsNYó0ŒP†6Ú>nFÖÈ¥}(yåy;{P  p:#˜nÌ¥ìÅËÌÈ¸6 j PÆA€È¸6ë¥yM£öbwªD P¼‹€ÚÎ“í¥|¹Sm™¬Ÿ% 
P²7€W¿£-ö¥îÿã8°9Á¨:JU€–€íã9Mû¦Íç,½Š«Õ8I#P  pIÍ¨ï¸¦ÆëÛØ3ó® LPW€wsÄAB¦AA:^‡|ß² 
P7€§Ù¿¤¦Ò¿€¨&¤ßD1† PJ,€&¤ßD<#¦ØåÈ¨xğ'‡ nPb·€ —ÀoH)¦¼5üÒ~´Áek PÆA€Ò~´ÁË-¦a#°ŞïpPQ€ ­T¯cJ¦'®9†]óÉ ĞPCø€'ƒ‚äÎo¦ÃL6kz¼ ‚&PĞô€›Æ7¸y¦ùFx2 ÊúÙ @‰[€x2 Êñ{¦ñk™ÅPé¾† P €ÅPé)¦EP˜tåS
Uˆ	P‘;€O¤|)¦5¾Ÿkr,ÚP‘;€é€„)¦îÿã8Y˜¼PUîˆR±5€À¡Ş)-Œ¦¢Dõ³èâfPh"€ÿä¯×½¦$á—C$	ÃO Pú€ rÄ¦ÿä÷ÜÚP5ÖPg†€ıwNjÒÒ¦ÑŸE´íŸ7k PÆA€íŸÕ¦¬_óéƒ~ú}eşPÆA€¢ÜÎ^Ø¦AÍk^Dc— HPW€T{ú»Ù¦EfPÑª«,¨ 0BP,û€\3º%A§âØæ(çf2Ï ¦
PM}€LCW4§#—òpTÅ š P¶K€pTÅ!§é‰·Ê¯SÒxGP{4ğÊ¨÷&'§÷\Î‘„İôm PÓ€‹°··3§!íÑ":™£İPçü °GÿÂA§ÉyJ§ô]ÿ PmÍ€J§ô]»\§N4^éú;b Ğ@MÎ€Æí$ ô`§ûNmNyWºWk PÆA€yWºoc§†CŞ˜u\ °PW€^*u¹h§&ëeGAg‡Q `P×ì€„£Oûòv§¼ÀöûA™Q nP{­€Ù¨¼­}§‚zNca|€¿íj PÆA€a|€¿…‡§À‡ç§K ¸Pc"€k¸	‡–§*PÜÕñÁ N3P¿€~›gP£§ùeL ëlO3PUê §-ÁÇ@¿§îÿã8Ï2Ø’g€P¡¿€šë6@¿§îÿã8Ï2Ø’g€P£-€è£–OÉ§;Û}¥oZäP”g€Q:ÅşÍ§rïÌÍ¾ò›§ üPÂX€pòD©Û§ÈR–Àâñ¨ÅPW€.±¤Frç§];U²+·s˜ú8P€4œ]ˆï§>-§êş± œ PÆA€êş±{ğ§âM/sR•é`•Pëø€iK–jñ§˜.HÈe>Õü  y‚€Ôc æñ§µ‹)W‘‰”^ Ê
Pã7…!?"õ§—ZqEÔš1 ¤P«U€jã·¨vLçrfXüH Pæú€çrfXQ	¨×~ªƒ8è^ÀïßP €ón’¨âcM°À&Px*€[Ê®E¨·-ÅZcM°ÀTñP’¾€¾s¨kÙ¡_cM°ÀÔ;Pp)€³ïëŒ¿¨PfË´d
£ šP;  pù•E;q¨mºÅJƒÎŞ{‹PÆA€™pb”ï¨ˆw¸ƒHQÀSk PÆA€HQÀÖ"¨d@»H¡›‰k PÆA€¡›‰ö,¨ j“:W|RAYmPf-€Y ",ş,¨ÍFlĞœ™Ôµl PÆA€Ğœ™Ô:¨QÀ)÷ä[FP <	P€º`r;«A¨*:Y1
¥IcBPz p9yê¢»Z¨4#¹»ùü `P.€™Œe¯)c¨/%ªuUæ °P×ì€‚ûËÉ‡c¨"Õ¯5}I% Â@£ ‘–[ëíj¨¾#ñÀ<Ôn öPS2€Òez5y¨ŸéJV
¾éa QPc&€çî&¨…˜t×Ä¯°j0i PU5Ä¯°jñ¬¨‚üµÊ"¡Hs PAÊ"¡EÄ¨ûÚoîe•O °P‘;€cÜ{ÚiË¨>¶*û‚½« 4PĞ€¦H÷Ò¤Ü¨¬_óé1¹—eşPÆA€ˆ6Íò¨`ıb­#—Åa PÖô€­#—Å<©L
+Ù=Ñ ŠP €¾AğPŞ(©mmw{“  Pºc€²ŸÖÛ2©ÿî¬­9æ ¾Pó–€\!]) 3©iíğÂŒl0d Pçü ğÂŒlÔ=©ınUØ(j PÆA€UØ(»@©
ŒXøVÀ@Ük @y‚€VÀ@Ü²A©²§@Z’!û8 ¶	PÌ€éšôcÒT©Ê¤"…r PW€RWˆ¨³~©şÏ–Áßë²° @Öô€Áßë²«©óö¢ÌáÔ¨…/Qw p‘ş5Ì‚’©QèwQ©Ã!¶PçŸ€¿¯…G›©(eCS0ñ¥& p@ç€vKJ+Û›©—…f E&øÜF”2@d2€	gœ©].Ûy¤œYŠXmP_d€öxh™…¯©¬_óé1õ*cşPÆA€½¾¢ÊÆ©›ãß%?TPI	  qo€¬²
 üÉ©«ÁËd<ˆ Pª˜€ÁËd<ÂĞ©˜óÎïŸ^Á©i PÆA€ïŸ^ÁBÕ©~·â#’Áã`UPi©€ £ët“Ü©c1%¦¸“vÉ „P{P€L O®ß©/Ìbê/Ceåh PÆA€/Cecì©}Ì~‹8† PÀ€–-„÷©~áN	 Ü Pïq€N	ZªK¹r–âÏÙ PPòY €€_’Şªîÿã8MZK ˆPm±€r!Mârª˜fN²A†Pº €(1vãjªá:Ò$Üí(»À‡Pî€mĞwjª·¥+GÜí(»€‰Pî€Àß/ôjª<­ÛÜí(»@†Pî€¤–?ß+ªóÅ¿78†»U ÂP2/€Yç#t1ªhğo‘zâkÈP  pF“BÕÖ5ª8o éŒ@  Põ€Œ@'Fª±ŒèIÃ´.Æ, P§q€IÃ´.XYªC†¤¤—Æ±^ @Öô€—Æ±JqªBôû(dÁ"\p6P  p¦/x„ª	G/"  Q;PÑ Ÿª±Ÿˆ6\!ıµ kÉQ o°ª$Äª¼Tñ¬´×D@ PqZ€ßTŸG·Äªó–†XQÄà…  0ò€ô aÜªüùWËyß(GP  p>íÏ}ßªô:cH4JÎÉËPB®€;afëÿªÖ¬qÕ4´k{ 0D	 H• y	«päJú)wì †@ E  ¹Âò«Là&Sª•¬/„‰ PÙu€ª•¬/«`LĞÓûJÊ   P4» ÓûJÊ«VYçál÷:ñ   P4» l÷:ñQ«æÖõÃñİhİ  F	 Èì ß"«¦iX\P)ûgÄıP$j€Ùxª!İ2«	Ñ+QGçV%
PÏš€¬ã/|sE«|Hö’fÚ º=P<€Có`sE«|Hö’fÚ FPĞ0€·k<{sE«|Hö’fÚ 6KGPĞ0€!OÀsE«|Hö’fÚ ô“Q<€ùTCsE«u¦Ú’fÚ nPf6€g“ÂE«îÿã8V‡Õ `P	z€¨YëÆrO«ÿÃ×{.Ÿ+4 PÒF€{.Ÿ­U«Q q¬¦N‡— 0­ ğM W«ÿî¬U~åá ÔPÆA€iˆÅD¢f«¼øÑmU3ŸV ^PJk Ae1ºt«-n‘Ñ¾ÁòJxáPŒN€t»ˆ rz«ñ¡äÕE 4@³ö€Šo‚}«&éÂqŸM¶Ài PÆA€qŸM¶”„««3ç_ı0@Å€çÖŸÿ’«(KY„ïOœ«l PÆA€„ïOœÿ’«ìÅËÌ”|¾úi PÆA€”|¾«”«ûNmN_%éµak PÆA€_%éµìŸ«¾ şQ	€˜ÂQH9¾³fZìŸ«¾ şQ	€˜ÂQì6¾³fZDÈ«òĞùÀ ¡g NP&¢€qqÕÎ«3`ôDùòÁZWP;:HPï&Ï«jrM"/e¹ˆ PJ,€M"/e¾ğ«CaêÖá Màˆ@£ 0}ŠÀ†ñ«ˆ¡»š¦ó¸ğõQw p£ÚiÁN¬îÿã8iC¾à¯P˜5€Î\«N¬Ÿ!NØuT¯XàŸ @>x €uT¯X¬(1O¾ÖéÜ• 2
P>ğ€+(-rà,¬0YRÎ®›ÓÀ##P  p´Âùá4¬ïş2¹~(† 0PÓ€ªä+Ï<¬ûNmNŸ9¾ŠTk PÆA€Ÿ9¾Šç\¬º2}Ï%ÁÔª(9?0cF ca¬¿RÂ(1vãv› P €(1vã©p¬©)X®–:to @ r€®–:(•¬ Ì 0]ßô(ÖP  pÏ0 ¬V‚r$Ú}ÈÕP³ı 2‰k<™»¬ÆÔ©ºñùÿÿÿOõ€(Â ª½¬Lè’óVGÛfzPÆA€ë â^Â¬ÁcÁ-§( PPë»€ÎaPiçÅ¬îÿã8RÀ£àò@í6§'‡ÌµÈ¬6vÚù!>!· ‚ Pî€!>!·:ë¬ˆw¸ƒY Qk PÆA€Y ï¬VY½Faòp‹ P4FaòÄğ¬öâÓ82•eêçPÓ€êAÑó¬¤8˜™O‘‹ PÆA€™O­îÿã8×zûR@ıP*ı€XF%¿¡­=ÃxØ3PoĞšMP_ a
1_A­*RfŞRpƒÎ PJ,€ŞRpÁ­ıï(`ôe—Î Pò¢ +’Ô3è­.4¢õ É7 ŒPW€şsë­¤wÇÂxŸ3ØçPÓ7 ¿Úâê-­îÿã89_ƒ rXP×r ú,½x­/­&éÂ9‰9¼i PÆA€9‰9ÕY­L1P;k£d`HP¾3hã¹!~­òïØN…ÛÀ ŞPM@€å»Çãˆ­MKŞÍ:"@ßt î^q‰­¬Î½Ö$v@Pºû€®~9Jš­ÿî¬…E 6P‘;€Ğ»	¥Ù›­:¬C>S®Í„P€4ñœé“8¥­)E/ÿ‰ÑßÈPv€æ¥ÕT‚¦­ª€$°~±nÜØ#På³€2`}‘q¹­¬_óéd¶ßgşPÆA€?í?ï÷Ç­y”ÍkÅ$ `Pá{€+æG# Ê­îÿã8*^8 JP€øËæ# ®0ŠêRKpH0l PÆA€RKpH# ®x*+½I
ñş^i PÆA€I
ñş®@bÌ¥yÿ³’ tP}°€ÑR”Ñ®ìÅËÌµá¥õi PÆA€µá¥s®è˜Ú9ZÙ±B P €9ZÙ±¬!®.ÔVíÖwk) tP‘¿€	¢Ç°€-®ìÅËÌ0ƒ­*ÿi PÆA€0ƒ­*•7®‚3S9ÅOyÙ H PÇ1€ÅOyÙ<®Ô*(!šô ’Q¶3€õÜşÜP®ıÊWÿBV6H¬P  pËÌoƒc®DjœÅb‚nùËPÍ)€£Ë±Àáz®:Ü„´FC.^Puy€¦Œ²êŸµ®Ç(h„£ İÎ¢¯ PÆA€£ İÎ{¾®ìİağpË}µ)`PÆA€>KøÆß®/(Ë²ğ)‰5ˆ@£ 8y£Íí#¯F,’Û”6C jŒPx>€Š™€TÁ'¯ŞïÕ©³f´
Pw9€KÎ(¥-¯ÑÁŞ“HÒUhi PÆA€HÒUh¦/¯F»ú¢&º6¿pDPÆA€C,ÅÍ0¯„€ã<
u|8PÓ€Z”½9¯rÉeì²³z´©ÚP|É€F\z~³P¯©¤­•=ÜÇ ¤PÓ€Poé¥W¯ujÁo8 ĞP¬< ú¤‰+×Y¯š/r£pgE ø@£ ûw±¸a¯â|äÅ¡¤ ~ 0v€0! r¯$í‚a_Vã‹  P¹Ñ€×?vw¯²s»êÍ  P{­€tJh€¯Ex®…üüH+@£1€ o,ã¥Œ¯œî-ºçs‘
§ 0K°€xé œ’¯5Åú Áş[wğˆ@£ Sâ›¯e}“œuü H@¾€ñPxl¨¯Ä‚Pòå¾uù;P{ø€;Šµ.Ô¿¯¤§ £¾f ì@½€öFŸğÈË¯¯›i¦n©(ZPğÿ€^ë{ÔÖ¯óÿMOiÉrÛ‘ 0›ü€ˆ Ãà¯¥J¢½fRq p Pê=€½fRqî¯,Ş›AVç  0ß5€TÎ xú¯Ûš-Ì³¤6 ¨PÆA€‡®‰|—°±ÌGHù¹ ØcU{­€l8éÂ&°‰Üh^FÕ ¾P®€ŒMÖ*ğ°şnÊ`x¤ ğ÷P  pOóh°HpÒĞÈ·gÌPša€Ö¡˜›JH°ì{8çÚ(¾j PÆA€çÚ(lM°<C#ü„Ìo\_·HPÆm€ozQŸ}°Avğ¼ÒÂÉXd'PKø€²ÏÑÖt°dT'ÿXï ÂfPc†€Kú0¾±†°ƒUƒÅ8ı ­	PK€'
Pı>°Ö‚Ú”s*¾‰ PJ,€”s*Ö°2‡iu9T«)Tk PÆA€9T«)Ö°(KYæk‡§l PÆA€æk‡Ö°ìÅËÌ=8`öi PÆA€=8`k˜°rÓq?RÍˆ@£ õƒÛL¢°ûNmN(É§]k PÆA€(É§n¥°ó4&¸Ë\ TPƒ€™02ƒù¬°F,ø&¯±Áº @ PøÓ€¯±ÁºøÀ°—ŸIÕRG 6H&P  p8Õ&Å°İ ÂÒ˜ê ÎA)H€ä}öUIÇ°\åP©{ ²P7€“ÜÖÆĞ°³l’w‚a ØP”€€õl;€ÿæ°BƒšpÛ6 P€[Öùôü°i"º0ŞÂm ‚PÓ€V¥˜ş°*ˆ7E:Ê`r°¨Pi©€}S õİ±L,)md/%×ŒPb€í©eïÒ±>ƒ0f¸ J/PÆA€cR&‡·±+«Ó=›Ñ˜+6 D	 \• ~±`ÍRVºxD ÀP¤[€iüş±KFÛæ·s»Ê ZPW€¹RË>‘"±‘rúRZ£|œ:ƒP?§€‘+Q¨(±ÜrSR–<i¹r¦8Pßr€Úí&3±[aïïWp"‰È‰2Qw pB°¾=^±cî	[ÚÌV  0›ü€œ ³p±xê§ÄàÅÀ' Pí §ÄàÅ¹z±]9Ù«ÖÀğ—İWS™€İÔË·~±]À˜ÅÌ|î”àP9ûêCH€±ÀO$ûÔ—q­Ã P’¾€µß
‰±@İIkK€	 0ÆA€X‚ 5›±©3¾[àŒÉ\f 0æ™€¸Õ ´±c£r¿bë ³¿H	@£ >ÄNì»±¬_óé$]NlşPÆA€×úpÇ±9ƒ;†&|Õ BPW€.ƒÈ"7Ô±ôÀD+’­^LX}P  pâ¬ç	à±ptÓPT»xü	P'‡ àN­Ì¯õ±µó58€ı»PPº€µåDG÷±a™gêk z@Ì€â£z÷±a™gêk zPÌ€â£z|ı±•÷Q¦Éô®X…PJ pqƒáeÍı±HãŠÌ"  @P” €„Ë%²7µO’§ÚÍ@ÜPO~€ıíJŠ.)²eÃË	ã{"jP €Rqü8²!ŒüÅLä:L¿   İê€pé ò@²Äø5şO@ú0P	  p…Ã™F²Öù—_İ $P‘;€	1õçSL²î<Ãìëï× bP5€q5}$V²­_Ü¦NÀ – òP)»€Ç[ò¼¼Y²§GÑÜEÊ‡é© PJ,€EÊ‡é»\²~é£!“ßÂ| P P,×€“ßÂ|‡l²*äê(ãf
)8™Xz pœöïü‡l²o't>ãf
)z%Ai©€ Õ½ë‡l².Ü1†ãf
)İZVSĞ†€ûê§ß´s²êã8ÅçmÌ½ô“ÚP;€@M!Ÿu²ò»õş%…½ B PÆA€%…½[w²é KPÈÊ‹œ ØPÛ6€I>Ç·1€²Îä*ÙÔŒ º&PGÓ€œ]B{½¯²uø\¦I„Èˆè0P  p2+ê)Ÿ´²|oÎ„·\¡P'X€¿o¸¤¾²Ó«+îìäòkcj PÆA€ìäòk;¿²6^ÊææáL0P`<iJÔ–Ç²úåÊ»Q;{Ÿô­ Pí‘€Q;{Ÿ@Ú²º4C=ØD  (Ÿ€p* ï²/ªÃtŸXq‹ xP÷ô€—»©¸9!³¶¢Š-Ó RPm€¬R¡İ#³Ë.×»´I 6PEk€ˆİ.+)?³y’ÛeÄıe) ¨˜PÒô€Ø-6WB³
¸k¿™‘àõ $	P{P€‰KH³2‡iu.]œ³Vk PÆA€.]œ³KK³°O”†Ä¨UH€Pb¢€ÁÑL¦W³‡kÚ1Rx@Ú0Â PD€Rx@ÚÍa³4eo ÆRæ ($PÓ7ìÿ°`g³Í
)Lª?2 º P;  pLª?2Åx³(RˆY9ù< *iPi(€¨ R‰y³0»?¬·: ÀPxc€ÖR³„a{³·›Ë Ê} ¦Pk€]sh’qˆ³&éÂz¿i PÆA€zI™³ÖM|-‚È˜x 8vPl;,œg†ñŸ³Ø²%(şˆtıÇB PpÃ€şˆtıy¤³ËŞáZöl¨PU^€eÚº¤³(KY-ÍÅ!°l PÆA€-ÍÅ!Ä¦³‡4†}+;=P¶š€ÀÕFÒ³²‡İMxlOPl PÆA€MxlO]Ø³‘šVŒ$û˜dP€¿ìtÚØ³Œ8R~sß÷#YlP~€&š¬ÌÙ³\oáPæxÆ³[ 0ïq€è" ­ä³¤´òd® Pl€àL¸õ³Ô¢O’é¼… 	@Aø€FûVLõ³Ô¢O’é¼… 	PAø€FûVLi´&éÂq'7|ºi PÆA€q'7|û´^‡Ÿ˜Êê3mÁÂiP¤G mÉ­¿´PÙ»¬}ı0 †P·4f›¼e$´Bæ7~*UN5 ŒP‘;€ ¤!jl,´…¡ı.“¯\â ”
P˜¸€Á[½#c´Ÿ¯k°A8k PÆA€k°AŠi´&éÂlJC2¾i PÆA€lJC2Şk´ˆw¸ƒÛö~íRk PÆA€Ûö~íJ†´ãugg8mÔ÷i PÆA€8mÔ„‡´Õ:F¤–¡ä NVP  pùº^‹´ÒOÚ©¸_ïÖáŸT'4Ä{?íùWé¬
µ$X½`P/:c8ºPÕX˜<¹R•Ä äP’Æ€ËíÀ¿ÕX—Ëı|¸7œ»  P’Æ€†7ã
ÖXwg“‹vEE7&PÆA€aÅÖ(X¦í¶±®Q‚Ä †Pğ{€Ú2]~4XgŞ{^
Âõj PÆA€{^
Â?XÏü¶l=±Ïò ğP€Ñé¶MªCXiµ]ÍeËHùOl PÆA€eËHùÃZXÊoÒÎé˜»\ œP€¹×ãsfXÊıë©R>î fP„!€tè6«vXÇŞ/H•&íìÅPÆA€‘, #wX½—­‰P»Hÿ¶@õ€'S»[^|X$ƒ`õ§B	 xP‘;€J®,ù¯ƒXfµ…y0VH 0ô9€4¼ ß‡X0}ë¯É_âÉ…PÔ&€&—Xßó¡¢i›g	 0(Á€LØ 7”X{p«‰=ÄÀdğ@#‘€Ì³%ƒœXÿ²ÙO„t ğ˜P€"€í•¹×0§X…–§ûê…Í€YPJê€Â»oz©XûNmNb<Â\k PÆA€b<ÂÙ²X äCifJùpÑ®P2?òkë…³Xe·kFò7¯Pä§ ºÇœAê¶X>=Ê_¶1HğP
 æ|T±™ùXC¶†
,¬w Ğ P’¾€
,¬w¼ùXÖ[ …VÓ¹ª VPNÇ€Æ'Ôq| Yğ;êêú™ PB®€¬kZŸ#YU/B\šgX ˆP?S€±¶MØ_YJõ3‚ÈÚ´ÿÿÿ_Ìö€<Ù K Yè6—ví¬Á^Á-P€`òı(Y¬_óé×­7ÕmşPÆA€1‰õÀp0Ya®ÙSÉÂ„“ÀŠ{Pw p$t·ô„2YµOHN°û¬j 0‰#€°­	 ø5YóQPí®H=eš† PJ,€®H=e¨6YJop$!  P^Á€y®í«Â6YãÚ„áˆû‘ bPî€j0×#?YÂw±Ò
Ù <P#²€E,€İBYR?|‰ãöõ  à%Pl€R&¶aDY„óÎq* i¬ r
P €s"ĞèİHYîÿã8ws| [ù_õ€4	ı‘âJYÜß=B¬8CÆ ´P7€œ^yWYu¹öÃñËˆ 0«¨€< [^Y¦?˜İñún˜ºP/:.ÛğjY²áÑŠiTPÓ€[u‰ÜYMTµË¹9°uAPÓ7/„ÕeíY1õ^(øûZT(HP€6YÁ ŞïYÃuş0ìÅlŠÌÀ P/(€ìÅlŠŞïYmvÆ¢Şƒ>¶:ÄP;  ph9ã<õøYîÿã8Xá>ø DP×n€oy»Z¬_óé53maşPÆA€ o	Z'¯„êİûÈ Pñ êİû¦ZWVÈ«ú£ˆË¿d Pı™€ú£ˆË°Z2hM¥'ØE}8Pó€I©ñ/&Z¡wirÌš°A&!E	 pï û2Z2iVğõÛa ğ P7€õÛaZDZY÷]ç²}_ ŞPŠ4€7ÖPwJZoW;bDÉÙ Z?P€6&ˆ¼~MZ®E¤dôé	 0ÆA€0‡ éRZ„!İ¾Ú§½A P"€“°#\ZŠ^áb`ëB bPi©€vïf	™bZÿî¬Ş,ü ìPv=¾‡^ÃmZ/ë™¬nœõ |@ßt š/ •ÉpZˆw¸ƒ³ÍÖJk PÆA€³ÍÖáƒZßki<Á/ >Pê€äUU’h”ZgéƒyÚ“Ë ZPÆA€®O”\ƒ¡Z~Ş›ÒšÜK‰@£ °è¢4­ZÖ±.mÕ @Pg€‹Ş8Ã»ZI“o‡ÂV 2PåÄ @J]Ã»Z^uƒóù2 "Pß¼ n¿Ã»Z^uƒ@9Ñ "PåÄ æ‘Nş¢¾Z²¤ïûËÂH0P  på	°#ƒÂZÎ³ÿ=¶VW#3Á“P<€¢<ñ¡ËÊZxÇûCØ!@D	 Õ^®DÒÑZÄíÀ?@(P‡ €/2¡¤ûíZîÿã8¾wv@ VP¥€€™zùá[%i1nPgÒ” „Pzw€7ïz[sNYãÄ&@÷P Pô€ãÄ&@Z[ş¶ã+&_ô 0a9€¼H ×S[uû¼™-$ F@i©€\OG¶([[ğUÀú ?e6p~ P¢4 ?e6ã{[*¨¼‚(##|Ş 0œù€¬- PŒ[pşÑ9ÚÈÊ¼ ºP|É€s=Á¥Æ[òäïaO« pPc"€sÖ¤fĞ[¢X¦äU½ šPÓ€]·0gñÙ[eQÙşFŞ¹³ dPÅf€­ur½üö[A••/¨öUÖ P“÷€Ëî3ËÜı[îÿã8pÓåLŒ=×B½Y€1·é\½÷ŒıKe	‹ è
PÀÇ€š<ÿƒ\ö¦}âCéÍ}Ê P¦v CéÍ}O \§Ü[ÑŠ?ª PÙ«€}„Õµ¿5\sZBWå— Ñ
P/t€…íošF\š“2ìò¬E „PW€?bSç¢K\ğÈT¯Şzw `Pì‚€Á-÷>™l\&éÂpYºrµi PÆA€pYºr&s\ 
‹0]x şP>ğ€Ù£'×^u\ûNmN©XwZk PÆA€©XwÇu\è;©}‰&v 0œù€À- bz\¶¢/€¥% 6Pm€¨S_W\Åšáêón ê@/€eÆ/äı\[”6á(h~GPá§ Vr¡k£\vùşø§c v"PÓ€ˆœk°\!ò¯˜'Lˆ@£ U±ÜO¼\¼5ü—ñ9_k PÆA€—ñ97Ğ\åŞ'B"© 
Pëø€1¬0G=×\aG×şß@: 0™=ğ ¨Ù\íKq-é¡ˆ@£ „ş„íËä\[âAúå b PB®€úå•ğ\·§ó¤é@·,P½3³&®]MC€o+<JX’3P  pĞv"—¸]ƒBÈ±tH-P  p$”M‹†]¤›^œ×H/E àPä'€éäVb#]C~qÌUÑø<`²PÓ7òš‡>%]@RjêudKô rP)H€yq	#6+]5ß•œüq˜P6@Ü°Õ¡;A]}-}¹¹xaP’¾€ã(ÓO]iG§•Äx8Ğ$ş Pí‘€Äx8Ğ@Q]&éÂÄ÷#,¼i PÆA€Ä÷#,]d]ÄSıF@l úPz pŸ\…g]ü‡SuuÆ1 Pºc€uÆAt]ªQ—–8?^È’ØP  p@AêAt]ªQ—–8?^È’ØPU:@Aêa…]ôùšKŒ˜©ğ ®P`b€f¿ğÎÍ‡]+*qİÒ’ÁzcNP{ø€æ3j—e¯]ûV>«÷j¤ãèŞP€6z†b‰¤¼]Œ™>"Ï?ñäÈW2Pn5î†”ZEÛ]kæ1x°8àPk3€·AÓİ]ùÀÂÿQgÊYP9É»lZòİ]BY;Š±±PJ¦€©2“°å]
•)§›*p Ô	PàS€*ô}ï]€­½¶‰(ïpÏ<P²e€t¼ˆ$Çô]„kìûÁŞ•x-ûPÆA€c:¢=^kÉ*s©U&°¬T¤5­_ˆ^&éÂÙI’Åi PÆA€ÙI’å^Ë6´€Ÿ¯^ŞxoP—6,d ’ö.^§¤ƒ²U1d%S  (Ÿ€D. 5A^Yˆˆ±Šá4 àP×ì€‹Ã£c1G^Jï[!'gÅİ  0ß5€¤Î ^J^#èáK]7 ¨P8é€¼s¦#çb^U¾6Dnú0ñ ~P@!Š€¡Y@vlƒ^îÿã8rim® ğ
PöÓ€£rR”„^»ZnMfj¹– ÂPæo€î0Š¶Rˆ^Õ>¹"/Šls Pı™€"/Š5”^37Ü{¬< XPGÓ€'x5”^37Ü{¬< XPGÓ€E¾Ò5”^37Ü{¬< XPGÓ€FN=5”^37Ü{¬< XPGÓ€HæHº5”^37Ü{¬< XPGÓ€MMùc5”^37Ü{¬< XPGÓ€ZTeA5”^37Ü{¬< XPGÓ€[9I5”^37Ü{¬< XPGÓ€\ğÖ²5”^37Ü{¬< XPGÓ€l{¬5”^37Ü{¬< XPGÓ€nçİ:5”^37Ü{¬< XPGÓ€”R5”^37Ü{¬< XPGÓ€Ï5”^37Ü{¬< XPGÓ€ÒãS5”^37Ü{¬< XPGÓ€Û§ù²5”^37Ü{¬< XPGÓ€è4°V5”^37Ü{¬< XPGÓ€ò}ò5”^37Ü{¬< XPGÓ€ü‡¡¼¤^iµ]Íl™;İCl PÆA€l™;İ8®^²‡İÿ?¯;Ml PÆA€ÿ?¯;8®^2‡iuj6ïĞck PÆA€j6ïĞk¿^†FTÊÀcÛlA°¼Pjo Œ­Ú×ÆÍ^&éÂ¥ğÍ½i PÆA€¥ğÍÁİ^ñ« ˜>ØØ® PÆA€>ØØ®Bæ^á÷³#z ¤@Ñ  {g-ó^[E=¦›$ à PÏæ€¦›$Aô^qÇØ^bëCe‹ PÆA€^bëCS_]Zw‚ŸÆhÃPz4\u}¶_á­Ğ¡6²ÿÉ ,PB®€ÆgæEk_©±CòâéğÒ
P©Ç éLcçã#_Zİ°-Şı ŒTP1š€Ux5Œ¢%_&éÂó?‰Ìi PÆA€ó?‰<+_¶¤Š¦¹°ÏğÜPZ5P‚Q&eE_~e²x²oÑ Ä P<€²oÑOG_XmZ›$u4â ŠPÆA€yÈ¡R_¡…{6¿g1= P$ p6¿g¡R_	‹CÈ/®èR P_€/®bX_–ß|¼nIş ˆ D	 üš »[_ìù¡ïXQj PÆA€ïXQz]_Vk‹~„‰nÌ.Pc€wW§¥h_©ûb„OÈy; yP#²€^â2Urm_%¶ÆAPV¾qÿÿÿ_t€¸9 9‘_ãûOÇ„"ğbyj PÆA€„"ğbe®_%Ê&É¶AÍó­ PÆA€¶AÍ„º_'öQİoÎ`|P~4„qqSÀ_¶—‹à¦LÈs n0Ag€å9ÂK¤Â_EĞ,åŸ 19`PÆA€NÏ)ÉÄ_¤wMİ=Åè 4	PUX€i%§ÚÆ_‡,‹mœÃ>Äi PJ,€mœÃ>6Ê_ÍFl_‘à²l PÆA€_‘àÜå_¢#¤½I† :@P	  p"á|°ç_4KİcdXjK¤ PÆA€dXjKœï_‹Xıgë’ò¶‡„PHh€êî»‘)`C‹r‹ßóî ÂPÜI€˜´ç»Z`BğĞ@5=’ßxL;P€6¢i&`ìù¡‹TUj PÆA€‹TU\E`$_w®†œùPıÆ€›å7t§H`ŞhŞ±v¶Ú@®j PÆA€v¶Ú@``ÎÏê)@ 0ÆA€D‡ f`/İ¡!,&±Q &P?S€™oë"g{`m^w·DÍ üP?"€p~`ãugg^3#Äïi PÆA€^3#Äã¨`½¯HNmzª Š @Ÿ>€mzªµ¶`ò%7 qÚK}ÁPÒô€¶³„º`ÙõÒÂ9E7ĞPP©÷€Ü–(2Å`% .Æ½Fìdö@hü€šWanÇ`ø^,h]y«ÿ B	P“Ã€nÇ¯çí`JÕ‚gD
œç ÈPJš€WÿDrù`³SÒ¹yô°ÓeP {€ë‰¸ù aªU9‘ı
S k PÆA€‘ı
SÖaÿî¬»5 B bPŸ‡€nˆAaE›İµ§ VPw&€]@½ñ)aûNmNV Wk PÆA€V ^5aãûOÇ¾¾D”j PÆA€¾¾D”&;a4¼%]ÕÜˆIsS-õ€Ì·>1@a–¢ÇX…Ü¹Qº PJ,€…Ü¹Q
BaªU9níÙl#k PÆA€níÙlüFaÁ‹`	=öØm•
P@,6İE´œ`aÜ:%Š’‡“ JPÅf€WÛ1&cazŸ6)*3ñc ÈPù€AôÄ„,gadO¶>*|?6 ¾ P€*|?6ia'–jA°·Ôä4‰@£ EÈï‡Ytaš?ÎMÖ†Ü D PÆA€MÖ†Ü:¡aò<àÂ  PDo€u˜³©:¡a2^íAàÂ  PDo€š”Ëƒ:¡aÈ®;]àÂ  PDo€šL:¡a|ğ1_àÂ  PDo€ùöÆ·:¡aàİ§fàÂ  PDo€ù*xh:¡aYÜßàÂ  PDo€c
ñÔ¾ªaüÔÜñ_©ññ? PÆA€_©ñú°aÊÁÔİ°ænG 0 Pe€°ænGÆÓa1PÓŒÅQí Pw(€•k[ĞíÖa¨"”ÈX6 P¬“€ÙÚå«§Üaîÿã8Œ™Z  PŞÿ€œC„‘ãaˆw¸ƒ¡óTQk PÆA€¡óT(ùa)	åKÔHİòOLP€"€>™^bë¼
4¨Ú ôÈ>P7€ÔØPb=ßDf¾İÆ; <Pã›€¤Ú)#9bêz©i„B2 0€dO	 P*b%›‰Q]J J^P¿-€9$Í»P*b%›‰Q]J J^P¿-€O6€<P*b%›‰Q]J J^Pº#€dµ¯'P*b%›‰Q]J J^P¿-€BlT4b‡†É¶8Ïyp'
P  pG±ü'?b~”oª½V Ì PB®€½V-pb¦Š´Õp]eg@ºû€übVÕYƒbzƒe` Õ'	 
Pm€—ì9xc…b†È×mËÛài PÆA€ËÛ‘bD©¶„Ø´˜Ó+P»ñ „Š`Wƒ’bŠª©«¹"¦e  (Ÿ€X. _–bğ¢†*¾ €-@†– ÷¶[šbÿî¬íƒï úP‘;€Â^*·b2­×½ÕIÑ :PW€ˆÔDdÄbÒú6ß‚pØ÷&Tw p·ƒ¬Åb_$÷:&½ü  P±€:&½üPßb<Æ	ã)w hP8€Q3¤Ğíb|ÓønpÅ^*r PÆA€pÅ^ïb!üùXÂ°¡ášª@óÒ€Ú¼ıöbˆw¸ƒÂ½X+Lk PÆA€Â½X+¶csg±I+ş)XAP;D€*JxÓc…5’&İQJ™·PYÆ€Àß3y)c!>Pƒbà "P¤€-0ı}6cÅéì•ºGˆªP  p›‘TBcÓ«+î|¡Vıaj PÆA€|¡VıàNcçñrÜ ™L¹ ®P#‘€eïtOcM”L-ÜwÉ­ 0Öô€Œ Xck¢Œç« ´PGÓ€ûG"Ync~ ïèªê‰ P¬€ïèªêwc%¶ÆAüÓcŠ ÄPh€Ofa´{c…¢Z¤-ºEˆ ° @i©€-ºEˆ€cÇ”Œ)³Š6 e @hü€³Š6 €c€b^Í”ßù	@hü€RTMz“c2‡iuùø<^k PÆA€ùø<z“cìÅËÌÛï j PÆA€Ûï>c‹p<äóÆìLjPg†€†kt>c‹p<äóÆìXjPg†€â¿î³Ü¨ca#O6(\®¥“Pg†€“AĞ5F©cÍ…7y….+§PÆA€îïiz\­c·ê/ª«¿ D•P…€Í¨ëË0¯cĞ¼ø …÷Ÿ$P+†€“ ßöÄ¸cŠ2È(Ä7À> P…€Ä7À¹c­›ê%öçj PÆA€ê%öµÊc-ÅÜ×æÃÇ(³P p¼qt,‚ëc³¡‚õ©@İD @ìª€‚õ©@qîc”¦úô¶œPåPAdİ5[ıc‡ñoé/o_Œ 2Pù€:câÁd5]©S	´? PÍ£€Í,fLY
d&éÂÏÉz½i PÆA€ÏÉzädrİ:”u]“â† PÆA€u]“Edmø&au¢¤ vP0¦€>fÛé(d15Á}Ğÿ>  Pé€{š2QL@dš)HÁH’§fk PÆA€ÁH’§PJd½ì“ølSI DPÄ«€87«ødMd­fó“
œ Î)Pl €tf4Khd²ƒç3ÀÈA üP¹Ë€"‹KJnd¥­GZŠVÆ¬ö 0ª€è »°dá\îÛ%2xğ÷P  pÏnì¨]±döCC¨ØÁ;  €xO	 ì±d÷–Ì•®¿PÆA€u(Îİª¸dpª¬kM	 :Px>€6«2¸¼dûNmNÙq^k PÆA€Ùq´Ádc(^Ğ³ª¢¹kŞ PÆA€³ª¢¹××d?†Û£ø;Š –Pê-€(S{ÔÛdæÕ
}V$ æP]§€¹H_åÈõd¹j1¯Ì" BP×ì€cÔ¨ı÷dêú$J°A	±PÆœ€9ÕßçúdOĞí¹Ğ/­‚PÌP €º÷&ûd6¥ş¢½FŒw@ø€8êÕPıeXÀÏÎB¨ P¥€ô§¾eD¨hc6¼¸AÀP=€Ï¾íÓˆ!eŸhMÊOáB± P…È€9ÑwtX&e0GÖqC³µPH©€Oìº±1+eøZ7ãÄü•j êP‘;€HR	´i7eÉm<'"Œ j”P:F€†Ë÷…Eeå½š<‡( 2 @¨z€‡(YYeZf³ğ9‚gl:P‰}€L¥
Epe™–öÏÀc9‰ßª PJ,€Àc9‰¡eó{8@ÆEœ²}PÆA€!è?ÿ6Œe¾¢%!hZ¼p5
P¤[€»¼gÔĞeÅ®zI¢ãØ Px>€ˆ%êe|–eîÿã8nÈ7­ÿÿÿ_Œ€T§ |–e*4)XnÈ7­ 4šPŒ€=åaô—e&éÂã¸9’¼i PÆA€ã¸9’–›eğ#SÄU§¢ LP  p‚U`b¡eĞKRâƒ3|‰@£ "Ù=#¥£eár1ˆÅá)Å ´TP<:	"<Ç¬eûNmNdÉ¦Yk PÆA€dÉ¦Äôeì¦c›¾n¸PR	P  p%ŞDimşea¼A¢b«˜EbP€"€o~5QfŠÚÚµY% ÜPh€’©h+f&éÂ½%xŸÁi PÆA€½%xŸ#QfNö5hW×ñ ( P˜¸€W×ñuQf¬_óéÖ€pşPÆA€ûrÂ>Wf³Nfw¨(XÄš Pg†€¨(X`]f-~…?‰Úz \ P\@€?‰Úz=^fåwkXttdXL@Éz€şz:ä=^f0?ˆ,XttdØUL@Éz€öfå=^fH×¸,XttdøXL@Éz€B¼O=^fÔú1XttddLL@Éz€é+¿=^f@	ÖZXttdtNL@Éz€irC=^fŞËòcXttd¨UL@allbackInfo);
#ifdef NAPI_CPP_EXCEPTIONS
    instance->_construction_failed = false;
#else
    if (callbackInfo.Env().IsExceptionPending()) {
      // We need to clear the exception so that removing the wrap might work.
      Error e = callbackInfo.Env().GetAndClearPendingException();
      delete instance;
      e.ThrowAsJavaScriptException();
    } else {
      instance->_construction_failed = false;
    }
#endif  // NAPI_CPP_EXCEPTIONS
    return callbackInfo.This();
  });

  return wrapper;
}

template <typename T>
inline napi_value ObjectWrap<T>::StaticVoidMethodCallbackWrapper(
    napi_env env, napi_callback_info info) {
  return details::WrapCallback([&] {
    CallbackInfo callbackInfo(env, info);
    StaticVoidMethodCallbackData* callbackData =
        reinterpret_cast<StaticVoidMethodCallbackData*>(callbackInfo.Data());
    callbackInfo.SetData(callbackData->data);
    callbackData->callback(callbackInfo);
    return nullptr;
  });
}

template <typename T>
inline napi_value ObjectWrap<T>::StaticMethodCallbackWrapper(
    napi_env env, napi_callback_info info) {
  return details::WrapCallback([&] {
    CallbackInfo callbackInfo(env, info);
    StaticMethodCallbackData* callbackData =
        reinterpret_cast<StaticMethodCallbackData*>(callbackInfo.Data());
    callbackInfo.SetData(callbackData->data);
    return callbackData->callback(callbackInfo);
  });
}

template <typename T>
inline napi_value ObjectWrap<T>::StaticGetterCallbackWrapper(
    napi_env env, napi_callback_info info) {
  return details::WrapCallback([&] {
    CallbackInfo callbackInfo(env, info);
    StaticAccessorCallbackData* callbackData =
        reinterpret_cast<StaticAccessorCallbackData*>(callbackInfo.Data());
    callbackInfo.SetData(callbackData->data);
    return callbackData->getterCallback(callbackInfo);
  });
}

template <typename T>
inline napi_value ObjectWrap<T>::StaticSetterCallbackWrapper(
    napi_env env, napi_callback_info info) {
  return details::WrapCallback([&] {
    CallbackInfo callbackInfo(env, info);
    StaticAccessorCallbackData* callbackData =
        reinterpret_cast<StaticAccessorCallbackData*>(callbackInfo.Data());
    callbackInfo.SetData(callbackData->data);
    callbackData->setterCallback(callbackInfo, callbackInfo[0]);
    return nullptr;
  });
}

template <typename T>
inline void ObjectWrap<T>::FinalizeCallback(napi_env env,
                                            void* data,
                                            void* /*hint*/) {
  HandleScope scope(env);
  T* instance = static_cast<T*>(data);
  instance->Finalize(Napi::Env(env));
  delete instance;
}

template <typename T>
template <typename ObjectWrap<T>::StaticSetterCallback method>
inline napi_value ObjectWrap<T>::WrappedMethod(
    napi_env env, napi_callback_info info) NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    const CallbackInfo cbInfo(env, info);
    method(cbInfo, cbInfo[0]);
    return nullptr;
  });
}

////////////////////////////////////////////////////////////////////////////////
// HandleScope class
////////////////////////////////////////////////////////////////////////////////

inline HandleScope::HandleScope(napi_env env, napi_handle_scope scope)
    : _env(env), _scope(scope) {}

inline HandleScope::HandleScope(Napi::Env env) : _env(env) {
  napi_status status = napi_open_handle_scope(_env, &_scope);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline HandleScope::~HandleScope() {
  napi_status status = napi_close_handle_scope(_env, _scope);
  NAPI_FATAL_IF_FAILED(
      status, "HandleScope::~HandleScope", "napi_close_handle_scope");
}

inline HandleScope::operator napi_handle_scope() const {
  return _scope;
}

inline Napi::Env HandleScope::Env() const {
  return Napi::Env(_env);
}

////////////////////////////////////////////////////////////////////////////////
// EscapableHandleScope class
////////////////////////////////////////////////////////////////////////////////

inline EscapableHandleScope::EscapableHandleScope(
    napi_env env, napi_escapable_handle_scope scope)
    : _env(env), _scope(scope) {}

inO7­¼/HP»5€Ÿ]€¦Y?¡w ˜Pä€q58ò¦Y÷]çzsû½ ÌPŠ4€c×àì#¦—ò˜åEùZà_'Pp<‰"2*…,¦0®„ŠW@Òç¯P†6Yv.¦Y¢ 4*¾â  02m€¸_ 2:¦‰mh¥pœ
 r-P`¡€DQf©<¦ñ—ø.«sŞG‚¨ Pí‘€«sŞG‡U¦Ò¦š7Üş  PP¾€ˆ=™Mj¦õ´ßªøI·Â ÄP±€Qà°Rr¦´‚02håoP•˜€ÒZ“Íu¦õóf¿éÂ9× ¾çP<€°*ùŠ¦Ú\´NF lP¬j€İ¨c“d–¦
İ|èğ¼¡ `@€"€W)—r›¦Hƒoz‚®yW]k PÆA€‚®yW]¤¦ª¨ùS÷{ º Pò€S÷{]¤¦ª¨ùLè¯ º Pò€Lè¯+³¦µ>ÖÀ¨b $P/L€[\–ûp·¦ÍFlŠNf«l PÆA€ŠNfüĞ¦@ÙëÓa˜É àEP¢
€ÅÖSÚ¦´d¯ãØ@Ì‡PB"PVk€©J{Ïå¦åä0±3’­ "Pö €–´sA:æ¦Óh—?DˆN  dP‘;€‚Øç¦Q{DÓAzˆI*¸Pş#€k ı+íú¦RÔÒh÷„|áR;V n„®—y§ªU9'Ôƒ-k PÆA€'Ôƒó§ìÅËÌ×5?şi PÆA€×5?)§ëx$>¶ôËğPK€ršT 7§}vnumic Ö	P$£€L1(Mo7§›ßXD0K0uPJ;!sè«$8§Kœ43š!Òˆ Po€wM—È¿F§LGBâÒ14¾ l@mÉ€§Råèb§s.O™C\aôáh PÆA€C\aô0e§q/+˜-«‡@?@oBSõiI-m§ÃõÊ±òÈB îPh"€	æ0­s§Y÷]ç‚ÀÆ: ÌPŠ4€/OàIbx§ö²Â¶¡ß8èm E	 Œû 
z§”Jf /’¬ ¬GP¯•€

	„‹…§îÿã8d•‡ş  PéV€éCZ)õ§;¡Zü–HöJUPg†€uîf¶•§C@Î\Ò$¬ÿÿÿ_z p,o •§Ø«oÒ$¬ [ù_A rE0•§’Ç.xÒ$¬şîÉQõ€wín•§µ;¥Ò$¬ÿÿÿ_  pØ[ •§#TØÓÒ$¬ÿÿÿ_õ€xÂ 
˜§,lÒ†ájØÀç	P~ pNê¼™§XóØƒ˜šÃ¹6PÎÄ€u»ƒxš§‚JCqög€] F	  û ²§ÿî¬¥É{ àPÁ­€.g)e¹§bÒI˜”"GÙ œPb€®z`¾§ü(YUKU¢í`PÇ›€®ÎˆxRİ§åæ'É"Ìû ÀPù€èw3.[å§Ñî9Cúvî $@€#æ<Ô÷§îÿã8g¶&. ÒP_p qÜ¹¨À£Ğw\†L£‘-Pw pz ‘„¨4¨K8Şu7»/k ÒP  p„î³×I¨ò»õşjÆj B PÆA€jÆj™R¨®²õ€º|8 ª PB®€€º|8ÁR¨Ø6VìTØô& È(PÊV€Š‰×ª^¨»¢…rBõä(Ó Pí‘€Bõäºo¨F)F'baâY †P‘;€¥OrÕ•¨IG?¤ZË‘‰L$D	 d´ Õ•¨¶Ín”?·ß`_P€"€5¥.V”›¨­„bÀ×%P	  p“Å·²´¨Œ$›eÿ¸\ŠQÓ7Êni¿¨$Ö/¿Êz!ÓPÑ¬ ŸùÇkÈ¨&éÂk_p¾i PÆA€k_p’Ğ¨oaÓÜÊ|Ã²A PB€Ê|ÃÕ¨³˜>£áÏ—ü "
PeÀ€ˆD?×¨Ú­\¾äN>Ñ PÆA€äN>©œkøsÇ}•G 
 0.c€ì©  N©îÿã8êŒé †P¤u€™f~4!©$“ëG©¢‰ 0!P‘;€_ßÛ)©é\*DñŠ_  PP€ñŠ_ZA©d@»H€c	k PÆA€€cYB©ı5Cí´ãÏb Pú€´ãÏbC©<Îœ–Öu® Pí‘€œ–ÖuKV©+f'¹€ –PW€b«œY©C‡Ù]×İW jÌPi©€=oöıCb©«\è4ƒu (P‚°€¬-ú¡c©Zâ\š‹¬ÄX ğP‘;€R1D²m©©YÉµÃ)Ñ_ HP¥t€ ªB7o©îÿã8'Ñ,Ø JP
 •9
ƒ‚©VßÛ¹œÇ{n 00P‘;€4ÁÁƒ‚©VßÛ¹œÇ{n 00P;  pl1úàM‰©¬_óé^ˆcşPÆA€@˜§3‰Š©€^…Ù«í|İ“PHÀ€¶Àıº½©¬·3¿R½?œ 0?€`0 ¨à© °G¦Mè„8È¾Q  p
bLWãı©i¹¿…^dYğ} PÔ2…^dY? ª,%í¿)î‹®j PÆA€)î‹J.ª~ŸúXÄ}D S@«°€.]¢jNªªU9ü)%#k PÆA€ü)%'uªDtˆ]–®8xœP2:»?`"vª«ãt
‡æ ğPLo€²b›ò?vª¹…¥7•*X ÚP4	€ğ%Ri{yªFwÉõa:b¥¤F@‰¿€^áÔ2ˆª'©:ÖQ3è«PJ pYî—/Å•ª²G“‚à àP®€ÁÁîÎ—ªš/r£P|Ó ø@£ :aî›!›ªk.D5Ú•†”@i©€èÿÅi ªp$ÿ\A-Ÿ“k PÆA€\A-Ÿÿ¢ªg>–dÏî¸ vPŠ€^#×¤˜±ªÀÑ/_·Ü…2 PŸ
€?‰æªi€Ó)¸gÒ 0K°€\ö èæªîğt§&ß4 €0P)H€/ˆ›îª}2¼CXe‡ PJ,€¼CXe“ûªu6­òTKÄ" XP¾€·›â'œ	«¯¬’vÙ5Ò  @³ö€°ïÏN
«BÕ´¥×‹ßÈ¦N@_ è’ğ)¥«ç)>G~e ÜP7€	»ÊH«°)dï¸0 0œù€¸0 ¨«Ûå0“Ï=}µ dPŞe€úIÖ${)«ìÅËÌRıi PÆA€R1«ò«¼7Ë |P1Ê€_iç‹7«·Jº¾jI \
P;Ç€ë¦ãxA«
¬ä¡5‘’Q7@P72ÏR«ğ+¦@z÷"Å¤’Pg†€÷„Àl«¦í¶±RpÏH P¶€2	[p«¦bôb}„ÚŒáP t€LÊ8Gq«ÀY,[™ú  P§€[™ú:€«—X=QümŠ–eyPÆA€Ë¼SİÛ¦« õµ¤<IMPƒ
P»" ©ı3?9³«›,Npa³ü Ş PGÓ€a³ü¦¹«·ÃÎy†ÍÚ¾ PÆA€Îy†ÍŒ¼«•ä$e‘*”P'X€·°G¤L½«„ÃAY,x‘¹aP¸Ñ€d²¡âÔÃ«×óÔ/^Úò æP"ü€d0=Ù«-Âó®Ô*”– à @i©€Ô*”–òè«4˜üdiHì¼GPPa€cÓÊPü«&éÂÌ`ëœÊi PÆA€Ì`ëœ:¬‡Ó“Ò‡E¹F˜ Pº#€‡E¹Á+¬pcA"w=%" PrÊ€"w=%ƒ3¬îÿã8íIo ¤ PÉE€íIoƒ3¬îÿã8Mu ¢ PÉE€Muƒ3¬îÿã8=©0ç ¢ PÉE€=©0ç7¬Wò1ÔŠx „PÑ Àä\sÆÅ7¬İ¯Ã²pTú… Pí‘€²pT;¬ÃÇï>‚7ŞSPÆA€Ø;¬ôO——\Ro7PŞ¡€6*É,;¬ÀkPÜFaÙ6P£€öRô'H¬G¿“‹”q¥š İPÆA€$çªJ¬‘üíº@LùšPLo€·yàM¬œîÛGöÕ ÄPi©€Jœ>”â[¬0òQO¥¼É ¶ PB®€¥¼ÉÖk¬EbÆ‰Ûõ¿( P;  p‹0ÒÖk¬EbÆ‰Ûõ¿( Ps
 ‹0Òxn¬ååje2JVül PÆA€2JVü:o¬€¿•ñĞz+ Ğ%P§S€ƒ%BÉ,z¬¤Ñ‹!+t ÍP°}€c|Œ¬+³³T@Şi’|YPg†€/Ñ¬õj%"‚¯Ÿô=PFÁ€ §›I˜¬­çµç~èCÕ0 Pša€ç~èCk²¬±$ı,Sv‡ïP2/€UíÖk²¬Î}$7SvPAP2/€³”YÚk²¬Ôµƒ<Sv8P2/€¹µp4k²¬LÊ,=Sv ÅPÏE  J.k²¬‹6ÃÉSvx)P2/€ëÀ}k²¬ÈŠcæSvg(Pİ&€ÿğU›{Á¬‚‡Ã³›†ß ”P¦ü eäõ<Ö¬È”ŸFœœA6 ôP)€…Â5ùù×¬ô.ÃëÍˆ|P  pˆ)ÀÒç¬Xæ¸23|±k%$ P™o€3|±kké¬Xaoá ( 0D	 x´ ÿé¬¡¢ãøµ%İ PP&€¦ö¬š/r£uNBÙ ø@£ „¨FÉù¬¹—àíUCŠ @w€kÉjÙ“ü¬ın)öñÉûi PÆA€)öñÉª­¿¢e9 Û P<R€ ƒ¶\­¯:ã(®™ îGP–€u–8­äğt}%äx¨½'Pºú 0;tMeceiver,
                                const Function& callback)
    : AsyncWorker(receiver, callback, "generic") {}

inline AsyncWorker::AsyncWorker(const Object& receiver,
                                const Function& callback,
                                const char* resource_name)
    : AsyncWorker(
          receiver, callback, resource_name, Object::New(callback.Env())) {}

inline AsyncWorker::AsyncWorker(const Object& receiver,
                                const Function& callback,
                                const char* resource_name,
                                const Object& resource)
    : _env(callback.Env()),
      _receiver(Napi::Persistent(receiver)),
      _callback(Napi::Persistent(callback)),
      _suppress_destruct(false) {
  napi_value resource_id;
  napi_status status = napi_create_string_latin1(
      _env, resource_name, NAPI_AUTO_LENGTH, &resource_id);
  NAPI_THROW_IF_FAILED_VOID(_env, status);

  status = napi_create_async_work(_env,
                                  resource,
                                  resource_id,
                                  OnAsyncWorkExecute,
                                  OnAsyncWorkComplete,
                                  this,
                                  &_work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline AsyncWorker::AsyncWorker(Napi::Env env) : AsyncWorker(env, "generic") {}

inline AsyncWorker::AsyncWorker(Napi::Env env, const char* resource_name)
    : AsyncWorker(env, resource_name, Object::New(env)) {}

inline AsyncWorker::AsyncWorker(Napi::Env env,
                                const char* resource_name,
                                const Object& resource)
    : _env(env), _receiver(), _callback(), _suppress_destruct(false) {
  napi_value resource_id;
  napi_status status = napi_create_string_latin1(
      _env, resource_name, NAPI_AUTO_LENGTH, &resource_id);
  NAPI_THROW_IF_FAILED_VOID(_env, status);

  status = napi_create_async_work(_env,
                                  resource,
                                  resource_id,
                                  OnAsyncWorkExecute,
                                  OnAsyncWorkComplete,
                                  this,
                                  &_work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline AsyncWorker::~AsyncWorker() {
  if (_work != nullptr) {
    napi_delete_async_work(_env, _work);
    _work = nullptr;
  }
}

inline void AsyncWorker::Destroy() {
  delete this;
}

inline AsyncWorker::AsyncWorker(AsyncWorker&& other) {
  _env = other._env;
  other._env = nullptr;
  _work = other._work;
  other._work = nullptr;
  _receiver = std::move(other._receiver);
  _callback = std::move(other._callback);
  _error = std::move(other._error);
  _suppress_destruct = other._suppress_destruct;
}

inline AsyncWorker& AsyncWorker::operator=(AsyncWorker&& other) {
  _env = other._env;
  other._env = nullptr;
  _work = other._work;
  other._work = nullptr;
  _receiver = std::move(other._receiver);
  _callback = std::move(other._callback);
  _error = std::move(other._error);
  _suppress_destruct = other._suppress_destruct;
  return *this;
}

inline AsyncWorker::operator napi_async_work() const {
  return _work;
}

inline Napi::Env AsyncWorker::Env() const {
  return Napi::Env(_env);
}

inline void AsyncWorker::Queue() {
  napi_status status = napi_queue_async_work(_env, _work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline void AsyncWorker::Cancel() {
  napi_status status = napi_cancel_async_work(_env, _work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline ObjectReference& AsyncWorker::Receiver() {
  return _receiver;
}

inline FunctionReference& AsyncWorker::Callback() {
  return _callback;
}

inline void AsyncWorker::SuppressDestruct() {
  _suppress_destruct = true;
}

inline void AsyncWorker::OnOK() {
  if (!_callback.IsEmpty()) {
    _callback.Call(_receiver.Value(), GetResult(_callback.Env()));
  }
}

inline void AsyncWorker::OnError(const Error& e) {
  if (!_callback.IsEmpty()) {
    _callback.Call(_receiver.Value(),
                   std::initializer_list<napi_value>{e.Value()});
  }
}

inline void AsyncWorker::SetError(const std::string& error) {
  _error = error;
}

inline std::vector<napi_value> AsyncWorker::GetResult(Napi::Env /*env*/) {
  return {};
}
// The OnAsyncWorkExecute method receives an napi_env argument. However, do NOT
// use it within this method, as it does not run on the JavaScript thread and
// must not run any method that would cause JavaScript to run. In practice,
// this means that almost any use of napi_env will be incorrect.
inline void AsyncWorker::OnAsyncWorkExecute(napi_env env, void* asyncworker) {
  AsyncWorker* self = static_cast<AsyncWorker*>(asyncworker);
  self->OnExecute(env);
}
// The OnExecute method receives an napi_env argument. However, do NOT
// use it within this method, as it does not run on the JavaScript thread and
// must not run any method that would cause JavaScript to run. In practice,
// this means that almost any use of napi_env will be incorrect.
inline void AsyncWorker::OnExecute(Napi::Env /*DO_NOT_USE*/) {
#ifdef NAPI_CPP_EXCEPTIONS
  try {
    Execute();
  } catch (const std::exception& e) {
    SetError(e.what());
  }
#else   // NAPI_CPP_EXCEPTIONS
  Execute();
#endif  // NAPI_CPP_EXCEPTIONS
}

inline void AsyncWorker::OnAsyncWorkComplete(napi_env env,
                                             napi_status status,
                                             void* asyncworker) {
  AsyncWorker* self = static_cast<AsyncWorker*>(asyncworker);
  self->OnWorkComplete(env, status);
}
inline void AsyncWorker::OnWorkComplete(Napi::Env /*env*/, napi_status status) {
  if (status != napi_cancelled) {
    HandleScope scope(_env);
    details::WrapCallback([&] {
      if (_error.size() == 0) {
        OnOK();
      } else {
        OnError(Error::New(_env, _error));
      }
      return nullptr;
    });
  }
  if (!_suppress_destruct) {
    Destroy();
  }
}

#if (NAPI_VERSION > 3 && !defined(__wasm32__))
////////////////////////////////////////////////////////////////////////////////
// TypedThreadSafeFunction<ContextType,DataType,CallJs> class
////////////////////////////////////////////////////////////////////////////////

// Starting with NAPI 5, the JavaScript function `func` parameter of
// `napi_create_threadsafe_function` is optional.
#if NAPI_VERSION > 4
// static, with Callback [missing] Resource [missing] Finalizer [missing]
template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
template <typename ResourceString>
inline TypedThreadSafeFunction<ContextType, DataType, CallJs>
TypedThreadSafeFunction<ContextType, DataType, CallJs>::New(
    napi_env env,
    ResourceString resourceName,
    size_t maxQueueSize,
    size_t initialThreadCount,
    ContextType* context) {
  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;

  napi_status status =
      napi_create_threadsafe_function(env,
                                      nullptr,
                                      nullptr,
                                      String::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      nullptr,
                                      nullptr,
                                      context,
                                      CallJsInternal,
                                      &tsfn._tsfn);
  if (status != napi_ok) {
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());
  }

  return tsfn;
}

// static, with Callback [missing] Resource [passed] Finalizer [missing]
template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
template <typename ResourceString>
inline TypedThreadSafeFunction<ContextType, DataType, CallJs>
TypedThreadSafeFunction<ContextType, DataType, CallJs>::New(
    napi_env env,
    const Object& resource,
    ResourceString resourceName,
    size_…p/  @i©€…p/*¹!œw2}S° Š
PËw€B[hä9¹!Yô¼kKèÒ0bPOù€QîaëÊ:¹!µ«úa>XÔ(¶ P€4>XÔÒ:¹!å+¨Ó­“#° PJ,€Ó­“;¹!K‚*Ç€ *P×ì€Ç]³¹?¹!ƒ‰Á6Jnnh P]€¯îMœA¹!š/r£ª—7> ø@£ \sNAW¹!ÃNÂFVB‡±@4Y€ß®UZAW¹!0<˜ÛVB‡‘
P4Y€ü’ç¹o¹!¹o¹!¹o¹!  0²€@ë  ÄŠ¹!.üÅ†·}êL èPÆA€0E½$Œ¹!£4ÉD6İE€ „Pù€z+ øÉª¹!&j]jwôyP“`€üùX¸j«¹!„ÅKW•Nè
 >P?S€º¼¿pj®¹!^³ù?äÙƒ 0fa€È§ ÕÌ¹!kêE7ŒD”ª[] Pº#€ŒD”ª¸Ú¹!‘©Óç!Ãy}	PÛ&€èt¬ ç¹!Áo­>`0ÇåP¼u€ŸÃKÀeí¹!µÿ²
\ä!û PÆA€\ä(º!m°Ex¾JCP |QÓ7f¾Él7º!iØ@]e².ÈOP~ pc)¯‰9º!«ÇZGOˆ` P$ pZGO´Aº!Ò¤Èç’g] *Pô`€—3 ¨	Pº!‰æ§ôÃÈ: .Pw'€1QızRº!ğÓÄ¯P'êè V P¬U P'êèUº!Ğdíiæ†@ PB®€¶CRáğUº!¸Ëi¬<ÅÛô¬PÎ§€ò4é@gº!§Ç¥§G¶	¥ P‘;€ì~{2Špº!¸Øø–Më$àŸPƒ4™!»vº!B›Û”.ä7+A8 P	c€.ä7+$yº!ç:/<j PÆA€/!|º!‚rmÜ[BóN  4P" p×²‘‡n‚º!sX¡…‚å ` Pi©€¡…‚å‰º!•ëwúÄú tP#²€ïóÁbŒº!0ÚgõÀ’ PÆA€gõ¨º!è{íq4²Çí£ PÆA€4²Ç8®º!&éÂÃâqÂi PÆA€Ãâqµº!	*9(#E²µ Pg†€½½–Øº!}WBUöJ}n öƒPç:€çŠòX7Úº!¦†÷áS ¨P«U€
ÜjŞDæº!½ ‰¨sL @P#²€ÚiTnçº!Çç*Á®ùAß§PÆA€Yø—~Yşº!^\‰l%B4”ÿˆ@£ 1í»!¦#Œ2­•dÉo£Pi©€7Ôáº(»!U\>L%~I	@£ ÚRv«c»!ãûOÇowÀîj PÆA€owÀî »!Ğ9@+8 ~hQB®€XĞ£%»!­^»ÜÑ¹g PÆA€»ÜÑĞ+»!ë={SÿÊ` PÒô€I'”8£4»!4XlkóWâ!  Pú€óWâ!ç;»!{zD=ÂÃ ¶P‘;€.Sx>»!ıÑï.•' vwP‘;€Y04š?»!°E‹Û:wõú>PÑ;€%€0õ·T»!àZĞUwP €÷·]F U»!½&ÆH¹sC ŒP €|ìèi»!ØVÖ¾Ml«3PŒÑ€ ÷Âùèi»!ØVÖ¾Ml«3PÈ6 ÷Âùl»!
ú§Uo|4µ Pí‘€Uo|4Nr»! L”–YZ³HPZ3m1±v»!Â",~,Íâ<Nª PJ,€,Íâ<7¡»!³­ÃwunH:Pºú £T•¢»!İZËÊZ»P iAP†6>=èÚy·»!Üdfçÿt‹ 4 Pè€ÿt‹y½»!ïXvyÆ8…Lx˜fPn5ÂNë ¾»!	V=âMæ¦ œPz€íİ¿ĞôÄ»!—‹åÈö”ŸzkPŞ¬€²ß3À”Ò»!È“ ^d /=Pæú€ ¤š”Ò»!È“ ÙA¼Mış
Pæú€EŞù”Ò»!È“ 2Zf0!Pæú€qdLÊ”Ò»!È“ )|ã¿/ÅPæú€Ø\¸”Ò»!È“ æxâ/IPæú€²-€rŒØ»!ôòG±eu"k ,PW€}@|ß»!‰xeZ¡æ ] àP‹@€z-õ+ö»!"¿Òä"O `PT'€4–ò¾ö»!'0~¿sø;  (Ÿ€¤F ˆ¼!q¯=cÉj­ ~P		€³(Ã·è¼!îÿã8æŒP UP÷ô€’9*„½¼!ÃıP±Fr‡pørPÑ¬ R2õ94¼!ìÅËÌôq=…ùi PÆA€ôq=…:¼!r$^­-àënhhYP6BÒÃâ•D¼!½f=b9,˜P€4IİdE¼!­^m‚;ÈÑg PÆA€m‚;È2G¼!|w¯‡8­- ¶Pr€æ‹¶WI¼!1½­Ê¯ • –PÓ€;y…€O¼!ñ8Õ–­Ód8 Š P˜n€­Ód89R¼!&éÂıÍEşÌi PÆA€ıÍEşVX¼!ï"Cº¤1—‰ÆtPz pÍÒrFi¼!{`j!¯[> ’Sà5€=†%i¼!½d´0!¯[> ’S{­€ôš&i¼!´ÛP!¯[>0ÌS{­€ã9Y©ey¼!³ÏŞMbœ× Î
P‘;€s{$Ş|¼!`!-Ïûõx– ˜PÄi€“éÏ‚Å~¼!qÒı=3Í"P:€›÷|}Œ¼!g­g$:ÄéY P’"€ñÄ/¬¦¼!¯£|“8çÂ lPk€ØÂh†«¼!æêfjÁkJk PÆA€Ák¥®¼!½z‰áú«ÀR'Pi©€Ù¯ŸÓÇ¼!²xš©oòO‚  QU€M2ÁÜĞ¼!gÚ„™]El˜ëP]<9c£>ıİ¼!rş]V8ŠÕÁ Pí‘€8ŠÕ­å¼!=|g{ÉS©†
 0Ó!€°	 Hé¼!:Ûíèz¨äP•€¦7ğ „ü¼!ã>¶ÄıšñH <PÆA€z\27„ü¼!ã>¶Äàø‘ <P{P€p-Ÿ„ü¼!ã>¶Ämç <P{P€ƒm6\…ş¼!ü¹Ô°ª±ÂHjœ	PŸ
€±ù*/2½!¢ÅïÌ@Y|CÊPÆA€@öÜe›;½!ô«pÕ{	ñ
 ÂP§S€ÑíyC½!Z¦ıK5U‹ hPÇÁ€U¸!”¼D½!iç
L!zVk PÆA€!zèY½!/óVªG=¤ ŞP’¾€Ö„/ïG]½!Ìgx ´\§ ÀPp(€
°Èï’d½!ÜÄKF;ìu èPÆA€?Ä›Øe½!uÍ+9O»T 0ÆA€”  %l½!]RuL<«r \PÆA€©{t½!&/J‡’İI 
PGÓ€€£ŸS¯¡½!N±!• +¢°¼¦Xi©€•H·@’¢½!Ş].HÊY;m 0â)€0Õ	 ¼¢½!nMp›w¤C  PÆA€ÛÆL±ú¨½!°.óBÜ}ĞFöP"™€ÂÂ™µ¬½!ãÀU8‚¥‹* £Pi©€b„ŸÿÄ½!UpòlK‰P)øÉ1PÈAĞ]š¢]Ê½!ŞŸì¹]?K'±Ó Pí‘€]?K'`á½!koI\íªu PŞ¬€¢Òãƒî½!06DŞY…GH#Pÿ¦€uUcˆ¾!]®?Æ!N`¸´ PJ,€!N`é¾!s)ê^àm ğPÓ€«#c`§/¾!ó«Š{-p–7 ª
PÇœ€«â·;SE¾!a—¤®yô  P2—€®yôG¾!áÄ¿ºK†„Á 0æ™€\× M¾!M_ 4_Ê0GçP	r€3…¾Œy¾!#©­Ëîw¿Ó èP?S€Ê:‹
‹}¾!-¾±¿¬Óº PöÓ€±¿¬Óä}¾!u®~QA­©ô£U@éV€=¹óÎ“€¾!Šnïµpô™ FPNd€Îrf†¾!QìÊ¨#¼Jè¿MP  pÍwgO‡¾!øƒ4‚Ò—|$P15€«¡t_Š¾!"4¢•Í@Û   P¡_€•Í@Û=¾!ıÔ¥",X î	Pi©€¯].ö”¾!gCÃŸJ(™]¾Pg†€ÂmĞñø¢¾!H›[kyìSø tPA~€ğ¹ ã°¾!Ñºı×_·gÄ“àAò÷€“O$Éh²¾!ìÅËÌsøi PÆA€sh²¾!ÑŸE´LÂ-­-k PÆA€LÂ-­Â³¾!	†5k9ø4BP¼›€U­çâ´¾!AÖ¬óV±\ÓP €hÑ¥Âê»¾!­›®y#líj PÆA€®y#lê»¾!­^²~ïÆg PÆA€²~ï½¾¾!ˆ€b:3¦£å ô PéV€3¦£å‘Â¾!ç7ZÄ°¤ûŞ,FYPHh€we¼‰÷Ê¾!Ü5—,ŒŞïÖ	PçŸ€•´[:z×¾!½MN%œÅçDğP5* ùÍÿ×z×¾!µÍûœÅçDğP5* “sÄ¢Îß¾!ŸÜ‘?3İÙéÊ Pí‘€?3İÙå¾!ÿî¬‡*^ P‘;€S–oÂB¿!/ÔB<N( ° PB®€<N(J@¿!ŞhŞ±¸ß“·j PÆA€¸ß“BX¿!;‡É½û ÔP.€”‘V)Z¿!¬Ì,!9& ,
PÕŸ ˆ6ÖQö`¿!æ71Lş“ 0PT€1±Lec¿!EİË(ö„ãT ¾
P‘;€ËöI°f¿!’nlSÎ°ÕP  p“>ä:q¿!ãûOÇEËoDƒj PÆA€EËoDºr¿![û½‚Pë°_P¤F€ûQw¿!ÎF4DÍ†”tr,@½€éî²`çƒ¿!O)Œpï3SÀªP–~€–àÃ.Œ‘¿!±\WÖË}È ÆP|É€À-b°X©¿!÷ l)òÑ¤ğÌP…6)ë:)©µ¿!K2H¾ómT ÆPÓ€Äîò:Ó¿!¬_óé-pêÓgşPÆA€qîßÎËí¿!²À¸pÛê‚ z P«°€Ûê‚ZÀ![œ†AË¦§ÜîP…ô€f.Üú—À!eßy½öK ïPÓV€ÕĞ°,À!ttöMé].€xP  pmôÜÅ0À!uåJì4 ŒPâ6€_Tı˜1À!³ƒ¥«v|ÜE P$ p«v|/?À!½—‚‹ÈOBPÆA€ÅÑÛèAÀ!oúRÑ€ö p
Pÿ7€‡%lBÀ!…,<>ğÿBû ¢P;  pSüşBÀ!ß?Çf‡;€Ä Pä§ Çf‡;eKÀ!ì_ûa3:ª ìP7€-Ï™iÊ`À!‚zNc<Íw÷j PÆA€<ÍwkÀ!ğ¢–pK‹'•Pöz€ê.	årÀ!h3…Áò$µ ÊPs€L6Ó{<†À!…Ë=‘âp í 0õ	€ìD Æ‡À!m*ÓqeÕ  P‘;€qeÕÆ‡À!m*ÓqeÕ  P! pqeÕ	‘À!è3må{eï@=PZ´€”ñ]¡x‘À!hUê×ş}AÓÅ P€ş}A°¢À!Mru²â46p­6T{4ìš1X!¦À!*ƒĞÎß¡iá®@v€&-ŠÙ°À!+L1ÏYÜ¨P  pî™MÄ>ÀÀ!ˆ Roq”WhÃP €Œr]\WÃÀ!GŒ¨4fğe lP×ì€%Q©R‡ĞÀ!ØÀÆşƒğ lP’¿€¥nVäÖÀ!¿îÓ>Š¢'¥Ì¥PŸ•€h;$ÂdŞÀ!(KYébê °l PÆA€ébê dŞÀ!ìÅËÌ:•~ÿi PÆA€:•~ÏçÀ!vÂ]Ü\ÊPuy€Ç7? êÀ!®m†m3F:6 Pı€m3FÁíÀ!§!lô¹âZâJ 0ãÏ€t¦ ÿîÀ!@„ÙÏÈ#]xj¡Qw p˜¯—ôÀ!ìÅËÌÁ	& şi PÆA€Á	& êõÀ!uôG¶°AÃT  …‰€üî
 ‚öÀ!ŒK8òç#<$ìßPá§ 7©°u4÷À!g†ª>5 ô„P{­€A1#'Á!6ãªy8_
P|É€)QCßŸ4Á!¤¼(îkT®*PÆA€Ğ-¶"d9Á!$ 7døzÛ‰ PJ,€døzÛKÁ!‘3m3ÜİyöPÆA€RÿJ4[^Á!&Í6›{…HxBPÿ€Ìe:[[^Á!æùÇĞ›{…HxBPÆ€0½ÅaÁ!I¹V‰^¨.>Pª€³AN>ÏcÁ!Hë’8¨U¸5À#LP€6+å9pzÁ!¯¯ªd+Ï(Ğm PÆA€d+Ï(=~Á!ì#Ì:Ÿ_s à
P¸ˆ€(èİ*…Á!%Ù«E.¥¶ØP#²€MÏ?~:ÂÁ!§ï1ñsu†}Pg†€Ÿ½0
ñÅÁ!âœı‚Ä÷~ NPùù€8Â’ÊåÎÁ!ãugg»ÖQÕßi PÆA€»ÖQÕ˜ÏÁ!0°]0SBc ülP³ı ¦(˜ÏÁ!à
ÜdSBc  …P³ı $XE˜ÏÁ!T(kSBc£<aP³ı J\î˜ÏÁ!j«ouSBcr `Q³ı øSÕK˜ÏÁ! {vSBc hBQ³ı îÍB˜ÏÁ!£bµªSBc  @Q³ı ß_+˜ÏÁ!‘´ÚÀSBc˜Â@Å€h×Œ:ØÁ!Øöuk vÎ™ğ5“P ö€'?I^ØÁ!Jô‘ï<>Ù°ÙÅR  p_f^«-ÚÁ!8Ê\]­–¢Å) PJ,€­–¢ÅñÁ!ëpüğn‹³5Xü$PÓ7È«ÏôÁ!yY%º<òu PW€<C“Â!…±Ú•Ç³g+ 8 @i©€Ç³g+Ï=Â!İÜZJºY¼EP`É€ĞFÃ—+DÂ!lÑ˜€¡Îf 
	P‘;€æ2oPZÂ!*Å<S¯õÎPg†€¼<ƒÀZÂ!,tJ£†2Oğˆ8P6Uå¯ÌêgÂ!¸m	jí ¬P’<€…@1µxÂ!kÚÿŸ#ì,ÑX@õ€ZT$;?’Â!&éÂo¾ó¶¾i PÆA€o¾ó¶¤“Â!ËÊ´×oõ ^P_p ÑT˜Â!š<fİ9qŒ šP¶,€ƒí*X˜Â!ÑÁŞ“é¹•i PÆA€é¹•Ù­Â!P_c^ÇB´ PÆA€^ÇÙ¯Â!DçiçĞŠU jPƒ€N¶­¢µÍÂ!ŒêZıttğ„P  p*éSTZÎÂ!5UkäÛ)ºÂPŞ¬€™>ˆa—ÎÂ!­õ÷©RjÖH#¦@ö€{úã ÚÑÂ!âpŠuUÁ3= ©PU3s¢o¥©çÂ!@œU×À“× Pô€×ÀŒìÂ!ĞÏ¼^Jß8 \@&€¦ 8”(öÂ!c Ï&!eN¥ PĞ‘€Ï&!eQÃ!4º×*ŒX§,P$j€àã1s`Ã!ÍFlÙ¯T±l PÆA€Ù¯TÃ!ºêÉg»‹D(h§PÕ€yª;¡İÃ!-ÚÍ».3ˆëPw&€¤ÎßİÃ!GK |k{ôˆëPw&€7ÃÁïİÃ!Mn(ÖUˆëPw&€‡Ú İÃ!Ùäs'ú¼ˆëPw&€h¦²*İÃ!åAD»jGÀˆëPw&€çš~+İÃ!D³©5G#Ñ	ˆëPw&€V¥çİÃ!òˆGí V¨ˆëPw&€øôÿİÃ!ˆjs«ÁO-ˆëPw&€Œ<ıİÃ!Ó›Í¶p ˆëPw&€¼H\ÔİÃ!º>œõªVˆëPw&€‰3öİÃ!ìQ²):QOˆëPw&€Ì2Ş"İÃ!há*Ñ³²€ˆëPw&€,ècwİÃ!*û ^ı[ˆëPw&€¨x²İÃ!6p;Ÿ‡ÂˆëPw&€Læ„ùİÃ!,â0!ˆëPw&€s‘=İÃ!Ì& @5F3%ˆëPw&€´ŒBİÃ!tW‡˜^°%ˆëPw&€ÎŠ£İÃ!µèa ú&ˆëPw&€Ùœ2İÃ!!eØïı))ˆëPw&€ÒÑ¹>İÃ!@‚W¶Œ*ˆëPw&€g|İÃ!Pes¢Ôz+ˆëPw&€,áÿİÃ!ë<fÛ‚¦8ˆëPw&€0µãûİÃ!Ñ„ğ{1UAˆëPw&€ñv\|İÃ!]M(Î<BˆëPw&€øğ…=İÃ!İ‘ıWã'C ÚPw&€Â’ÚİÃ!!+(9•`IˆëPw&€ÎÄ•UİÃ!ÀØÎé(N ÚPw&€5»İÃ!piëé;‚NˆëPw&€$-¶ßİÃ!Í¤—½9’PˆëPw&€	7«gİÃ!}ÚC3oˆXˆëPw&€ç¬8;İÃ!êVk†—[ˆëPw&€<µ÷İÃ!jÄé¡Ë´^ˆëPw&€WÈÓİÃ!ßÖ84İx_ˆëPw&€"IİÃ!_tèc/qcˆëPw&€?‡o½İÃ!ëèJÉë§nˆëPw&€«ÄíİÃ!=÷oˆëPw&€OyüİÃ!È+OFj°qˆëPw&€ˆÅI“İÃ!jñªÛ^àÒrˆëPw&€y×£İÃ!w¢R>YLš}ˆëPw&€³ı÷İÃ!ç"5+ö:~ˆëPw&€’ÂÈFİÃ!ÂÿG‹ˆëPw&€ø…İÃ!Öiÿ²rZÕ„ˆëPw&€FQÀÄİÃ!İ‘ıWö,sŠ ÚPw&€$…İÃ!¶“}?eàŠ ÚPw&€ô…'İÃ!HŠ_˜X<‹ˆëPw&€o7+8İÃ!¼0«(åˆëPw&€CşêëİÃ!Õ{cçöˆëPw&€’ÔyšİÃ!´­*‰ØšˆëPw&€¿'İÃ!%…CÙ¦²
ˆëPw&€Ü€©JİÃ!»wŸZÉ¢ˆëPw&€j8UNİÃ!Ù’|Üjmq£ˆëPw&€(ñ×”İÃ!m<uU—¡¨ˆëPw&€"Í§ˆİÃ!µeà"z\«ˆëPw&€WŒMİÃ!¢º‚^w°c«ˆëPw&€/;4´İÃ!Â‚ïJy!¬ˆëPw&€4Ñ¥½İÃ!­©©O'²ˆëPw&€•ÁñİÃ!Ùóh¨­Œ²ˆëPw&€8cİÃ!•™•yÏµˆëPw&€ pIËİÃ!Z¯4qµnDµˆëPw&€×‹j©İÃ!U÷Çïã¹ˆëPw&€—"LİÃ!¶“}øí¼ ÚPw&€…é¸İÃ!€Uˆ¥Ñ½ˆëPw&€ôıGÓİÃ!©*éï(ãò¿ˆëPw&€ò@İÃ!·>ğr ËVÂˆëPw&€gTİÃ!İ$={iÆˆëPw&€ÎŸ°/İÃ!×î;º™áüÆˆëPw&€7ÿ82İÃ!qáü¥ÒZÉˆëPw&€™f_áİÃ!tÂÂj!ãÏˆëPw&€%y öİÃ!ĞÅ­
ÑoÕˆëPw&€ß1>İÃ!¶“}½†İ ÚPw&€§ëïXİÃ!8(üÂIŞ}ŞˆëPw&€
 _İÃ!·@7ìhßˆëPw&€ª7Š³İÃ!—CœçÎ`ãˆëPw&€îØIñİÃ!…IÑ©2ÿäˆëPw&€[*QİÃ!7®‘ÁÒ”"èˆëPw&€şï”{İÃ!3ÀéW1µ÷éˆëPw&€¿ÕíİÃ! XÀçŸjêˆëPw&€ƒ÷’SİÃ!uGõYWDêˆëPw&€Å»ÄŠİÃ!‡ÆAõÄßùêˆëPw&€q™ĞİİÃ!½Ö¼C	j÷ˆëPw&€ä0!§Ã!¯èUíùRPª¢€SÊmØU)Ã!½µ*£uFõ €	PB®€#æ(%#-Ã!<ıÈ¦¶, ¬FP€¨‚Ùlj-Ã!¥¶ÑwÆ}úş­Pè7º/?0Ã!&éÂ×´ØÄi PÆA€×´ØJ;Ã!¹ãåL8o¸$ P¼€8o¸KNÃ!4Fz@éà3¸
PÍ)€U;Üè>VÃ!wŒÔÃøh~ 0g†€\Ğ
 qˆÃ!Å—¾i–³.›uPÔ%€Ï1Eş”Ã!´ı?}Šğõ PÆA€?}Š­—Ã!ù¦‹“ÁÀßpƒQP2?Z Ñ2Ã!ãûOÇÃH
Ùvj PÆA€ÃH
Ùy¢Ã!Úä·++ "ı  PÅ€‹Pó–ª£Ã!f«Õa`ÿB@ÔP  p õÒÌk°Ã!f³f§+ÈqF ~ P­u€+ÈqFM²Ã!îJé\®±f©@ZcP  p§3Õa©·Ã!:Hë
2İ4` 0K°€èû ë¸Ã!Fw´ô°¢P1P/:Ï\ ƒÅÃ! Ä|rŠ × € PÛz€Š ×ÓÃ!¬_óéÂw]›dşPÆA€ÿÖ(;dëÃ!xÒò&1ƒª÷ØøP‡6ë-íêçìÃ!5¢(tº‹¹´» PÆA€º‹¹°îÃ!ï>ğñÌd ØP÷ô€g¸ÒrÅñÃ!G°œ¤5o hP<v€±PPUPõÃ!pÙ¹ŸŸ1ˆjP  p
x)`F÷Ã!iµ]Í¯ehCl PÆA€¯ehËÿÃ!«ëÂşSié\&Pæ À	]±øÜ Ä!”wêåt> íP	  pÖ–›Â÷Ä!}ñÃ#¿©ğğP  pçµgÅÕAÄ!P‚%Såzp PóÓ€Såz¢_Ä!”Ô«z*ÕU) ¼P"€t)òÏ‚jÄ!\DDÎ­ÿø P™Œ€(©mÈ3lÄ!zûPëêPâ5	Pã(€kÒÇ:3lÄ!qÀ~ÁëêPâ¯PÖ"€úèklÄ!êÙ¢lW±á ìP‘;€‚kÌ›mÄ!âhné@™/\ " PÑÔ€@™/\ÆoÄ!côQT¼¢Óy  P^Á€¼¢ÓyArÄ!ì¬²"Ÿæ·O. P)F€Ÿæ·OˆyÄ!°å%Ğ•l¥vP'X€À„;Û~Ä!Ë€M ¾^@;L€$ù·æ;…Ä!”ş{EeëŸLpçP69vI¾ÎˆÄ!=é¾µë«Í%`P/:'2”‡‘Ä!\Dit8e:PI€½¼ëKş Ä!>MgYcIôdäPÆA€çÄ¹¥Ä!´ı˜•ÚÇì,P˜¸€Ó»Bü²Ä!ÅÈqº ÃPı©i PÆA€ ÃPıÎ»Ä!¼/s*çHxP/:
Ù=ÍÄ!&éÂ³p2¿i PÆA€³p2¾×Ä!_20ñór|„ h
P‘;€şÜrqBåÄ!ò¿±9m®À HP¦j€Fä´ø`æÄ!ın¬7+Bûi PÆA€¬7+B1êÄ!­¼«0i&‰¿ R	Pgÿ€/ûá©İüÄ!ñ²H?0ç¯@ 4 P;  p0ç¯@XÅ!íö’¬“KâZ  PÓ€“KâZšÅ!e€?NBªƒ†
 @	€ï1qSOÅ!]ºö®Ğ{- |PW€@`‘áG!Å!ïuµ”IÛÛŠ PJ,€”IÛõ+Å!Ò(œ %±ÃX£P/:?2|IEÅ!ÒÉÓ¸"„^.P€â²"Í¤NÅ!qòûVˆè ª @i©€ûVˆèq[Å!vÀ0Êß²Ë dPÈ€Úô%ŸÁ˜Å!.xI9 º° PÎ²€t¹Z…ÅÅ!—»Ú_šé8.Pº pëÔDŠĞÅ!ğpÜ ôÑÌĞ6
P{4(gçÈeÑÅ!NXîsbı5…`âP³ı Ö]
¶?äÅ!¶Ğê{c÷¾”ğ-PI…€$ğ¿ıËéÅ!­^Š£ïyÂg PÆA€Š£ïyËéÅ!ë»-aÑk¸ö&g PÆA€Ñk¸ö®îÅ!™«¦gÕø (P*‡€%¹å…ñÅ!–"Òo›ÛW ÖP“:ğ[y»ÒôÅ!ú Ù)0ò PK€âÿıÅõÅ!¤<‹ŞÈA: zPÓ€æ ¥êÄÆ!t™B+ßéön
Pî€ÊìÊ®Æ!Š‚MDŒ›Ùæ’~PÆA€
2èßÆ!ßİú·b¨7¹ó-@8š€Wtğdè6Æ!5İ7b˜ÁS òPÆA€m·p;Æ!¬_óé~‰ÑZfşPÆA€]GÆ!®.ï_¿/2@í€4³6(SÆ!î€¤ºi@è‚ÏQw p¤xã-ŒSÆ!\‰Fæ_nBÓ¶ PÖô€_nBÓŒSÆ!0Àğî·«oî
¶ PÖô€·«oîiUÆ!(•y¦@U° ÖPÃ À!ÂZ“_Æ!Vw±àšº0e:Pz„€ÈüV"tmÆ!ë ÇşŞ¦	P$]€ÉAÓEJ}Æ!Õ%ï#«Áa @‡’€#«Á&‰Æ!ö¯ÈøW^ô0Pi©€¢>é¸ğ”Æ!seè8ŠJgÆ`@ €/ ï˜¦Æ!ˆw¸ƒ¤"æDXk PÆA€¤"æD·¨Æ!&8o³54çEk PÆA€54ç·¨Æ!ÑŸE´3Bê7k PÆA€3Bêj´Æ!lEHà­”•§¡ P¤=€­”•§R·Æ!MB
ÆJ4Ñ @@€
ÆJÄÆ!«1 ,#–5 ²PĞn€ó©|ˆ•ÑÆ!àë–b˜#dP‘;€B–?¹•ÑÆ!K	Œ°–b˜O_P‘;€QI.È6æÆ!àâ5ˆ1P  pIN4ˆòÆ!6àxÁ°O©™-oP.§€ô…lø‚óÆ!¤´LŠ²ˆø¦2P‹Ç€®¬”[RõÆ!3·$õSö PG©€/’bhÈöÆ!äåÛq¨¼ô V P0@q¨¼ôÌöÆ! ²¬%…ÁD 0¬.€¼U  ´Ç!œ+àİÔ ¶ >Pt€S/ÉhÇ!öbuKáğ9 öPÆA€w“ğğQÇ!ls1‰Ş·nØ¨Pñ —’ûÇ!&éÂ»œğÒÂi PÆA€»œğÒöÇ!t>š:¼àd Ş PB®€:¼àdq Ç!ml…Ãêë6— Pß€>lv•)Ç!?O#Xµqø PAj²ÿj2Ç!²‡İVÁ>?l PÆA€VÁ>ßDÇ! ,Ôcöh›> PeÀ€$¬™WÇ!¹6+~½YÌ¹îşIPmŠ€j‡<ÔqXÇ!İéªcC^öÅ  Pã7C^öÅ¬]Ç!dNÁè ® d PÆA€è ®„Ç!˜:VÁÖ·»…ğçPxš€«S-JœÇ!]ã¿Ò¥´ ¾ &Pl€åêd¢Ç!7Z,ø2NÆ= 	P‘;€Å/½U¨Ç!ˆ`YŞiª šPöæ€¶öu†­Ç!o¤cáfÔ HXTGÓ€MÂÏùÓ¯Ç!XØ®·6«eåÙ Pë®€6«eL²Ç!»7Ö&@?Ğ¬í P€@?Ğ¬À³Ç!­^ò!wÀg PÆA€ò!w´Ç!|Oéâ›ÕÑ'P	P/:6—şïBÈÇ!R1nËcçÙø PÆA€ËcçÙ8ÉÇ!iç
Lk 3fPk PÆA€k 3fËÇ!˜·DNBÀ Pù€Î,èbĞÇ!îÿã8	ˆ€= .PÙh ıJÒ00ÔÇ!œ.È]´M›P}€"¬uF†ÖÇ!&éÂ£k2»i PÆA€£k2ØÇ!á6+ÃÕÿoŠ Ì Pİ ÕÿoŠãÇ!$ôóœ’Ü; |P†(€C 1ãÇ!ûNmNO€nãfk PÆA€O€nãzæÇ!œY—¢CãˆkAPšs€SˆæÆÁñÇ!ŞS±³cŠŞ ¢PÙ€rãf %È!×'æ¦Â‚ R @+¡€Â‚1È!`Qâ`‘x	¸û<ÖD¬\€¥%}†Ê:È!qV“!‘ˆ "@Åg °ãÜl>È!ß6f¬}´bˆ~á PB®€}´bˆb?È!<Šär¡M@Ÿ PÆA€¡MãEÈ!W÷¸X©M’ÒÂSÆA€…qÂs.IÈ!¦n¹~‰ (P&¢€ÿÃüHQÈ!>áÎfáûbP•PM?`GiƒTÈ!î¬´(—è²]T 0¹c€ì3 -YÈ!•³ƒşÕ³S!P  p¼qœ]È!.\‚Épl F=P‘;€™ËÖlÈ!Å:5Ò1R“È¸]PD¶eoš…È!n¯f @Ê„d”p Pn€@Ê„då‰È!Îì]¿‚áJ@B®€[}¦pë“È!Ä³²Æ^.Oà @‰¿€Æ^.ë“È!Ä³²%RIJà @‰¿€%RIë“È!Ä³²_±OUà @‰¿€_±Oë“È!Ä³²TÇæyQà @‰¿€TÇæyë“È!Ä³²
yLšVà @‰¿€
yLšë“È!Ä³²G‹º©Rà @‰¿€G‹º©ë“È!Ä³²ÛTÊSà @‰¿€ÛTÊ•È!ºš¶İğb—ªv P» ğb—ª'­È!¡Q{§¾î?˜ùPÆA€>^d²È!l¾YGmIÈlíFõ€,Xß_µÈ!"½¸½ÔP ÜPü€	>Ã:¿È!în+àÒò%mœP€"€.„O&¿È!SßàÒò%xœP‡¸€?y"ªàÁÈ!€OûºÊ½¬ØºAP  p‡& È¡ÇÈ!pTï72Gñˆ¶ P‘;€2GñjÙÈ!ƒ—µ˜lÆÚPÆA€ŠËæïâÈ!K4ÍÄùYwĞ PÆA€ÍÄùYõÈ!†÷É¨µ3¶ŞOLPºû€DkÔÛõÈ!/ë™¬ã‹: |@ßt WÃ^EÿÈ!wg“‹š‚ªØàP€c€IY *&É!]¶Œ¨¿F/Á ìSP×ì€Ó^~X`É!*ÌÉÀåİèhîvW.:Úxzê)%É!JŸ°v‘„y œP’¾€„u¦&É!¬_óé¶ºkşPÆA€Ãnˆ7É!?Ö£!Õ" ç"QÓ7q®AsÌBÉ!¹ÓÅsÌ©>å FPX]€g[ib¼HÉ!À©„ˆ¸´B v}Ré !:/Ô¯JÉ!$“4œ„e^şT@÷ô€ˆS»¬MÉ!x;3Ğ’´ıîF Pı™€’´ıîUÉ!ZÛ¸ThreadSafeFunction<ContextType, DataType, CallJs>::Release() const {
  return napi_release_threadsafe_function(_tsfn, napi_tsfn_release);
}

template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
inline napi_status
TypedThreadSafeFunction<ContextType, DataType, CallJs>::Abort() const {
  return napi_release_threadsafe_function(_tsfn, napi_tsfn_abort);
}

template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
inline ContextType*
TypedThreadSafeFunction<ContextType, DataType, CallJs>::GetContext() const {
  void* context;
  napi_status status = napi_get_threadsafe_function_context(_tsfn, &context);
  NAPI_FATAL_IF_FAILED(status,
                       "TypedThreadSafeFunction::GetContext",
                       "napi_get_threadsafe_function_context");
  return static_cast<ContextType*>(context);
}

// static
template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
void TypedThreadSafeFunction<ContextType, DataType, CallJs>::CallJsInternal(
    napi_env env, napi_value jsCallback, void* context, void* data) {
  details::CallJsWrapper<ContextType, DataType, decltype(CallJs), CallJs>(
      env, jsCallback, context, data);
}

#if NAPI_VERSION == 4
// static
template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
Napi::Function
TypedThreadSafeFunction<ContextType, DataType, CallJs>::EmptyFunctionFactory(
    Napi::Env env) {
  return Napi::Function::New(env, [](const CallbackInfo& cb) {});
}

// static
template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
Napi::Function
TypedThreadSafeFunction<ContextType, DataType, CallJs>::FunctionOrEmpty(
    Napi::Env env, Napi::Function& callback) {
  if (callback.IsEmpty()) {
    return EmptyFunctionFactory(env);
  }
  return callback;
}

#else
// static
template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
std::nullptr_t
TypedThreadSafeFunction<ContextType, DataType, CallJs>::EmptyFunctionFactory(
    Napi::Env /*env*/) {
  return nullptr;
}

// static
template <typename ContextType,
          typename DataType,
          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>
Napi::Function
TypedThreadSafeFunction<ContextType, DataType, CallJs>::FunctionOrEmpty(
    Napi::Env /*env*/, Napi::Function& callback) {
  return callback;
}

#endif

////////////////////////////////////////////////////////////////////////////////
// ThreadSafeFunction class
////////////////////////////////////////////////////////////////////////////////

// static
template <typename ResourceString>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount) {
  return New(
      env, callback, Object(), resourceName, maxQueueSize, initialThreadCount);
}

// static
template <typename ResourceString, typename ContextType>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  ContextType* context) {
  return New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context);
}

// static
template <typename ResourceString, typename Finalizer>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  Finalizer finalizeCallback) {
  return New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             finalizeCallback);
}

// static
template <typename ResourceString,
          typename Finalizer,
          typename FinalizerDataType>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data) {
  return New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             finalizeCallback,
             data);
}

// static
template <typename ResourceString, typename ContextType, typename Finalizer>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback) {
  return New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context,
             finalizeCallback);
}

// static
template <typename ResourceString,
          typename ContextType,
          typename Finalizer,
          typename FinalizerDataType>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data) {
  return New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context,
             finalizeCallback,
             data);
}

// static
template <typename ResourceString>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  const Object& resource,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount) {
  return New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             static_cast<void*>(nullptr) /* context */);
}

// static
template <typename ResourceString, typename ContextType>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  const Object& resource,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  ContextType* context) {
  return New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context,
             [](Env, ContextType*) {} /* empty finalizer */);
}

// static
template <typename ResourceString, typename Finalizer>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  const Object& resource,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  Finalizer finalizeCallback) {
  return New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             static_cast<void*>(nullptr) /* context */,
             finalizeCallback,
             static_cast<void*>(nullptr) /* data */,
             details::ThreadSafeFinalize<void, Finalizer>::Wrapper);
}

// static
template <typename ResourceString,
          typename Finalizer,
          typename FinalizerDataType>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  const Object& resource,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data) {
  return New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             static_cast<void*>(nullptr) /* context */,
             finalizeCallback,
             data,
             details::ThreadSafeFinalize<void, Finalizer, FinalizerDataType>::
                 FinalizeWrapperWithData);
}

// static
template <typename ResourceString, typename ContextType, typename Finalizer>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  const Object& resource,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback) {
  return New(
      env,
      callback,
      resource,
      resourceName,
      maxQueueSize,
      initialThreadCount,
      context,
      finalizeCallback,
      static_cast<void*>(nullptr) /* data */,
      details::ThreadSafeFinalize<ContextType,
                                  Finalizer>::FinalizeWrapperWithContext);
}

// static
template <typename ResourceString,
          typename ContextType,
          typename Finalizer,
          typename FinalizerDataType>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  const Object& resource,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data) {
  return New(
      env,
      callback,
      resource,
      resourceName,
      maxQueueSize,
      initialThreadCount,
      context,
      finalizeCallback,
      data,
      details::ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>::
          FinalizeFinalizeWrapperWithDataAndContext);
}

inline ThreadSafeFunction::ThreadSafeFunction() : _tsfn() {}

inline ThreadSafeFunction::ThreadSafeFunction(napi_threadsafe_function tsfn)
    : _tsfn(tsfn) {}

inline ThreadSafeFunction::operator napi_threadsafe_function() const {
  return _tsfn;
}

inline napi_status ThreadSafeFunction::BlockingCall() const {
  return CallInternal(nullptr, napi_tsfn_blocking);
}

template <>
inline napi_status ThreadSafeFunction::BlockingCall(void* data) const {
  return napi_call_threadsafe_function(_tsfn, data, napi_tsfn_blocking);
}

template <typename Callback>
inline napi_status ThreadSafeFunction::BlockingCall(Callback callback) const {
  return CallInternal(new CallbackWrapper(callback), napi_tsfn_blocking);
}

template <typename DataType, typename Callback>
inline napi_status ThreadSafeFunction::BlockingCall(DataType* data,
                                                    Callback callback) const {
  auto wrapper = [data, callback](Env env, Function jsCallback) {
    callback(env, jsCallback, data);
  };
  return CallInternal(new CallbackWrapper(wrapper), napi_tsfn_blocking);
}

inline napi_status ThreadSafeFunction::NonBlockingCall() const {
  return CallInternal(nullptr, napi_tsfn_nonblocking);
}

template <>
inline napi_status ThreadSafeFunction::NonBlockingCall(void* data) const {
  return napi_call_threadsafe_function(_tsfn, data, napi_tsfn_nonblocking);
}

template <typename Callback>
inline napi_status ThreadSafeFunction::NonBlockingCall(
    Callback callback) const {
  return CallInternal(new CallbackWrapper(callback), napi_tsfn_nonblocking);
}

template <typename DataType, typename Callback>
inline napi_status ThreadSafeFunction::NonBlockingCall(
    DataType* data, Callback callback) const {
  auto wrapper = [data, callback](Env env, Function jsCallback) {
    callback(env, jsCallback, data);
  };
  return CallInternal(new CallbackWrapper(wrapper), napi_tsfn_nonblocking);
}

inline void ThreadSafeFunction::Ref(napi_env env) const {
  if (_tsfn != nullptr) {
    napi_status status = napi_ref_threadsafe_function(env, _tsfn);
    NAPI_THROW_IF_FAILED_VOID(env, status);
  }
}

inline void ThreadSafeFunction::Unref(napi_env env) const {
  if (_tsfn != nullptr) {
    napi_status status = napi_unref_threadsafe_function(env, _tsfn);
    NAPI_THROW_IF_FAILED_VOID(env, status);
  }
}

inline napi_status ThreadSafeFunction::Acquire() const {
  return napi_acquire_threadsafe_function(_tsfn);
}

inline napi_status ThreadSafeFunction::Release() const {
  return napi_release_threadsafe_function(_tsfn, napi_tsfn_release);
}

inline napi_status ThreadSafeFunction::Abort() const {
  return napi_release_threadsafe_function(_tsfn, napi_tsfn_abort);
}

inline ThreadSafeFunction::ConvertibleContext ThreadSafeFunction::GetContext()
    const {
  void* context;
  napi_status status = napi_get_threadsafe_function_context(_tsfn, &context);
  NAPI_FATAL_IF_FAILED(status,
                       "ThreadSafeFunction::GetContext",
                       "napi_get_threadsafe_function_context");
  return ConvertibleContext({context});
}

// static
template <typename ResourceString,
          typename ContextType,
          typename Finalizer,
          typename FinalizerDataType>
inline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,
                                                  const Function& callback,
                                                  const Object& resource,
                                                  ResourceString resourceName,
                                                  size_t maxQueueSize,
                                                  size_t initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data,
                                                  napi_finalize wrapper) {
  static_assert(details::can_make_string<ResourceString>::value ||
                    std::is_convertible<ResourceString, napi_value>::value,
                "Resource name should be convertible to the string type");

  ThreadSafeFunction tsfn;
  auto* finalizeData = new details::
      ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>(
          {data, finalizeCallback});
  napi_status status =
      napi_create_threadsafe_function(env,
                                      callback,
                                      resource,
                                      Value::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      finalizeData,
                                      wrapper,
                                      context,
                                      CallJS,
                                      &tsfn._tsfn);
  if (status != napi_ok) {
    delete finalizeData;
    NAPI_THROW_IF_FAILED(env, status, ThreadSafeFunction());
  }

  return tsfn;
}

inline napi_status ThreadSafeFunction::CallInternal(
    CallbackWrapper* callbackWrapper,
    napi_threadsafe_function_call_mode mode) const {
  napi_status status =
      napi_call_threadsafe_function(_tsfn, callbackWrapper, mode);
  if (status != napi_ok && callbackWrapper != nullptr) {
    delete callbackWrapper;
  }

  return status;
}

// static
inline void ThreadSafeFunction::CallJS(napi_env env,
                                       napi_value jsCallback,
                                       void* /* context */,
                                       void* data) {
  if (env == nullptr && jsCallback == nullptr) {
    return;
  }

  if (data != nullptr) {
    auto* callbackWrapper = static_cast<CallbackWrapper*>(data);
    (*callbackWrapper)(env, Function(env, jsCallback));
    delete callbackWrapper;
  } else if (jsCallback != nullptr) {
    Function(env, jsCallback).Call({});
  }
}

////////////////////////////////////////////////////////////////////////////////
// Async Progress Worker Base class
////////////////////////////////////////////////////////////////////////////////
template <typename DataType>
inline AsyncProgressWorkerBase<DataType>::AsyncProgressWorkerBase(
    const Object& receiver,
    const Function& callback,
    const char* resource_name,
    const Object& resource,
    size_t queue_size)
    : AsyncWorker(receiver, callback, resource_name, resource) {
  // Fill all possible arguments to work around ambiguous
  // ThreadSafeFunction::New signatures.
  _tsfn = ThreadSafeFunction::New(callback.Env(),
                                  callback,
                                  resource,
                                  resource_name,
                                  queue_size,
                                  /** initialThreadCount */ 1,
                                  /** context */ this,
                                  OnThreadSafeFunctionFinalize,
                                  /** finalizeData */ this);
}

#if NAPI_VERSION > 4
template <typename DataType>
inline AsyncProgressWorkerBase<DataType>::AsyncProgressWorkerBase(
    Napi::Env env,
    const char* resource_name,
    const Object& resource,
    size_t queue_size)
    : AsyncWorker(env, resource_name, resource) {
  // TODO: Once the changes to make the callback optional for threadsafe
  // functions are available on all versions we can remove the dummy Function
  // here.
  Function callback;
  // Fill all possible arguments to work around ambiguous
  // ThreadSafeFunction::New signatures.
  _tsfn = ThreadSafeFunction::New(env,
                                  callback,
                                  resource,
                                  resource_name,
                                  queue_size,
                                  /** initialThreadCount */ 1,
                                  /** context */ this,
                                  OnThreadSafeFunctionFinalize,
                                  /** finalizeData */ this);
}
#endif

template <typename DataType>
inline AsyncProgressWorkerBase<DataType>::~AsyncProgressWorkerBase() {
  // Abort pending tsfn call.
  // Don't send progress events after we've already completed.
  // It's ok to call ThreadSafeFunction::Abort and ThreadSafeFunction::Release
  // duplicated.
  _tsfn.Abort();
}

template <typename DataType>
inline void AsyncProgressWorkerBase<DataType>::OnAsyncWorkProgress(
    Napi::Env /* env */, Napi::Function /* jsCallback */, void* data) {
  ThreadSafeData* tsd = static_cast<ThreadSafeData*>(data);
  tsd->asyncprogressworker()->OnWorkProgress(tsd->data());
  delete tsd;
}

template <typename DataType>
inline napi_status AsyncProgressWorkerBase<DataType>::NonBlockingCall(
    DataType* data) {
  auto tsd = new AsyncProgressWorkerBase::ThreadSafeData(this, data);
  auto ret = _tsfn.NonBlockingCall(tsd, OnAsyncWorkProgress);
  if (ret != napi_ok) {
    delete tsd;
  }
  return ret;
}

template <typename DataType>
inline void AsyncProgressWorkerBase<DataType>::OnWorkComplete(
    Napi::Env /* env */, napi_status status) {
  _work_completed = true;
  _complete_status = status;
  _tsfn.Release();
}

template <typename DataType>
inline void AsyncProgressWorkerBase<DataType>::OnThreadSafeFunctionFinalize(
    Napi::Env env, void* /* data */, AsyncProgressWorkerBase* context) {
  if (context->_work_completed) {
    context->AsyncWorker::OnWorkComplete(env, context->_complete_status);
  }
}

////////////////////////////////////////////////////////////////////////////////
// Async Progress Worker class
////////////////////////////////////////////////////////////////////////////////
template <class T>
inline AsyncProgressWorker<T>::AsyncProgressWorker(const Function& callback)
    : AsyncProgressWorker(callback, "generic") {}

template <class T>
inline AsyncProgressWorker<T>::AsyncProgressWorker(const Function& callback,
                                                   const char* resource_name)
    : AsyncProgressWorker(
          callback, resource_name, Object::New(callback.Env())) {}

template <class T>
inline AsyncProgressWorker<T>::AsyncProgressWorker(const Function& callback,
                                                   const char* resource_name,
                                                   const Object& resource)
    : AsyncProgressWorker(
          Object::New(callback.Env()), callback, resource_name, resource) {}

template <class T>
inline AsyncProgressWorker<T>::AsyncProgressWorker(const Object& receiver,
                                                   const Function& callback)
    : AsyncProgressWorker(receiver, callback, "generic") {}

template <class T>
inline AsyncProgressWorker<T>::AsyncProgressWorker(const Object& receiver,
                                                   const Function& callback,
                                                   const char* resource_name)
    : AsyncProgressWorker(
          receiver, callback, resource_name, Object::New(callback.Env())) {}

template <class T>
inline AsyncProgressWorker<T>::AsyncProgressWorker(const Object& receiver,
                                                   const Function& callback,
                                                   const char* resource_name,
                                                   const Object& resource)
    : AsyncProgressWorkerBase(receiver, callback, resource0Aâø]ı½
F?†‡œêºz(Ì   \ pl  ò4A2	†bàê=œƒñ<ìâÙDp   O pr— \AA&?¯¢¥Å}mğÙ~i¿ñD   ğÿÿÖ_ ^A‹	¤T›gïŒîø#hÎ   S pŠT  ‡iAşF”,¬«q¾bĞzâ   x|  €AüØ% $Û<îÏKIóò‹p   O p¾m u‘A'U2•ÅTÉ*[eMÙÙ   N pé  tAısúµğüO^g¶“¸çEİ   O pqà á£Aèª	b¦ë#«‚EÍnYã¶Ş   x p]  "¸A·Êƒ	¿’KWg5²”âÓ   O pşá  2ÌA#»¨ox¿_K5·³³@¯ÊØ   N pˆ  úİAn÷6›-èLP.r»š]óØ   O pÎ³ ŠóAÍ¹İ×ÅÅ_ïK`èp   O põ) Ë÷At¦ã(N1yb1îú.ˆp   O p? âBLüòÃ“×G4b jÆ6Ï7ä    pü  üBXU”ŸX «&ôM=O¹Ğ»Ó   O pä· œ8B‚*‰X”§{çVíaE=Ù   ‚ p¢  İ_B«“×•…G‘R ¶CšÁØ   O p+R #ˆB‡M”×î6_ŞPQè“<Ë   Ê p   6’BJ€Ã¾°Š[D9§ÜI.çš   ŠÙ€    Ò•B#™±Hï±%êCFÔÛ&…òp   O pf. ˆÊBwP,p÷±U‘Ôî’:    b   “ï   ×ÑB4ÛæŒ=H0Ñú^*ãTaÌ   \ p^U  ‡éB £ùöh—|µ(] ?úØ   O pÅ EğBuã“‰Ëš¡+“x‡XœÜÓ   O pûP ñòBtÄ£a%/`ãåÃ÷iÅ°=p   O px– ÷CVíÕĞAÀCÕ—ÌõQlÓ   5  pñ  <0Cè"?ùøµ/«Àa]HL¹Ó   _ pa  MIC7PÂU}£ÓŒêç1!¶:¤   ›Î €´  ­NC+[)G:Ÿë½N&j«p   O pğ¨ X`C±pôµÑKú´    b   O pŠ iCµÖ¦ù@Òâcæy¥¶    b   ë pË  ‰|CàİÅû¡Ô;ılÿ; úiâ   ` pb  Õ‘C6	³(Î4 OæVĞq"Ú   N p“%  k¦Cj÷~ÖEÖ%oÏ6äí›sÌ   S p«@  ¸ÇCËL2üâxÎ8› á<Ü=äp   w1
  çC·\XX¬Š|ã†ì¼³ûŸÙ   T pU<  :èC’\´ˆ¦¼Nqávğ    b   K pø  ÁüCÍ²§‚'Æ§ÂøK<gÎaØ   S pbo  oD*6OãÀdŸ°ÑC¶ó¢Ø   íx ò  œ2DÇùÄ6ù%~j"¤ÉHD   ğÿÿ÷h P3D4c_R$2Ù1¸é1CD   ğÿÿ^ ID„À|”»>#sÌzpÙ   T pa  LDOÊNÿ~üúïN=¸ÇÀêßÌ   M p~0  ù[D?„Ù´›cÑ/Å„3ÙáÚ   8 p¥  `_DTä,¼ô¥
mãjrİÈè7Ú   ?&¡  ÇiD*ñ ö<ê“(d`ªXu/ñÙ   Ã pÙ  ÃyD²÷ß«ßO)‰
(úÚ6’Û   † po  Ø|D°ãˆA%ÒGÍOÊ¤	¨ÃìÅp   O pB Ã‡Ds&fúVE–y¤i»•ãÉ    pØ„  İ¿DÌ¼w¥í'Îí5ãM´±1Rs   {€´   eÃDhØé>rò/ñn`‚|·UfØ   ÿ   ÜDÜôó„ÖÃ“6…–Ü¯Š ÷OÛ   † pª  ìŞDì`Í2k6å¾B+n€•Wp   O pú… o[Eñèö:6[œ&|    b   K€ˆ  ~oE„…®¼ĞÓ­3à“å¡à)"p   O pjş *zE½KV¥ÍAQğ'D*>³Ì   O p[ú  ;“EvY°ğ @¨(¤¸%RÔÌ   \ pÓ  ”EW.‡^aöB„ï    b   ƒ®€O   E¡EG°’Õ!PÛğcãí|Ø   O pìO ŸÕE ‚ş–a(äI<E«ØŠYÚ   8 p%  xÚE^HŠ‚d†ö»D§“µìÓ   M p[•  ‡ŞEŞO±!
!#ã$ç˜YÓ   O p™ f9Fc¸²=‘Ém\Ô})°(s   ½øm   ìIFË¨x}ÔÄ 1r3¿ÙØ   ²  ãJFEšÈ7;Wrò+×!Õ1…Ú   N pí'  	hF¦‘.m/‰­PÁ¼Ö%÷ÿ'Û   M pŠ!  ô„F®«¨xR4IpEáŸ1¶%IÛ   R pf%  + FÏá+æ|ºÁh²ÒÌ   O pş  ô¹F±#G"a¯ú"* ã   W p  `¼F”ÕzÅ-É[tŞç„¥İ    p#  XÆFƒíÕgbæñzµ¤@ãÖp   O pm‹ ÎÆF›ËûÀ-RBıbå5ÄIÙ   Ã p  ÍFİòáS+¶mzıØj/Ú   M p*  ÑF
E¾ÁôCîTQhÌ   D€E   ûùFau\‘¼aöèLğ|œ<V—s   O p«· £'GÏU¸uyaƒqÕŸ;(Ì   O pYƒ í(GºòÇÚá;/¯%ß2™è=œÙ   Ã p4  \\GƒÛç–.°\¶¦Ô    pè>  øbG6Aİñ	µXeàqìxØKØ   —Â ,   ’G²ËL;†LYx³J·Ì   D€   ò—Gäª¤î=>µ«$‘‚Jä   ó pİ$  O­GE’r.àeº¾&$òDşÙ   Z pç!  ±G˜Bd€ı§çl¥ú	VÙü á   »D€   µÁG§Öî+ö•G_¨ØÍ_¡ÔÚ   O pÜÇ AöG¨1ÖÕVfP0u¡İ$    pÜ,  ÖúG£ŞÇ¯âZ‘Çöëó ğä   Œ p.  ğúGÉÆ(û€e¢+Mã5»°p·|Ú   O p,“ â HêØŸµ°àsDa”Ñ\Zâ   O pb ÑH¶¦jŠGëEc<Š¯iì˜üp   O p7) h+HR÷áÁŠ)”¢ì+7²Ì    b€	  7H‚ ‰âaZÇìÕQA,‹vµ   < p?  ;Hç;JãÏ{9o¿k±ş    p  5JH"`ä	Oz`úbÓØpp   O pà ¯rH9£)€’/€øŒJÕ`Şä   ’ pÄ  Ğ„HÍ¢Ş?#5j N'€Híã‰Ó   S p2w  ÕHsÂ·[ñ¹•,‘pU“öğtp   O pw8 ˜£H®jÁ¡—_ò¦vja    b   ë pã"  ˆ°Hgú2Òíê½m¤:À    b   7c€)   ÉÂHìVş¦ê~+¬—yÆ²ŒÓ·oÚ   Z p­P  ¨ÈHMœC*ó^  H^EÏõ$p   O pç— ÖËHX¾Ğaú¸ÊÆ‹,)©Û   M p’ö  ò	IA`Û|ı$}ˆÂ„_Ù   ò pø$  ×I¤¹ ~‰Æ#ĞÃªÎ§‘ä   Ï pj  I
@`Ö¡–Îb$¥³·•÷ªä    pé  „IŸZÜDvW'2Æ¦Ú    pŸY  T$IçÑ±#Æ)¨ÌÅ´TNvZáM   ’¢€   c'IÜ=íÙ–êÓÇÑy    b   O pÆª ë2I8OlÅ‹°~ÄcÇÎ†¬Ë   ^ pL  YFIHcN
YdŠ x
ƒwæ]9”Ú   ,   Z[IT˜#ĞokKïYKiõ²¹_á   M ptw  ÌjIB””Pû §j£O©ËièË   \ p‹Q   ~IˆËç[$kNşƒ÷k    b   X €"   T“IÊ¦–Qb¥N¿+û8X1    py9  ¤IÀ‡È”¬PíìäZÿ:    b   Z pø  ëªI&¢ö]+íKÍ€±÷    b   >€µ  "»I­!ígYboM·¨]Ñs’Ì   æC€¾  nÃIû	ãBªãß¾’›u    b   X €^  íIÙğçP`;®€WŞéÒd)p   w½  şğI|ï´µŸ³ÀÎûH™    b   R p§&  ñI,…xV„_ló•O¯a‡Ù   ò p&  ZõI	Äbñúb»å·QNC£#zã   P p.  ıJDK/Ÿ¿2^Íj‰<ôMÃ,ä   š p²  —.J‰ñ¿°ÉtÛúÿ@+»=¯mD   ğÿÿJh Ë?JÀ?nŞKëlf:ã;{Ó   O pĞ WJ]Ê)?	Í[}à”±“Ú…éps   µ9€!   eJÉZ;°`.i7õM5OtQ®1Ë   ƒ pª  ËeJíÈf÷×PUE¡CK
º×ä   ˜ p‚  ÿzJ7[ß™ú’“D™€İ   M p% [ŒJ?—ÃÜ¡ß­¡ö$TFPÚ1s   O p“ ³J»`÷­[?]d„¡ú)lÌ   S p  èÀJG¢^ÆíAd[‡G„,ôp   O p$x œÇJĞ$óa(&»t8ÕÙ   O p)k ÔÑJÓ¶pDìèŒìÒÇˆWŞ   x põ  ³ğJ?.	Lò.LÛoôNæĞá   N pZ   KJáa~¼E-”ŸNÉì‰ÕÌ   O p v-Ké\|Q¨Áì¼'    b   F7€š  ²8K	Ş©ík/k¥çZLk\&DØ   M pxÑ  øDK€1p—Uı®F¯*«–#Ş   x p)	  ƒGKÖòM²f7àÚ‚A¢I)ĞØ   O pä ıaKê•hâ:,š
‰ØÌ=p|p   O p$¼ HlKûÕ«æ*Úü‰á¦ìëœÛ   T p¿%  y~KeŞÙj¶\!1…ä    p|  AKÍÿ‡Y/NÀ‹~9ßä’ßp   O p[C è£Ké>Şƒœl§È®ˆÂÀejTÓ   O p¹w «K¯Øi5±ÄØn¡G5åíÚ   M p~  ²KğnöêßRØIÙŸ}H48Ë   ƒ p  –ËKOiFÀşÒyøcKAZÛngË   ^ pü  ØÙKÏ2Š¤›SÓ®kq‚Ó6)p   O pVC İÛKf:gc~Pn•„N43Ù    pR  ÖìKÄ¿[™åt¾Ø]ù7¶¥ùã   N pÌ%  XïKá}Ì©‘ óÙ½ÔŒ2ç‡ûœÓ   M pv  mLÈiLV+R”¨aèçòZ&Ø   íx Î  ˆ1L†ƒTëˆrşöçåa    b   Õd€    úFLÔ!€dQTO3Œé9q{ØË   N pƒ+  †^L:]xd0Ûiae7å|(_ä   Œ p  !fL~œçígÑ¡éw©|1ìÒp   O p¼İ  ³‰Lö›‚õ!ùWÆ·Ea–€   < pm  ›LÃqÓWëÉ¢mñ€Ì   \ pÃ@  d‘LÑÿÂü™EåÅò³Zz    b   ès€D  ²“Lî¹ã=HH@…ebŞ   O pì» ‘ÅL}¯7CS›‘^ß°WòËÓ   N p»  äÆLØ21ôÊ­³$~ı5X0jÌ   ¨ p,   ÊLß‡äR/ÚjG,âYğÒ´M   o p   ÀÎL.Ğ:„-ù2ø£ù;°ïÛ%p   O p8ò ©æL)L÷Ñš«B¢T+Å   ›Î €¨  èLìhe°`‚I­ø‘æíqh„Ø   [ p0  nöLÉÜ°v‚ñ<å—0oÛp¨ö/Û   S peB  ÿMşnøÜqBkÓ0ªÉ®‚¿ä   ¢ pC  dMŠ{½XÌ¸:*ß°Ío+ä    p  3M' (o="À-Üô×    b   X €  m"MÔŒô­ä;pÊÉ½_¶}­'ä    p˜   ~M>İB•f*1ĞJ÷w˜l»z¾Î   \ pn  \šM”~ÂŸ!5Iiàä   È p{  	¨M{¶^İï.ºŸÒ"äÓ   S pÌ
  '©M‰?jT
´»@G¯	V \s   g€   ¯MÔl+Ç¦»h”÷Oïç°œp   O pÏ  ƒ°MFİaUÎGğMß)Ìå    b   ë pş  ÓMœ¼!"4şÛÑ¬ZöšñTyÛ   w   IÕM&mGarz³`
ôŸtp   zú  ENA·)Šï1VÌ©’{;C    pâ.  ì	Nêş|ôÿ¿f*}ZáYYs   O pYƒ ÛN òÁ-ãŠ™&½ê
çÎÄjÙ   ò p!  .Nßì4íñ¡ÙÂmò°«½Ù   ò pé  Ã•NoËdwôèXÛãq€ş¬D   ğÿÿ…n ›Ni•·ávNöù'¿q<·	s   O pCg rŸN]ˆ‚ş(MçØ™€M“1s   8€    –¦NÂ}ÌáoO Íêú'}Gp   y pæ  ùObEx8Ó²mjÕ”Yü:l®Ì    b€3  ‰OËwüVX ‚3½Á(¦ÃË   Ï  p
  ¨-Ok'ªYˆr)¤R|Œ»˜~Ì    pÆ  ,0O¡ï~‚UuU¾uq    b   xÑ   |dOb0Ñô´ 1:ÈÛ*[Ú   M pí˜  RlO÷FnŒ7¯şs0Òí»ØwºÌ   O p8x ïqOŞbÒÄ‡äTTãRTñ1~İšs   O p Æ|Oe,Ş¶<E´©©¹WË   ƒ p  º€Oxæ‚t±Ã˜´’¹Ã5ê,™Ì   O pÚ ¢—Oéµ7£…7ÄÍ•£½²àã   O pC É¤Oí;(İïÊƒJ5Lİ/Dä    pà  ¾°OeÓ×şÈåkÍÕU`*Ø   Q p  'ÆO„àUN„|yoÆËÛ<qØ   O pÅñ  kFP’Å'C¿\cĞÍá’Ü×Ù   M p³‡  kOPMK{Úeü)dl^™ä   Ó p¿   QP¯$·<$¿&»ÍéÈ­µMÀp   O pq´  ¦P€Lö5€5c[»¦ä”oÅp   Z pLB  ş§P$nÄü;àkw ‰Xnã&Ó   ¦Â    Ö°P¾ã
âX[p?y´™àØ   O pN< û¹PÊ°ş¢Æì"¢ä„³E_s   D‡€   ¸»P²\Œ¼³^^}R    b   b€B   ÎØPùëª"ÀxÖ1w Ÿ&RÙÎ   Z pR  ãQhÚÆ9‡ëTù BíÕLÙá   M p½ Q%ı#'àİì±†‹y}óBİ   O pW½  ê?Q‚¦ éÑS¿	ï†<ØxmS6Ó   R pñ#  àFQÿT$ÛÅ6'şÜ×Ü1šN İ   Ü pê  øRQ+BòÚAı.àñûòLÎ   M p  SQ©çAPXÛÖìà®UĞ¯ã´Ù   ò p   *ˆQ@¨¾ÊF"pC–¢cÜ£Û   Z pG  €ŠQÓ‘R_˜{¹±ƒ½Ñ4Éc’Ú   T pÚ;  ı¼Qµwª,ûœã"cmGİ   M p ¥ÌQÕU¢õğU¦Ùoî†i.\kä   – p+  5RBõ‘ÉC|@X]’x    pİ#  R®òÅïî©Êë§¨òëR%Ù   ‚ pö  ZR9³?«/>l-wQÉßwòÌ   ÃE€   {(R†7*3|[0ì>â~p   O ptô <2Ry5û÷0ÑooıÄr-    b   ï    FcRÎ]<şa9Â5¨Uê_!,6ã   b p!   gcR¢ àƒæOh)ÿ¾	*O¿áÌ   O pi¸ %zR©se¹¹¿Øî¹²o$ÁGp   O pÅê  €R6œÀĞSEæì.¼#ZßwzÓ   O p‚¨  m‰RiA ÂodqÊäœ!àj~;Û   O pëÊ 3 RÎ~•{‡RŠ/èÚ*2ÆÑÓ   S p¡"  ¬Ryd®‘¿Ê*2¶ïøoD   ğÿÿÌU ë¯RĞ1ì…êE”Jö‹L    py   ÍÎR«Õîm™é·ºë°(Ê©$Ú   Q pÁ  !çRŒÿÕ:icEı<‹4(OÚ   O phß  ÈêRfş3]JÛş¼šA½åKºÀp   O pë Ë;S?]LHıÜ¯šëöåIFã   O pÃ gSá‘ø€ÃÖàš¶7»ánŠÚ   M pÀ  ıÚS˜Ë2r´oB 8†8iÿÎ‘Ë   O pô½ òSÃ]pãuçnOñŸùÛxêØ   M p]2  TjUÁh¢üTÌú-µ„9wçyÛ   † p`  †T™Üçl_]ğĞş[Ôîs–wä    p•  ô(Tlœ!rı”ô5î¶nJ÷ØÓ   \ pÍ^  X.TóuZh!¬~¢Â¡sÌ   O pm‰ +=T”‰´a!äª0 ä    b   µx€   ·ETá.XWªfåUî/Ù    b   r’    RNTújxñI%ˆh\ñn„/ä   ó p“  TTô›P€L²ó>|ñz3À‚÷Ó   O pb6 ET™¨¶«ÊûÍ÷Gº)? «Ø   	w ô   =—T^îºP¿¤u Æ È?İD   ğÿÿB[ ù³T ´¼E2RŸ¶.—‰[bcË   ^ pª  jÁTâıµiêöütŞ+ØßƒyÌ   z p4  ÚÎTf´¥©Øó°ò„š¹    b   b€1   ÇáTA~ïÑáì‹Òı†³1}?ëÌ   \ pP  ½óTBugb8’’Â€§Š·s   ñB€G   èôTŞ˜Iº¡3²Z¡¬    b   T p©c  9"U£¦5?ô‚O÷g‚_‡qª>    p‰&  åTUğ{4äSB
½fë»e<T §p   O p)m WZUu*m›<rtwLöf©z    pH;  ÷rUƒ7t-ùzõJPÊ˜É–bp   O pÌ¨ 	wUí±‡–vºğy\í ÄîûKÌ   \ pˆ
  öwU­ØYß¼[‰â˜6Å*³ã   _ p½  T›U ÿûÿ¤¿F¢!1(ÜÌ   € pS  /¢UÉí¼lbG…À—çÙn²*Ì   ] p¢  A¤U«QÏñ†ê|½ıØÚ	uenä   ˜ p\  ëÃUÀ‡ÌçõÚoÏÜ²qêä   ó pÂ#  `ÈU²îMÛø´€é¬¨£Ds   ÷‚€   ÊUD©«=»¹ÕéÈ:Ã/    pb  4ÚUãµåv:¯¨¡i24+eZÓ   M pAQ  %ÛU¬ÓäzX'ğ?0ô>Ë    b   ?€    0ãU!“KZ;AA0M†øauÛ   Á p<  jåU1*ÜñÍ2@6'}i=_    p×H  uùUnºXã4¤Gçıù\â   u pÑ  î#VÙ%VOYÔiÃçæAUfip   O pú‰ àdVjÆ’ ½IüêŞMJı±Ì   S pÙ  sVAn-¾¦ÜĞ XèışìDpÓ   _ p5  àƒV’%ÄÏzşÆ€ãv¦‚×    põ˜  "Vf&xPd‰µ¿:ó=Æƒİ   O p‘á  —V4ÂfÊ
i¾›«7?TË?Ø   O pn C©VÌ¢n¦R8,ëÍ…á—    b   ë pR  Z¸VèõvqYn×P2C‰ÓãZÙ   ‚ pW  SğV°ĞF: »!_b(M)Â†ä   – p+  †úVMRa`_œ’[#l¥¬W÷Û   O p ¾ûVÓ;ƒ>Ø_çÀàXA    b   ë p†+  õW0)¢¢««¼vú}®s   K pY  HWŸËP®×
;ß¥ŞJÆ
Ù   ‚ pG  "W>çÙ…ÁW¶B‘^„÷ä    pN  |kW`*kSï³{&5âË¼7ñ‚Û   M pğ˜  ŸpW·Â åèY"—«{J­Ø   O pEu uWº5UZÜEl4â[VÙ   f    w~WëË“¥E$
ènã—“›õ’Ì   | p  É’W¨¡œM‘=¾U·¼ãQÀRÇ~p   O p2 “W¬®†œ÷•z™°º–?Ô?ä    pÜ  A¨Wm.ÑWò(¦w†ˆÏ(ä   ” p”  ÃÑWßÚ¼.¡È.Üh“+Ã0iØ   S p_p  'ßW	k­'x­v$E7j    b   ™Œ€õ  âW3£ì–f®ÒjEÿ„$f¿Ó   à¦   AXŸ8©.4’Ì`•XÄ†¢DÙ   ‚ p-  [+X¼j(€XİĞ³r>L[IÌ   M pAx  ö5X
‘~ñüƒ™ÂNêQYÍ>Êp   O p¥ ]KX7>Üµ¨kyæn!/š{tØ   R pÓ  ,VX¦nÿİ_TeVŸé`€ã   íx   ÄfXØßr„ëroíjîÌ__`ßs   ¼ø7  [–X21öÍí‹äÎ+#RB=Mp   zúš  F£X»¸ )¬ú=ÀV­Ş.Ë   M pNc  ]çX»°ì†àbš|‹d­    b   3€   &ïXXäQ¼KaŸ%SçQË©WÛ   T pš  ¬ïXÑƒ¡DÍbx0Š°IdS9   < p›  bYœ‚1–U&¼=éÖ‰¤Ù   ò p  ÇYT66Š‰å•Ñ¦ô“§×ãä   ™ p«  !YÈİÃT¯Ínš'QóÚÚp   O p™5 »&YÃT¿[´b‹^	—¶¿§BÌ   M phÚ  ™IYfâß¦T—!ÀvY    b   O p ^ R‘YS0OvOfºj‹‹zèÛ   O p‘x ”­YÖ¿F‚¤~òéÏZóûß    pëd  :Z£¿¾jD^íVLc•cµ¢Ó   O p·}  îFZÛë¢ğ0xàúV¦ÒâÆY	p   O pŠ hKZ=PÄ+áßZì¿˜ØÎ&÷°Ú   O pãº EPZ•İœŸ§³£\•ò«ÖI³p   O pİN gbZYˆ­íQ’[‡­ùû"XD   ğÿÿqa U…Z+=cNòü¦`Öä   Œ p`  ³Z%üu6YÈŒ0•ÎØ   O p	À ‹˜ZŞï-ã™Àh˜(‡„µxó    pÆ^  «Zà]¦àÔJ£EÀ>    b   ë pa   Ç­ZyçNQ}S[Ò÷¤ø<‘wÎÌ   f p¸  ÎÜZè»öP#4ÊÖ:ßÃğH®s   Ìô€±  ìïZ ±¸²vÿGó}[    b   X €G	  [~Ô2ïº2Şl9Å:K+”;zÙ   N pÚ  Š
[Ó~¾±8€=‚SG²Àp   O p& Â![6euo3¿ö2×v -    pßƒ  g+[l@y“¢ì2KáüêísÔ Ù   Ã p¾  Ó5[ÕGu*H.’ë&ï^ÄK]Ì   | pÿ  QB[Ğ˜ù
Fe1+®jîÚ   O p®t wL[ä€¤	™Ğz5B^1OMD   ğÿÿªc „L[ WH‹µÑfâ=À±g¤â   O pà Ÿ[££³™^ëAˆŒÓ{t]õÙ   S p¿\  ƒ [ÃtØ^Dùšƒ¿JÅFÌ   O p, ²µ[ç,ÎO—;o    Í   Q    ªÏ[Nækêƒ`Õe