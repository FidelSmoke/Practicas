'use strict';

var test = require('tape');
var qs = require('../');
var utils = require('../lib/utils');
var iconv = require('iconv-lite');
var SaferBuffer = require('safer-buffer').Buffer;
var hasSymbols = require('has-symbols');
var mockProperty = require('mock-property');
var emptyTestCases = require('./empty-keys-cases').emptyTestCases;
var hasBigInt = typeof BigInt === 'function';

test('stringify()', function (t) {
    t.test('stringifies a querystring object', function (st) {
        st.equal(qs.stringify({ a: 'b' }), 'a=b');
        st.equal(qs.stringify({ a: 1 }), 'a=1');
        st.equal(qs.stringify({ a: 1, b: 2 }), 'a=1&b=2');
        st.equal(qs.stringify({ a: 'A_Z' }), 'a=A_Z');
        st.equal(qs.stringify({ a: 'â‚¬' }), 'a=%E2%82%AC');
        st.equal(qs.stringify({ a: 'î€€' }), 'a=%EE%80%80');
        st.equal(qs.stringify({ a: '×' }), 'a=%D7%90');
        st.equal(qs.stringify({ a: 'ğ·' }), 'a=%F0%90%90%B7');
        st.end();
    });

    t.test('stringifies falsy values', function (st) {
        st.equal(qs.stringify(undefined), '');
        st.equal(qs.stringify(null), '');
        st.equal(qs.stringify(null, { strictNullHandling: true }), '');
        st.equal(qs.stringify(false), '');
        st.equal(qs.stringify(0), '');
        st.end();
    });

    t.test('stringifies symbols', { skip: !hasSymbols() }, function (st) {
        st.equal(qs.stringify(Symbol.iterator), '');
        st.equal(qs.stringify([Symbol.iterator]), '0=Symbol%28Symbol.iterator%29');
        st.equal(qs.stringify({ a: Symbol.iterator }), 'a=Symbol%28Symbol.iterator%29');
        st.equal(
            qs.stringify({ a: [Symbol.iterator] }, { encodeValuesOnly: true, arrayFormat: 'brackets' }),
            'a[]=Symbol%28Symbol.iterator%29'
        );
        st.end();
    });

    t.test('stringifies bigints', { skip: !hasBigInt }, function (st) {
        var three = BigInt(3);
        var encodeWithN = function (value, defaultEncoder, charset) {
            var result = defaultEncoder(value, defaultEncoder, charset);
            return typeof value === 'bigint' ? result + 'n' : result;
        };
        st.equal(qs.stringify(three), '');
        st.equal(qs.stringify([three]), '0=3');
        st.equal(qs.stringify([three], { encoder: encodeWithN }), '0=3n');
        st.equal(qs.stringify({ a: three }), 'a=3');
        st.equal(qs.stringify({ a: three }, { encoder: encodeWithN }), 'a=3n');
        st.equal(
            qs.stringify({ a: [three] }, { encodeValuesOnly: true, arrayFormat: 'brackets' }),
            'a[]=3'
        );
        st.equal(
            qs.stringify({ a: [three] }, { encodeValuesOnly: true, encoder: encodeWithN, arrayFormat: 'brackets' }),
            'a[]=3n'
        );
        st.end();
    });

    t.test('encodes dot in key of object when encodeDotInKeys and allowDots is provided', function (st) {
        st.equal(
            qs.stringify(
                { 'name.obj': { first: 'John', last: 'Doe' } },
                { allowDots: false, encodeDotInKeys: false }
            ),
            'name.obj%5Bfirst%5D=John&name.obj%5Blast%5D=Doe',
            'with allowDots false and encodeDotInKeys false'
        );
        st.equal(
            qs.stringify(
                { 'name.obj': { first: 'John', last: 'Doe' } },
                { allowDots: true, encodeDotInKeys: false }
            ),
            'name.obj.first=John&name.obj.last=Doe',
            'with allowDots true and encodeDotInKeys false'
        );
        st.equal(
            qs.stringify(
                { 'name.obj': { first: 'John', last: 'Doe' } },
                { allowDots: false, encodeDotInKeys: true }
            ),
            'name%252Eobj%5Bfirst%5D=John&name%252Eobj%5Blast%5D=Doe',
            'with allowDots false and encodeDotInKeys true'
        );
        st.equal(
            qs.stringify(
                { 'name.obj': { first: 'John', last: 'Doe' } },
                { allowDots: true, encodeDotInKeys: true }
            ),
            'name%252Eobj.first=John&name%252Eobj.last=Doe',
            'with allowDots true and encodeDotInKeys true'
        );

        st.equal(
            qs.stringify(
                { 'name.obj.subobject': { 'first.godly.name': 'John', last: 'Doe' } },
                { allowDots: false, encodeDotInKeys: false }
            ),
            'name.obj.subobject%5Bfirst.godly.name%5D=John&name.obj.subobject%5Blast%5D=Doe',
            'with allowDots false and encodeDotInKeys false'
        );
        st.equal(
            qs.stringify(
                { 'name.obj.subobject': { 'first.godly.name': 'John', last: 'Doe' } },
                { allowDots: true, encodeDotInKeys: false }
            ),
            'name.obj.subobject.first.godly.name=John&name.obj.subobject.last=Doe',
            'with allowDots false and encodeDotInKeys false'
        );
        st.equal(
            qs.stringify(
                { 'name.obj.subobject': { 'first.godly.name': 'John', last: 'Doe' } },
                { allowDots: false, encodeDotInKeys: true }
            ),
            'name%252Eobj%252Esubobject%5Bfirst.godly.name%5D=John&name%252Eobj%252Esubobject%5Blast%5D=Doe',
            'with allowDots false and encodeDotInKeys true'
        );
        st.equal(
            qs.stringify(
                { 'name.obj.subobject': { 'first.godly.name': 'John', last: 'Doe' } },
                { allowDots: true, encodeDotInKeys: true }
            ),
            'name%252Eobj%252Esubobject.first%252Egodly%252Ename=John&name%252Eobj%252Esubobject.last=Doe',
            'with allowDots true and encodeDotInKeys true'
        );

        st.end();
    });

    t.test('should encode dot in key of object, and automatically set allowDots to `true` when encodeDotInKeys is true and allowDots in undefined', function (st) {
        st.equal(
            qs.stringify(
                { 'name.obj.subobject': { 'first.godly.name': 'John', last: 'Doe' } },
                { encodeDotInKeys: true }
            ),
            'name%252Eobj%252Esubobject.first%252Egodly%252Ename=John&name%252Eobj%252Esubobject.last=Doe',
            'with allowDots undefined and encodeDotInKeys true'
        );
        st.end();
    });

    t.test('should encode dot in key of object when encodeDotInKeys and allowDots is provided, and nothing else when encodeValuesOnly is provided', function (st) {
        st.equal(
            qs.stringify({ 'name.obj': { first: 'John', last: 'Doe' } }, {
                encodeDotInKeys: true, allowDots: true, encodeValuesOnly: true
            }),
            'name%2Eobj.first=John&name%2Eobj.last=Doe'
        );

        st.equal(
            qs.stringify({ 'name.obj.subobject': { 'first.godly.name': 'John', last: 'Doe' } }, { allowDots: true, encodeDotInKeys: true, encodeValuesOnly: true }),
            'name%2Eobj%2Esubobject.first%2Egodly%2Ename=John&name%2Eobj%2Esubobject.last=Doe'
        );

        st.end();
    });

    t.test('throws when `commaRoundTrip` is not a boolean', function (st) {
        st['throws'](
            function () { qs.stringify({}, { commaRoundTrip: 'not a boolean' }); },
            TypeError,
            'throws when `commaRoundTrip` is not a boolean'
        );

        st.end();
    });

    t.test('throws when `encodeDotInKeys` is not a boolean', function (st) {
        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { encodeDotInKeys: 'foobar' }); },
            TypeError
        );

        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { encodeDotInKeys: 0 }); },
            TypeError
        );

        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { encodeDotInKeys: NaN }); },
            TypeError
        );

        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { encodeDotInKeys: null }); },
            TypeError
        );

        st.end();
    });

    t.test('adds query prefix', function (st) {
        st.equal(qs.stringify({ a: 'b' }, { addQueryPrefix: true }), '?a=b');
        st.end();
    });

    t.test('with query prefix, outputs blank string given an empty object', function (st) {
        st.equal(qs.stringify({}, { addQueryPrefix: true }), '');
        st.end();
    });

    t.test('stringifies nested falsy values', function (st) {
        st.equal(qs.stringify({ a: { b: { c: null } } }), 'a%5Bb%5D%5Bc%5D=');
        st.equal(qs.stringify({ a: { b: { c: null } } }, { strictNullHandling: true }), 'a%5Bb%5D%5Bc%5D');
        st.equal(qs.stringify({ a: { b: { c: false } } }), 'a%5Bb%5D%5Bc%5D=false');
        st.end();
    });

    t.test('stringifies a nested object', function (st) {
        st.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
        st.equal(qs.stringify({ a: { b: { c: { d: 'e' } } } }), 'a%5Bb%5D%5Bc%5D%5Bd%5D=e');
        st.end();
    });

    t.test('`allowDots` option: stringifies a nested object with dots notation', function (st) {
        st.equal(qs.stringify({ a: { b: 'c' } }, { allowDots: true }), 'a.b=c');
        st.equal(qs.stringify({ a: { b: { c: { d: 'e' } } } }, { allowDots: true }), 'a.b.c.d=e');
        st.end();
    });

    t.test('stringifies an array value', function (st) {
        st.equal(
            qs.stringify({ a: ['b', 'c', 'd'] }, { arrayFormat: 'indices' }),
            'a%5B0%5D=b&a%5B1%5D=c&a%5B2%5D=d',
            'indices => indices'
        );
        st.equal(
            qs.stringify({ a: ['b', 'c', 'd'] }, { arrayFormat: 'brackets' }),
            'a%5B%5D=b&a%5B%5D=c&a%5B%5D=d',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify({ a: ['b', 'c', 'd'] }, { arrayFormat: 'comma' }),
            'a=b%2Cc%2Cd',
            'comma => comma'
        );
        st.equal(
            qs.stringify({ a: ['b', 'c', 'd'] }, { arrayFormat: 'comma', commaRoundTrip: true }),
            'a=b%2Cc%2Cd',
            'comma round trip => comma'
        );
        st.equal(
            qs.stringify({ a: ['b', 'c', 'd'] }),
            'a%5B0%5D=b&a%5B1%5D=c&a%5B2%5D=d',
            'default => indices'
        );
        st.end();
    });

    t.test('`skipNulls` option', function (st) {
        st.equal(
            qs.stringify({ a: 'b', c: null }, { skipNulls: true }),
            'a=b',
            'omits nulls when asked'
        );

        st.equal(
            qs.stringify({ a: { b: 'c', d: null } }, { skipNulls: true }),
            'a%5Bb%5D=c',
            'omits nested nulls when asked'
        );

        st.end();
    });

    t.test('omits array indices when asked', function (st) {
        st.equal(qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false }), 'a=b&a=c&a=d');

        st.end();
    });

    t.test('omits object key/value pair when value is empty array', function (st) {
        st.equal(qs.stringify({ a: [], b: 'zz' }), 'b=zz');

        st.end();
    });

    t.test('should not omit object key/value pair when value is empty array and when asked', function (st) {
        st.equal(qs.stringify({ a: [], b: 'zz' }), 'b=zz');
        st.equal(qs.stringify({ a: [], b: 'zz' }, { allowEmptyArrays: false }), 'b=zz');
        st.equal(qs.stringify({ a: [], b: 'zz' }, { allowEmptyArrays: true }), 'a[]&b=zz');

        st.end();
    });

    t.test('should throw when allowEmptyArrays is not of type boolean', function (st) {
        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { allowEmptyArrays: 'foobar' }); },
            TypeError
        );

        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { allowEmptyArrays: 0 }); },
            TypeError
        );

        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { allowEmptyArrays: NaN }); },
            TypeError
        );

        st['throws'](
            function () { qs.stringify({ a: [], b: 'zz' }, { allowEmptyArrays: null }); },
            TypeError
        );

        st.end();
    });

    t.test('allowEmptyArrays + strictNullHandling', function (st) {
        st.equal(
            qs.stringify(
                { testEmptyArray: [] },
                { strictNullHandling: true, allowEmptyArrays: true }
            ),
            'testEmptyArray[#”FÏCöB«š"#Aú@ºvÓeæÉ2¦7İ{Ci ÃBŠ=ßúŒè˜?+Øƒ˜Äß|^»Æ³é­´øı”CR¾˜6‘X.sS@Hìî¦¶Ó¤`3
ætÁÁ:?)ìXìLnŠøßS0Tìí)r¼ŠŸF]ğ£G£'`€Ùš [N!Şöï “¿ÉK®éNÒï‡®ş í¸è¿aşÿ#üÙ± DÇf[}¡¨rG$ğIB§Ø¦¹¡Ôïo:ryŸopáq“¤Ö¾‹qéjC.¬è–OŸûR5t^×y#†„æ—C¾Öç>\ú—„ÛëwDÉï%ƒÑã9gã¬ÊÖS®ùÄ½Ú ®J½{ODĞñoªi8ÂÄw«Èù]+P©ĞÍÕÑ>ÂÉ—â(èr¨ïOÈª.ÇÑ¯ps)ãûxÌ%40ncV­šR\9èœÁ–ày«Œ™ÏPªp=üHgŠ£y|ÔP	º€Aú†À'j)ØµCèñfw*,“…¼:.g,@Vƒ?ª’H-íN¦|ê'1Q ‰m§!ãÔ[OOõçİşæŞÇº§ Ñ
­gğíG]y)'	&ëTnß?ı´}şïù+$ÛüšñQŒ¤ªãI5ğ£¯=¢I+z³ÄCQ:{:¶çq…?’ó{	­$)Q’á“xb†ögC–ş³‡ÿ§C{÷¡‚‘Ğ|éCëB/cÄÛ|kA¿«U0IÉ¶ô÷ì´Í/2ÃoHhÈû«ñëëee O-ùY ç]9ô€` ­’E¶*¡Àñş¼¼–Õ™Ş84™ŒKYİô‹PŸ‡‚FÈ^â×ã«­*›Çğ+Î!×‹.E
ÊåÊæÈ¥a<Àj^‹;2uxâã7²£¸­ù â‘èNzM@..¨sÄ™ÓÅ_óz¡õS'zßWòy™™f¦{wQ¾AnÙ’ï{}9íS	€ÏÄÊ
±$äbÁ•LLæ1c/ê¹	?’­Äğ<5/ŞM;ôî]»­e7ñ‘GãQ3¡ñPû6ÓÅz&añLlÒ:9/€óJUP*x`§¼E«Mmálğºƒ°û§Á#Ëî±"9 WvPs]£ØÍšˆîXr+£T³+²²·p‡à"1Mc„¡6dRœ4„ÇM#Ïc“lCâ‚4bŸÓçqù[]P3Wzú˜0ä÷x¬+q›ZXşy¤yŸ±f2ıEÿğÆ°j¯,-ã[;)1j“V§ÏKm2†QPíPKÿ³™Iê1Ü
c¸şÛN–!¦wx‹äbµŞ4t‘h3È2#,˜‹Å×îH£ÁJc›S7-`T˜O|‘Û^2’d»)…?)¨.ˆeVÔ†0ÈÙ}Šm,”9g&*ÉJQ¤Îåó ø;GõTP¥$ğà¦É½,@ô°&mu	¼„JAE
³nw {>>d²¶qßü-%³õvCË—ºm§ƒbWÓB@Á§~"Äå± ÚÕ§äg‹8{ª'±`ïDùœ<®C|‚WEºşòû=gºsn†|Î¤­nR8k·o‘ e™ï‹3‚›T ¦İ&æè˜!P¥ã=^RA=ƒMŞ-§‘É÷×J9§@nÑ¦´}] \ Êb<^(‘‹¹#£ÁET€1…_b$Sı 8<ëş@ü¹
şeâıf6ŠÃ¥ÒHr~ ¥:&îÌï@¯kŠñNÔ0/a©”Ôp_¡9(ÒU¬¾e|ñË0çKBÍšCóË"³¬ëÀ‰è3™Wf¨v@jsÅ2ÌıÀ1FÀÕ&s‡€Ëj¹4¢ğñ;n8×`5Ñã-´‡Kl±@õ”(šVØ‡¦T S<ED’ŠæÿØHóá#µÃF#»kP®ö&÷H>ÎZ¢	b£Œ;”udáºjøï±°,9e@-Q‰Y8"Ï¦ÁÖÑ’Û”çAƒÉıê×9kØè¼4@©;B_³mQñ±<jJ–É÷å1·¨¥RLlÅ'}pä&äGÉ¸`Ó>IBV,Ë½mÁş94—R8@SÎ‚ÉóG¥¸½Vñ%b4Ìşdÿ$µ”Œ*Uçd¢J°ùØË§Çé‡d!¯;eå‡9ËÒË„'š
íîÇŒ.€ÅwŸËEì€Ë/“:PÑÖœñ“xäêebÿ	.üo.‘¾sp°¸HÎCÎAzB
AµÜ£ü­=gé¿Æ[İØNc3~¿;÷J“¿hnƒ™¨™eqä0ı¬ËıGá5ÒFËíñ¾Û8d.ñ«å¶ŸŒmAÔ†1É-$ÿW1Â€>˜¦«.œ~Ñ¬×/&}?C`M0ˆçmœ§¯£(û“•4qósêdÑZ“è‰Mvf…ªo¶f@HºÔ¹¤#*#ÁÜDJ„¤ß²¾C„< ©)oÂ†N*¾riÛ£Zâ_0ÕœtYôpàûÊ`QR]Íƒ±îƒiÅz6ñsĞäQëomÃğErm!ì™Àm€‹ÏsÄè1Ãø¾cİËTL+$ÿšS±GìêÒ÷©ÀH_ûúl¸:å2ÑĞåPï²Öù›GCÿt¨±ÈƒNâ[2a7±O†s­gƒlÓU­ÖÕÃi1’`šA>yğÏ1“è}uó}òÑ…£Æ;lÿ"Sû43
òù®˜Bƒšnö’şød|Õi€¨»¤hã‘º;£ Âsê‹½5ı†eeªNÕi¥Y*Èø_°ë::Õüî¬“ÚŸ¾Ù ï…ÿAMü#/J÷‘nl„P¾ÇöQHß±ã¯nİ<¶3m{vâ¦6ßÙ?Ûé)id
¶XÒ€’ˆvŸ¿-Eóı)n§•% ÏÖ)}=ŠQaô	Î°öiæşòà£ï0îƒ‘¬+4­S]ÇğFÎ0*O#OË¯ıQ¶e§uË!³J@oMúÀÅ¶XÇú\³Ïl²Ì„
PÃ´1¼‘ó)€  ñ†lÜkõÅX½´
ÚÏ  †y˜ˆ–™™i†©š¼—º©š§º–š¨|¹ª¸{	Êˆz¹šgxwˆT‰v™©›‰ˆ¹›˜˜©ªº¹Ê¬ºËº¨‡ªª›™™ŠlˆœiYjšÉË°°Ì°	Ì»°Ë
¼ º»Ì»¨«ªœ‡x©ˆˆˆ¨‰ˆ™«š™š»›¹›Ë«†z™Œ˜ª›ˆ—¸™iÀ      À       ¹¼      ¨      —¹¼Ì    —¹»¼°Àˆ©ºË Ì °w™«°ËË »†¸ÊÀ° ÀÀv¨ª°À   vˆºÌÌË v¸ÊÀ ÀÀ€ª
Ë  °À                        ~?M #ˆš»yG½B(ç8TÉ8¨§)òF&‡¯ä»wÑ×–6‚8r„SNIjhÂ½`9öıÆµÁ¥”’´–S8lGIúÍŞí	&Ôÿi6SµÆ+µiôøàvÖ®óÉ:à}‘>âÑåèÇ\i€õı§¡–ÔàÑæ ©Ì¿Ú­­;s¸l.ÍÌ·u$Hé·ëN¸ÜGö€”\ïúšZnÎnÕC¸kxE¹TÈÙQÂq¢i ı©m¨RG›‚Û­.ı’Õ–Ï¯½ÀnF€ØnÒX”Ş"áØëí%[7Àô@{ÎE¸w½'äšl©w[”¤ëœ.Š²h¤œWP‡TXc·\â
Î‚=YÖ(æ ÊËín Ó	İ€ [‚éÜŠÈ‚ƒ"äÓb€~€é÷÷ÀùµA…¤ÔE½o²‹¤qô#Ôµ.7ÉZË§º†-'™İ¹ÖêÀn Ák2ğı½~)İş7k(Áö2;¶áÔP ’âß­¤ÙÍ;ƒ«´ÿ‘P]/[ÓT&ÅëœÔí³Jz8%Cn@lÌWâ2©ªPœ6ÔT6Óµ•‚|‰1°H<mRÊ^Ÿê˜
mn¦
KšËXª­õ7&ú|DÄÊ¢Àmş%6m<PÏäJ:­k[u˜¦Á¯E„´İX³çæÍOĞŞç<¥Ó%Öwñ¼ö5++q@¾<!cÙA§Œı@ ÔÜ¼}<1“9ÖÏ¥RÃæpIŞ9YòPÀ°`^kïTãŒq~€/yÀ6M¾‰ëÂ?²?â°ãfÆÁ® ³¾~@Sû÷d0äƒÿpN.ëkº+³íQ9¡ás•ç€RáŠÓ!Åx3lÜ:‘@–Ê»&á¾/¶i*=’pbTÍO%’ :ÂGòol‡Ø–T¤÷mP`Ÿf…°|N¢ôˆ‡›Ş°û¦»‰xÄc_ZÅ¬F.¯=C¦»`Br¸Z†©2:ı»ä–V×©*rÎM›Nm8+Ú¥ Ôä LÜvU?ÑzC-(Äj%«9pIèeÓ×C¥J• `:nÙAALW¤Ïoÿ˜nŸ!•Ü[2=€ )°<ğš£J÷ö„{Í—Q¯áè±Íu8zGR˜æU²e”•‰81¤“õOHVÖûFf°â½’rãFôlµ]è>Nl¶kğwy€µ :d“Çîm35!çÂCx_rë~¶¡'ag–™¬³¡zş
G‚hÍ®K{ jx3éªç ĞŒ›İFDDÄºTİW#ÀÈŠz„ds±ÉöW×õ °ùt?Øµ’ùş ¿Œ±’¢ ŠğÛÜi$“EApçaÂ5$÷ºñF0Şé±`¨a¥*ú©L5"úü´©(Œ3¸”(|`ä# 1œÚF±ÔŒa¯m8{\]7Û97n:Æs”ã=tÃÁ!ğ9¼± ’M*uc  @¬°Cö?	oT	šŸ€§«^LcH!Nª±Ñ„V%UÍMk"UTInÀ7ez+Ğfû6ßãõ	åş«
³¿!}d6Ö¸WhªŞiıHâ¿¥ªßX½ZRaõ¾EÜñu	Öİ`õÑR.ö¦$-Eî’d¥Í¥«!«a÷/	Ò±Els—oKÇåä1ÔVñ†Óñkê}Z‡Ø/©rg `Ğ±ÑB…ƒ¾âoh¦aŠ$ÑòY¤¾»Øl•—d8¤:îxéÑ|¤ò¤i+İÏûğ í´x¢rß"sD<è ´ÖäÎÔaÌHŸşˆnÕ0QqL©º6Œ?¦	Ñ9ˆBTˆ¬ïµ`n~âŸä#j*Ø×&ÊĞçOÏóïRzä»º¨ø&ªÄs?•
çCä‡èd‹v«Ô–½Wæløw/ˆ#G±+n
€ù¸Œ‡ü®U­_˜hˆ8,£ò¡4Ë¨BÕĞW:•©ğ†('ôO–LøVœQóõ»J­”“"¡—Ã~R× C¾¹O#¶×6-“<¯ı°9{Ö?&±|$÷r€BÀ.# õƒƒR%ÿ–“6"o£œÖÆ.Ò«Ÿ\ûnÆé'B54%¹-ñ T—!_@ZÉ8¦4må5UŠ½gôƒÇZál&¾vWÖÆÒ,Öí/¿ñÓZ½]Â
òdã¶ìõ
´ëØ¹ë9aÛ»ßdn“8H‡ósX0<ì½Ü·Å”h‰ÚZ\É©88¸A) Ë’Á‘K|øÖMAo?Á€…ßv};™’"ûã¨cü‘àèÖôoöÊà{µ7ë°p1õéSÁhM²±Rúø%îC×„¹Õ›ZµÒçğjjâ›Â0áĞù1òÄøª¬câœß3:;})hLœiÉOOÃD$ÿëü¤¡”11Ò§ö”#t©˜€g2Û!©™Á½ßé¹"9âÛ“p°‡.:‹ï¯9¡ÃH‘2•z_Ç\Zù ‚ü\WÎR!%× ñ°VÖáº_ègæØù•¼‹t³ÏŸ›Y5³êÌÊ§š§wª2«ğ_)ŠŞÉ÷€ÂRP}ÿ3¯ÿÒƒ(äí ìÊÑ±Oãe™‚û1‘‰â¯ñMÎ#+GÂÜ@ÀDåHÎ2Ê‘BeCZ·L³;s†Å²A*€ 0"ï€!>ıÈt#Cüğø{5ğR‡5ˆSjM\âa²ºéWô‡‘Mg€zàg:®ñEäGZˆMûÀÈC¢IèÉBha’îğşníƒàuqgÇ‰¼®â£.}ˆK¯úµË&ªBÑûúÂßg\ıêø	ìv}€TÒDœ6û8h­fÛ<[»ÃóŞÇnQ0¬f—Wø9s2¼¦£ç1¶®*»8ÉÉÆÖjµ°‡en
,ß!rHŒØÎ
¨.ZÑJÖ!váHÒ|ÆÆ³…IÙ&±ÜIõ+àßsPÇÿäOå®.é;D†xb_xÆÍ«ËÈª=i ¿Æ1Rhëè$š%[¨¦ŞÌ­}#%äJ¾±X™ı¾…U'ÄXŒwx\"«7›m8VøĞ=nQV¢x ÌQm}m.ú/‰¥¨"{ù§ÓY¬ğO£
å/¿Şå:Ã£Á‡|8îêÙßç 9I•	¢”BDş2?ã©^`ö®ƒĞ¥›¹(Ê’ç(¼Ë¼¹"VÇ@*Èdfÿâ5î%3fQƒ;³šeÓFgeóÊs×úÌ š$ì›=ÒÅ]eÅ^qï%v©áÎíOŸœì©3ßY"%»ô,xIÌ‘K² ôÑ¤1¸¨±¶L=tø İ‡dæ$i©êÏ!ßq3Ï|ş†Ã{‹E@²×$KJ½ê ©µ5–6¼%Kª³eªøİ@ZvÎzÙ­}*¾<D¨ôÕ‡¶wôn8Lo÷¹¼­â¬u‹¾¬p>£¼Ÿâ“[u‡C¼?v
ìwÛ>à)ü¸]3ûÍ’4P¶L±)²+7ö#Dà”BDG`¼)ëÁ”²1håª€D?ÁJ,9Àà‡‰~ù•>Ef@¿æ¢ªfp¢h
óªU‚eKfÉšÊ‹‰ÚÈ‚ÄÊ¥V]x¦GÆq"‡’*	ç&bfxü“Y7Cw«³€»›E-²å<[êYß´xò0Cò©7ê×êæ	4bk ïh¾ÿÕ£˜û3‘ˆg0s"k«—‰TqûR½ÄrµI¡J†t_½B+[ÚŠ>õW^üã¬Bî<g)ˆ©û”SP_’cÌ¿¡uuŸÈö¼GZ¥üµİ8ºÌÄßÇ‚/ğa&å’Ó­LÑ_ÍxuBîªÉ–PÓ´â1‹ÑÑû—*[üSMùêNHKñéL7NVĞ‚¿|ºšûãOÿZù\NğVcò^*¿Pâù"®M$¨m§6â×œÕwÇóB#\§zVù=	ğÁ¯ˆwUµŞ_-û°ĞˆA_œİ?wM9t‘çHücVRkõRû šû#XQ¡òı÷¿ÄĞ¢lı¨aöArïÃaŸİãŞ?ä¾é—{‚O/öy1âb­u¨Ä*ûƒnãïøyĞü»b­U´38Tz$Ât€Ç{è”ƒT–±Çˆ›Rrx½ıw¯õ¥Hs¹ò-g\ì7D ]šŠ2Za$´sXñ~¥Jµ|îæFâ™pr¤«‰µùy _GHRğµhAY.{Ü¾™¤Kµ¬`MÕ¾¡³ÍìÇA±xÍOÂ]shÚFãër¨T÷—Ü.ñµvƒ¥—÷]Wõ!Û)-Àõ§‡±ñé~áø‰mğY±‡k8Å¦õŸ<Šİ²(Öê+Bº—O«ÜÍFIÆÎ&øü Q©GTHD!Ü`ŞC	C$%Úäœ…‡inC’‡«a^™°Vğ×L¿ÁyĞsY[nÄºÀTB6í9 ìvh `†ô£f3*ìgX
ğ×-_ê>—·.à‡Nu-Xeu&Ô¿şÿ¼Œ]!÷‰Ã|¥—'¾?„`K¥å¤[ö2ª^Uàr.ïÏPÂ­/ö%s…‹7‘.â\Å¤™*H{s²Nh_åhÅß°(’P£üŒt•º•~%^_j¹ñ›KÃ²¤şçæ¾¢!'{İ8ã›1œÚò'›ŞCE¾Ç­9–>bqU]É€ÚìãÖÄMC°.±g¥TÛR„¿W«TJµê®g¤‹TÄÌ|5Å±Râ\²ÍõâMuì'!ÆãHEînŠİÚ‰U‰ZÚ8^<ñ]’´9šÜ†]]èÕ›bq	Úüü 'x=!'„,§ê_¢Ùã7)ŒÕÍWmqs(“ğíIÒ‚ì
Å}Ü-qŸø,~7)ve0UÆ¶ªb0pdaêI)Sìw}³~MéÂ¾öp€Ç,t£g–'ÚwZ«©ÁTÀğÏ»‘éÍàQÓ "ÿšø-ØéPyp@Æt°øŞv5›d`ì“\½&Kİâ“&ŠgP(–húã÷Tÿì­å^–zê´-bªU´s\½Şçı_éŸ¦¬qŸ±²Ê(x}Ò ˜ñøî5»tŞ—Pá¡#AÂàŞÎ,ÒDFİ•ªbAk
!hö‘$¡2àmáÀŸä M9âÒü˜¤é‘3ÍÄÓGÉG™&«BÅæ*·ÄIwq3\™£İA•È¤-2â¨ÍYlŒ%t  t§H¶Ö{k‚UZ­'ü…§C\{¦'çşCfÎ+»fäÚÜ:-Æ\
Fv³…Á‡Gn.‡5ÏE¸hxùà¸J°v¿
9ã%H±›Ùê_Q(ây-ÊÍLR-
àÖ,©„¸›ıùìÃÈÅ ò{)Î«» p—tzlˆÜÁôh~´&4ªe6nìtöE]u²ı	v”ìs¿¼-i¼6À9€¼´MÁ!ô5æÊõÁT5ç7öÚÿ­û%É˜;ıTEüOæıå”iI±-še|£–Ñ·Áù{iVÓV±È Ë!(>¨\¹vßÜ¹‘qÃÚÇEÇ#2yA°ŠÔ\A(¹Ä78‚WilruÁ[º…÷qciÈ#ö!¦ŒÛé½E2Í† ˜€ñ„DÏõG1ÌîùÎ§«p\øıÏ ÿ½N¾–»5:ƒ®¥—£A#çÆ}@'1Ò´Ü9«è¸‰1G†7Hìo†éRú#Á2Ö¹(–I^saqœ£™Ì3Åq‡ßhF¾DB0K@irsop³pbï³Å-hAÅöØÉpÌ8(½%è¬Øk ójBïblãã;¤°¬¸‰êr¥¦_šw¯ëÂ?ïWW”H«ØÉÕ™k‰wZÎ<åU6iò.2ªûÛU+,T”|°r[¥•»òL…åÜ«*sÑEF+U—hàtà8Béä>ß>±‰ÑòÄ°GI¢äü¶#ä™J1W:‚F>7–¿Dà@×¬Ø@¾şƒÔì„{C5ApAÇ†¿°õµ}.î%8š—^z…¢	½Ù]jªF˜öa²§<ñÙŸ“àÛ­Ò ³qîâ7£j\=`9¯†i}¸4n°>í¨ğ¶j÷8;õr÷#eø…M<û!­úîß¨‘H˜ê¡øö³ï·«?äİş-X¤ØowÔÈ}×Õ?âU»Ukñu_ ÜİfZ\aèPŒ>úcH2úÈ29]r`!-3».º½EK¦ìhz¾â‹‰©°\Ö?‹ßÄ¸½Ù*Ì1\¶„fñm»<¼âûj@ç]GşúfÀ@ŒKÚÍßàu3˜9S©5?²dÒH‡òPÉàãHcú„2Å>Pøßƒã ÙÌà* ”ÿ°ë’<tÄ×÷ø’ãwÿbïqí£EQâ8¤,Ùë%T"É”7m­`¡WÏ2KÌÇû½9 uìò“lmäİ@cNùİ/ØQ"YqÊ,}DØùƒ,G0'7qç’q/ •±¾¡×Q©àÄ<iˆ´¦ÉØŒõ¡;t¤BJ—îïA2¢ }¹Û~'%5§[æ÷Ü,…£eædò‡$0&Ú{7fü‰§ù¦Õ/m€C×ˆÛŠ³´}Ú…0F%s%Ó2‡×:çiÇöjî{¡ĞÇ ï€e7€­q‘.êtA¦ï³›kïf¼ÁRpm ÌçüÉqñ€b*b ğpÚj$Ÿş/w˜·ã^”¥‡úóÈR`¨À¾|oF~Ù$©çdR…Ö^î“°á7Q’
vjÙ@Ä83òòh~‰¼9$öZF–€ŞE~²†{‚‹/Ë£RÀ•\ñRtd¾[½A—@èebÚöĞtvÚ<’†T„e7¬™¯#$&šlà­;#¿±~û{ùå¡1¼Yâ ú8V¨/Ê³¡Ä¾T|æŠÉZ.@–Xˆï»lu¿N½A¹(‹#ş¬aş±êLËÊá¶×c`ãö^ÖÚõ;2>PKlg°bäVANÀ¯|ú™Õ¿&ß>ä @  †‰ˆ˜—š™j§™™™¨š¼›—©–™˜™™™¨‰¬š˜ŠªšwŠg‰tšf›ªy™Éš‰™¨ª¸ÉÀªÌ¸™wªÈª‰‹˜ix¬xZi¹¸«™ÊÊ°¹Ë©œª«¹ººÈº˜™œÊ—‰¨‰˜™¨š˜ª š˜ª©š¨œ¹š…Š™š¨ª›‰˜™ši    À         ˜
      §      —©»     ‡ª  À ¼‡™Ë Ì  wš©«ËÊ¼€v˜™Ë ¼v˜ËÊÊ Àvˆ«ÀÀ »v˜«ÊÌÀ °Œ	ÌÀÀ                           ì¨€ÛªaÒ¹ì ­Š¬ò€¤€Á•£XMÕ¶ÂXázÿq¬Ÿ“¬, Kqé@™åÑ	/éices', encodeValuesOnly: true }),
            'a[0][b]=c',
            'indices => indices'
        );
        st.equal(
            qs.stringify({ a: [{ b: 'c' }] }, { arrayFormat: 'repeat', encodeValuesOnly: true }),
            'a[b]=c',
            'repeat => repeat'
        );
        st.equal(
            qs.stringify({ a: [{ b: 'c' }] }, { arrayFormat: 'brackets', encodeValuesOnly: true }),
            'a[][b]=c',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify({ a: [{ b: 'c' }] }, { encodeValuesOnly: true }),
            'a[0][b]=c',
            'default => indices'
        );

        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: 'indices', encodeValuesOnly: true }),
            'a[0][b][c][0]=1',
            'indices => indices'
        );
        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: 'repeat', encodeValuesOnly: true }),
            'a[b][c]=1',
            'repeat => repeat'
        );
        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: 'brackets', encodeValuesOnly: true }),
            'a[][b][c][]=1',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { encodeValuesOnly: true }),
            'a[0][b][c][0]=1',
            'default => indices'
        );

        st.end();
    });

    t.test('stringifies an array with mixed objects and primitives', function (st) {
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true, arrayFormat: 'indices' }),
            'a[0][b]=1&a[1]=2&a[2]=3',
            'indices => indices'
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true, arrayFormat: 'brackets' }),
            'a[][b]=1&a[]=2&a[]=3',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true, arrayFormat: 'comma' }),
            '???',
            'brackets => brackets',
            { skip: 'TODO: figure out what this should do' }
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true }),
            'a[0][b]=1&a[1]=2&a[2]=3',
            'default => indices'
        );

        st.end();
    });

    t.test('stringifies an object inside an array with dots notation', function (st) {
        st.equal(
            qs.stringify(
                { a: [{ b: 'c' }] },
                { allowDots: true, encode: false, arrayFormat: 'indices' }
            ),
            'a[0].b=c',
            'indices => indices'
        );
        st.equal(
            qs.stringify(
                { a: [{ b: 'c' }] },
                { allowDots: true, encode: false, arrayFormat: 'brackets' }
            ),
            'a[].b=c',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(
                { a: [{ b: 'c' }] },
                { allowDots: true, encode: false }
            ),
            'a[0].b=c',
            'default => indices'
        );

        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false, arrayFormat: 'indices' }
            ),
            'a[0].b.c[0]=1',
            'indices => indices'
        );
        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false, arrayFormat: 'brackets' }
            ),
            'a[].b.c[]=1',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false }
            ),
            'a[0].b.c[0]=1',
            'default => indices'
        );

        st.end();
    });

    t.test('does not omit object keys when indices = false', function (st) {
        st.equal(qs.stringify({ a: [{ b: 'c' }] }, { indices: false }), 'a%5Bb%5D=c');
        st.end();
    });

    t.test('uses indices notation for arrays when indices=true', function (st) {
        st.equal(qs.stringify({ a: ['b', 'c'] }, { indices: true }), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    });

    t.test('uses indices notation for arrays when no arrayFormat is specified', function (st) {
        st.equal(qs.stringify({ a: ['b', 'c'] }), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    });

    t.test('uses indices notation for arrays when arrayFormat=indices', function (st) {
        st.equal(qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' }), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    });

    t.test('uses repeat notation for arrays when arrayFormat=repeat', function (st) {
        st.equal(qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' }), 'a=b&a=c');
        st.end();
    });

    t.test('uses brackets notation for arrays when arrayFormat=brackets', function (st) {
        st.equal(qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' }), 'a%5B%5D=b&a%5B%5D=c');
        st.end();
    });

    t.test('stringifies a complicated object', function (st) {
        st.equal(qs.stringify({ a: { b: 'c', d: 'e' } }), 'a%5Bb%5D=c&a%5Bd%5D=e');
        st.end();
    });

    t.test('stringifies an empty value', function (st) {
        st.equal(qs.stringify({ a: '' }), 'a=');
        st.equal(qs.stringify({ a: null }, { strictNullHandling: true }), 'a');

        st.equal(qs.stringify({ a: '', b: '' }), 'a=&b=');
        st.equal(qs.stringify({ a: null, b: '' }, { strictNullHandling: true }), 'a&b=');

        st.equal(qs.stringify({ a: { b: '' } }), 'a%5Bb%5D=');
        st.equal(qs.stringify({ a: { b: null } }, { strictNullHandling: true }), 'a%5Bb%5D');
        st.equal(qs.stringify({ a: { b: null } }, { strictNullHandling: false }), 'a%5Bb%5D=');

        st.end();
    });

    t.test('stringifies an empty array in different arrayFormat', function (st) {
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false }), 'b[0]=&c=c');
        // arrayFormat default
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'indices' }), 'b[0]=&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'brackets' }), 'b[]=&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'repeat' }), 'b=&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'comma' }), 'b=&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'comma', commaRoundTrip: true }), 'b[]=&c=c');
        // with strictNullHandling
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'indices', strictNullHandling: true }), 'b[0]&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'brackets', strictNullHandling: true }), 'b[]&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'repeat', strictNullHandling: true }), 'b&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'comma', strictNullHandling: true }), 'b&c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'comma', strictNullHandling: true, commaRoundTrip: true }), 'b[]&c=c');
        // with skipNulls
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'indices', skipNulls: true }), 'c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'brackets', skipNulls: true }), 'c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'repeat', skipNulls: true }), 'c=c');
        st.equal(qs.stringify({ a: [], b: [null], c: 'c' }, { encode: false, arrayFormat: 'comma', skipNulls: true }), 'c=c');

        st.end();
    });

    t.test('stringifies a null object', { skip: !Object.create }, function (st) {
        var obj = Object.create(nulÆ&z³"a-Ú˜D‘ 
ë12zÃR%K.I)kÔ‰pjÇ×E.˜ÿBN¦Ì²E‘Åœöª`¨ùR°.Á½aY><G³tO>¬XĞYÓ’ ÄñB]ÙÑmËc+bšµ‡R=ü½. 8üø*-+Ër}ğÇ—pKÅ¼^’°¡É’QÎãşŞ·eŞ?ùríÎ'–Œ»²éø]_¹íÍ»ñ+é|{÷íê£—¤øÛrÒœ•«MÑ‚¿t½üÖƒgcÚV>fü„‹8[x€SîÃeø>0~  •™™™™©©™§ª™©©Š™š—™º© ªŠ™¨ª©ªªš©¸‡‰x˜ˆ™ˆˆ§ˆ˜™©™™ªhwgwhšvV¦fvˆ‰¨ª™¨šš™ªšš©¸ª«ªª™ºš˜™™«™˜‰¹˜šš™šš«š¨©ª™™ª©™—šª™©™›©·©ºšš©º™¨ª š«ªš»       »       	      ¨y¦     —y˜ º—h˜« › ˆyŠ  ›‹˜‰‡» ° €‡™ª °° †‡š»° «›ˆ¨ª«   ˆˆš
   « ˜Š

  «                        f·ÿ[/ä0®7ë?ÚM17ëE¼ş±ßéò].“†Gí—J¹MÔ«^F Jê£éC¢Â°ÖWL###ßŞµËïâ9(‹/¶3ØS˜@nÈNßNHıàØ¶ÔMj‚‘‘@,cæl¾y¾_¹ÀŞ_“ûwFUhçb¦lU-²U{óÔÈåÓí!;i6ºÅAZˆĞì«j™¤NŞ BzÊİà¬àÈ$Ô®£Ëb.Zï¯à~ÖD±*%ïÖÈƒ\>œAâÇV/khbÎ–+ğ®6½¹3ö¶oıĞ}Å#T<ìÌv?ß¯XŞWm
ÏËøw—ãÌ˜\?X®ŞË¨?¾v}öw%Ì~PèSÛìÚ‡·³Ì3¦¸§f9tôUH¾Ò‹^eä+”'š—¡°ãÅX6R77 ¡ÙQÉ°PÊ4nREDX>St#‘¡õß!pM¥Š„œØ1Ë}‰°<ƒğ×¹¢È˜]b™©AçBÀiA‘7¸vªaÙ¼.äğYîoNLµçsñÛ}'Îˆ;›ALª4ˆ„+€W ¸Õ¾pµ2†G""Âü3""§BWÜÖ«`@Z0p, àÀY¨ë@­
<€qZD_À H2¸ş{ğ«6g.EbÙkìÛ@iLg?ÙK>BâšÄä@HXT'S½PA£?!¥†Y -	§¢+Rƒh¤ŒS¶ƒ*÷£¥|ù	¥†ÂV{ 6Ü$h×>úõ¥T.›T/ Y‰F ùQ:›üQd³F3fgR(pÑ9À1mı*`ÑF@€c%Z¡elà%_¢š%Íj•}	#Ac€‚z¥±2-şµL6‡¾ª“1"v’ø`êÉ9LØr™o[`Uğ$ÄaBàC‚^,VayB‘ğãL¨¥˜"ü…`aÀBêp1˜B–pt*E)PB…x «
1i¢×ö`¯d²ºGÃf‡üf@?³
¨ee Ë¢T‚£yK…vàÂyS;Ó«ã‹T°€q@ãaA¸Á2—ğèsªÅ½8°‚ĞP AÁPy± ÓvV¬n1Ã‘2bJ©8Á×ˆ#U˜‘BK®¥ø2KoÃşòC)‰OéÈcÌŠ˜+S7õº¸;ÿSHyÅç¥ıPÂBÌ¥ &^;­ÙŸ·*<ˆ!˜Ä	g+V…g,ˆçoô#lƒÆ 6?Û§6†„BÒ1S
 jŸ¿€Æy	M†|3 £Fè¹ş9è¦ª¬rø‘vA¦šŒ„4Bœë¹Pøp Î”úá¸x‘õŸx@Bk/(ñø:TzLgKL/Íoß&íœT¹xI¹0yCßnĞy;nÅ'•føòl{=i÷0å.˜ëÊør‰a¶_µ°ÀsÚ®ÇQì÷ô|¤×vOI±ãîû³¡èŸöÀ¹şM.€…’' ÿü(ã9 ôYÙNó¾yÑô®K?¦ÑÕËw°F‹÷×år—öÂ<MWÙàù1zH–“¹ÜÄô9VOç»êKÍ3¾Ğ™pX>¤•¹ªà$÷u}Rs“òºŞ<èiÖiÍk§æÒh¡ÖºğùqÕÔ¢±VjfœªSg­÷¨É‹ß8`w¨pÏA„€1¯‡a	­²æ\ï•Å¡æÀ¡@;ßÄBòÇ›fã±¤6×ZñèÃp8€Xµï—0-T£4†¯ê$ €ásEŒ›6€W4áKÃ®èy¦ihØú(c]Pk2óp$8EPg ((Â…ÀÂDÍ =Àá'¡)ec€.uüŒnòpÖ)*H{Æ´1àÜÁiÚ›¡C<*G>[·¸ará“ÉÂâMsÛxï-GÅA¼öÒA$šM M>4¶ıDTée45cb(0j"L°X,àœÌ8°#«·"\MBÀQÏU !Yìˆ-Dd¡)LäÃı³€¸ÃA®UXnÁphH†‰`ÔŒÓzîÿ¹A:(µj(:ò¦µh:2Òöp€ÏšÇ&GÅ“ˆ<>M¯AHíšµ=Q<G˜	
¦	ÉbpÁT=5‚M¤CŒ†ÏOâq)4´(yIƒeİÅşÒå·0ovµæ¾’nÌ€4dıÇônS<Å¦ZÓ5qh€“%Ø«nZ¡dº;	–©'Dh³hH4ˆk?Ìs¸¬ØàçoäüÕ‹õx€nèîÙ3o|f¢WzEó½¼bîg})n0t.HVºöÍ:¶y’½sg-ú’"¬õ0ğÑ	áR&à[ˆÆFC¸(Ë9
n:Ó*ÒĞ©aÖõÿèA°› ü3ÓB¨DX	£Ø#Ypd!(¢²Ñn† :øYE j{Î# ÷W¹5O â•™Ğ{CwÂ¸ÁUnàÕ'ZbİÚ³WÒ`I9õ&OòiC¶.ê$ïÿêÑ*P·€T–à
·Û $#ûœH·Ö9TuËMFÿT‰%ÁƒmgäU˜Á&@ÀŸ ß{~ ÀŸs3úâãón
Ø®xBHd @]7Ñ)²º'y¨jë•‡%øK˜÷¯Çí‡aH;`†k¡k( €Yœ»Úğ=š'áTÂ°„©UÓT0^95šè•ß@®ŸtF†ıG¹Ğ¿	hK&I¹@€ ÷‰$	´Ã‰~÷dTPô´ ê$P|z>U‚sNÜù…xÀP~­³@|ÂlÍøï8BÚ@§Ü×2šH¡”VBŠæ`*(Jõ²ªIT`ªKsÄŒVATx6¯IFŒdUBfÕL¸GPD `üD¹ªHÜƒ– £ñR`B„Å“?€"
gql»÷"TR‘$²çAìw
Œ*Õ¨&¤
J¡Å%Lğ3­©¨ÿLR˜ËÃ(dŒ@
ê–ÜCuÿ²ÅOéˆûî—ĞCKeõƒÃ½Æ1ß"“!`3fx¡(–&… ~·‹˜j\!{PN-øCB*0œ[Æ’“ŒCß‰°ÛEÿ@ƒ@02$Ys×¹gà^ñR…G3ŒRdC1\
(†ÆT§jå
CæH³š\H‡RÕĞÜ	©hÅ¼öõYÍ)€Ø¨(°”<¡xœFÏØZ£§á'RğcîvÈ¶v§q¢‹=‹\$pşH¼š«R«-€DÀaƒ@h«`@‰ \KÆ¼¦2µ£8èÎÅI=c¥âHõúÀw«ˆÊÔÿãÏã'²h ©PãÆ”4eu=jœy!úhˆc¡GÂ#¬ÂŞ¤ÁµAõ… wÉ4;NGş+¸ 4CfY(ğqúxıNå`‡ˆQ¢‚SB™(’i‘„ê¢´f(!úO>Ñ #~#/˜Šûó¹‚i`ÑQÅü»·€ “2ÂÑ€1/MAG(¶øDÉ©[³Tç á q CMŒR¡Šdşù´YS[=O&’&¶lÉÖÊÃM#ãQ¨sûU·W¾ûz§5¬Édõ(o7;mÌj”ÕÛÉ‹ÚÁ(”Åm›Z¼,eãÙÚ°ƒ¹ÛUW%êv*PûÅ‡0$×zz¥fÿô»P>{Üš€<(:m ƒ7_nÛ„œÖ
h€ù<Q,È™v¢¥5àç‘(
nàÊ(Šó3€"ì¸>\à¨În	ûr¸#‘ÏpL›Fd´éAQÕ‡¸™¢¬lÔ#°…´â§	«X-÷máÃ7ê;ıDjí[­ùÁGñ`„]ğ ¿Vüh»ºc-[µ×>+ùBöÌïo‹%×Ğ»,gÖŞ‘¸‚«Õ»>¹şªê‘•ŸéÅos¤5ÔÒx-şF±ÉˆªßºÙ×ÈÅ2ã;ş·ö›«½Ñ"8°æ?ÜÖkã¸ºÇïé¥*¢Gşëáp«æüÌGrº7ÂÛ¿² ÜP‘V{+ù½…Û8É¿¶éb5Ş·ÄïJÕÕ}úçÂÌ;S5?Ï%s©Î„°hïyi6jœ?0î.1-¹Cwb”`ûpÌÏ˜"æy‚øS>Î&óïˆéDÜ—«š¢ö¤¡*ç0^æÂù]v–™;°ñæP_by! 
úî†#’	%¡àˆö-\‡nm!„…ñ>‰fS ShDAš„nÃÇ8¸æ®GÀÅ¸uÃ!j˜[àóÅã„]l,\µİ–DˆIœ’ÀO¯8ÚhDhB¡ak‰À"4²­¢¸´B,"¸§€ÓX¢IÑhCÚ‡ Ë!:–U³ Î8%å|õñÂÎBp&h:„Æˆ®’ŞüŒ+A€8K)„K¢AĞ¡I¢!€;kuƒìQE—ˆ†Dƒ !B“ìyv¿_ÁHT·,cM%¹….İå»¡ÎãJõîè?œNğy¶´qùæƒ3¨Áçô€Øˆœó-`QEÿ<\wƒÅO`  ',         qùsˆY½¯¡ˆ9Z®Â»ßô ”  ”	ªª©©šº·«šª«šª©°¹š  »™‡˜™™™›¹ª‡‡‡‡‰šw—–yˆš™
Š©gxgxh‰wg–wvˆˆª ™—«
««
™™§ºª©©ª©ª—š¹ªª™šº§ššš›««©‡ª›«ªrguments: [hourOfDay, 23]
        };

        st.equal(
            qs.stringify({ filters: { $and: [p1, p2] } }, { encodeValuesOnly: true, arrayFormat: 'indices' }),
            'filters[$and][0][function]=gte&filters[$and][0][arguments][0][function]=hour_of_day&filters[$and][0][arguments][1]=0&filters[$and][1][function]=lte&filters[$and][1][arguments][0][function]=hour_of_day&filters[$and][1][arguments][1]=23'
        );
        st.equal(
            qs.stringify({ filters: { $and: [p1, p2] } }, { encodeValuesOnly: true, arrayFormat: 'brackets' }),
            'filters[$and][][function]=gte&filters[$and][][arguments][][function]=hour_of_day&filters[$and][][arguments][]=0&filters[$and][][function]=lte&filters[$and][][arguments][][function]=hour_of_day&filters[$and][][arguments][]=23'
        );
        st.equal(
            qs.stringify({ filters: { $and: [p1, p2] } }, { encodeValuesOnly: true, arrayFormat: 'repeat' }),
            'filters[$and][function]=gte&filters[$and][arguments][function]=hour_of_day&filters[$and][arguments]=0&filters[$and][function]=lte&filters[$and][arguments][function]=hour_of_day&filters[$and][arguments]=23'
        );

        st.end();
    });

    t.test('selects properties when filter=array', function (st) {
        st.equal(qs.stringify({ a: 'b' }, { filter: ['a'] }), 'a=b');
        st.equal(qs.stringify({ a: 1 }, { filter: [] }), '');

        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: 'd' }, c: 'f' },
                { filter: ['a', 'b', 0, 2], arrayFormat: 'indices' }
            ),
            'a%5Bb%5D%5B0%5D=1&a%5Bb%5D%5B2%5D=3',
            'indices => indices'
        );
        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: 'd' }, c: 'f' },
                { filter: ['a', 'b', 0, 2], arrayFormat: 'brackets' }
            ),
            'a%5Bb%5D%5B%5D=1&a%5Bb%5D%5B%5D=3',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: 'd' }, c: 'f' },
                { filter: ['a', 'b', 0, 2] }
            ),
            'a%5Bb%5D%5B0%5D=1&a%5Bb%5D%5B2%5D=3',
            'default => indices'
        );

        st.end();
    });

    t.test('supports custom representations when filter=function', function (st) {
        var calls = 0;
        var obj = { a: 'b', c: 'd', e: { f: new Date(1257894000000) } };
        var filterFunc = function (prefix, value) {
            calls += 1;
            if (calls === 1) {
                st.equal(prefix, '', 'prefix is empty');
                st.equal(value, obj);
            } else if (prefix === 'c') {
                return void 0;
            } else if (value instanceof Date) {
                st.equal(prefix, 'e[f]');
                return value.getTime();
            }
            return value;
        };

        st.equal(qs.stringify(obj, { filter: filterFunc }), 'a=b&e%5Bf%5D=1257894000000');
        st.equal(calls, 5);
        st.end();
    });

    t.test('can disable uri encoding', function (st) {
        st.equal(qs.stringify({ a: 'b' }, { encode: false }), 'a=b');
        st.equal(qs.stringify({ a: { b: 'c' } }, { encode: false }), 'a[b]=c');
        st.equal(qs.stringify({ a: 'b', c: null }, { strictNullHandling: true, encode: false }), 'a=b&c');
        st.end();
    });

    t.test('can sort the keys', function (st) {
        var sort = function (a, b) {
            return a.localeCompare(b);
        };
        st.equal(qs.stringify({ a: 'c', z: 'y', b: 'f' }, { sort: sort }), 'a=c&b=f&z=y');
        st.equal(qs.stringify({ a: 'c', z: { j: 'a', i: 'b' }, b: 'f' }, { sort: sort }), 'a=c&b=f&z%5Bi%5D=b&z%5Bj%5D=a');
        st.end();
    });

    t.test('can sort the keys at depth 3 or more too', function (st) {
        var sort = function (a, b) {
            return a.localeCompare(b);
        };
        st.equal(
            qs.stringify(
                { a: 'a', z: { zj: { zjb: 'zjb', zja: 'zja' }, zi: { zib: 'zib', zia: 'zia' } }, b: 'b' },
                { sort: sort, encode: false }
            ),
            'a=a&b=b&z[zi][zia]=zia&z[zi][zib]=zib&z[zj][zja]=zja&z[zj][zjb]=zjb'
        );
        st.equal(
            qs.stringify(
                { a: 'a', z: { zj: { zjb: 'zjb', zja: 'zja' }, zi: { zib: 'zib', zia: 'zia' } }, b: 'b' },
                { sort: null, encode: false }
            ),
            'a=a&z[zj][zjb]=zjb&z[zj][zja]=zja&z[zi][zib]=zib&z[zi][zia]=zia&b=b'
        );
        st.end();
    });

    t.test('can stringify with custom encoding', function (st) {
        st.equal(qs.stringify({ çœŒ: 'å¤§é˜ªåºœ', '': '' }, {
            encoder: function (str) {
                if (str.length === 0) {
                    return '';
                }
                var buf = iconv.encode(str, 'shiftjis');
                var result = [];
                for (var i = 0; i < buf.length; ++i) {
                    result.push(buf.readUInt8(i).toString(16));
                }
                return '%' + result.join('%');
            }
        }), '%8c%a7=%91%e5%8d%e3%95%7b&=');
        st.end();
    });

    t.test('receives the default encoder as a second argument', function (st) {
        st.plan(8);

        qs.stringify({ a: 1, b: new Date(), c: true, d: [1] }, {
            encoder: function (str) {
                st.match(typeof str, /^(?:string|number|boolean)$/);
                return '';
            }
        });

        st.end();
    });

    t.test('receives the default encoder as a second argument', function (st) {
        st.plan(2);

        qs.stringify({ a: 1 }, {
            encoder: function (str, defaultEncoder) {
                st.equal(defaultEncoder, utils.encode);
            }
        });

        st.end();
    });

    t.test('throws error with wrong encoder', function (st) {
        st['throws'](function () {
            qs.stringify({}, { encoder: 'string' });
        }, new TypeError('Encoder has to be a function.'));
        st.end();
    });

    t.test('can use custom encoder for a buffer object', { skip: typeof Buffer === 'undefined' }, function (st) {
        st.equal(qs.stringify({ a: SaferBuffer.from([1]) }, {
            encoder: function (buffer) {
                if (typeof buffer === 'string') {
                    return buffer;
                }
                return String.fromCharCode(buffer.readUInt8(0) + 97);
            }
        }), 'a=b');

        st.equal(qs.stringify({ a: SaferBuffer.from('a b') }, {
            encoder: function (buffer) {
                return buffer;
            }
        }), 'a=a b');
        st.end();
    });

    t.test('serializeDate option', function (st) {
        var date = new Date();
        st.equal(
            qs.stringify({ a: date }),
            'a=' + date.toISOString().replace(/:/g, '%3A'),
            'default is toISOString'
        );

        var mutatedDate = new Date();
        mutatedDate.toISOString = function () {
            throw new SyntaxError();
        };
        st['throws'](function () {
            mutatedDate.toISOString();
        }, SyntaxError);
        st.equal(
            qs.stringify({ a: mutatedDate }),
            'a=' + Date.prototype.toISOString.call(mutatedDate).replace(/:/g, '%3A'),
            'toISOString works even when method is not locally present'
        );

        var specificDate = new Date(6);
        st.equal(
            qs.stringify(
                { a: specificDate },
                { serializeDate: function (d) { return d.getTime() * 7; } }
            ),
            'a=42',
            'custom serializeDate function called'
        );

        st.equal(
            qs.stringify(
                { a: [date] },
                {
                    serializeDate: function (d) { return d.getTime(); },
                    arrayFormat: 'comma'
                }
            ),
            'a=' + date.getTime(),
            'works with arrayFormat comma'
        );
        st.equal(
            qs.stringify(
                { a: [date] },
                {
                    serializeDate: function (d) { return d.getTime(); },
                    arrayFormat: 'comma',
                    commaRoundTrip: true
                }
            ),
            'a%5B%5D=' + date.getTime(),
            'works with arrayFormat comma'
        );

        st.end();
    });

    t.test('RFC 1738 serialization', function (st) {
        st.equal(qs.stringify({ a: 'b c' }, { format: qs.formats.RFC1738 }), 'a=b+c');
        st.equal(qs.stringify({ 'a b': 'c d' }, { format: qs.formats.RFC1738 }), 'a+b=c+d');
        st.equal(qs.stringify({ 'a b': SaferBuffer.from('a b') }, { format: qs.formats.RFC1738 }), 'a+b=a+b');

        st.equal(qs.stringify({ 'foo(ref)': 'bar' }, { format: qs.formats.RFC1738 }), 'foo(ref)=bar');

        st.end();
    });

    t.test('RFC 3986 spaces serialization', function (st) {
        st.equal(qs.stringify({ a: 'b c' }, { format: qs.formats.RFC3986 }), 'a=b%20c');
        st.equal(qs.stringify({ 'a b': 'c d' }, { format: qs.formats.RFC3986 }), 'a%20b=c%20d');
        st.equal(qs.stringify({ 'a b': SaferBuffer.from('a b') }, { format: qs.formats.RFC3986 }), 'a%20b=a%20b');

        st.end();
    });

    t.test('Backward compatibility to RFC 3986', function (st) {
        st.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
        st.equal(qs.stringify({ 'a b': SaferBuffer.from('a b') }), 'a%20b=a%20b');

        st.end();
    });

    t.test('Edge cases and unknown formats', function (st) {
        ['UFO1234', false, 1234, null, {}, []].forEach(function (format) {
            st['throws'](
                function () {
                    qs.stringify({ a: 'b c' }, { format: format });
                },
                new TypeError('Unknown format option provided.')
            );
        });
        st.end();
    });

    t.test('encodeValuesOnly', function (st) {
        st.equal(
            qs.stringify(
                { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
                { encodeValuesOnly: true, arrayFormat: 'indices' }
            ),
            'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h',
            'encodeValuesOnly + indices'
        );
        st.equal(
            qs.stringify(
                { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
                { encodeValuesOnly: true, arrayFormat: 'brackets' }
            ),
            'a=b&c[]=d&c[]=e%3Df&f[][]=g&f[][]=h',
            'encodeValuesOnly + brackets'
        );
        st.equal(
            qs.stringify(
                { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
                { encodeValuesOnly: true, arrayFormat: 'repeat' }
            ),
            'a=b&c=d&c=e%3Df&f=g&f=h',
            'encodeValuesOnly + repeat'
        );

        st.equal(
            qs.stringify(
                { a: 'b', c: ['d', 'e'], f: [['g'], ['h']] },
                { arrayFormat: 'indices' }
            ),
            'a=b&c%5B0%5D=d&c%5B1%5D=e&f%5B0%5D%5B0%5D=g&f%5B1%5D%5B0%5D=h',
            'no encodeValuesOnly + indices'
        );
        st.equal(
            qs.stringify(
                { a: 'b', c: ['d', 'e'], f: [['g'], ['h']] },
                { arrayFormat: 'brackets' }
            ),
            'a=b&c%5B%5D=d&c%5B%5D=e&f%5B%5D%5B%5D=g&f%5B%5D%5B%5D=h',
            'no encodeValuesOnly + brackets'
        );
        st.equal(
            qs.stringify(
                { a: 'b', c: ['d', 'e'], f: [['g'], ['h']] },
                { arrayFormat: 'repeat' }
            ),
            'a=b&c=d&c=e&f=g&f=h',
            'no encodeValuesOnly + repeat'
        );

        st.end();
    });

    t.test('encodeValuesOnly - strictNullHandling', function (st) {
        st.equal(
            qs.stringify(
                { a: { b: null } },
                { encodeValuesOnly: true, strictNullHandling: true }
            ),
            'a[b]'
        );
        st.end();
    });

    t.test('throws if an invalid charset is specified', function (st) {
        st['throws'](function () {
            qs.stringify({ a: 'b' }, { charset: 'foobar' });
        }, new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined'));
        st.end();
    });

    t.test('respects a charset of iso-8859-1', function (st) {
        st.equal(qs.stringify({ Ã¦: 'Ã¦' }, { charset: 'iso-8859-1' }), '%E6=%E6');
        st.end();
    });

    t.test('encodes unrepresentable chars as numeric entities in iso-8859-1 mode', function (st) {
        st.equal(qs.stringify({ a: 'â˜º' }, { charset: 'iso-8859-1' }), 'a=%26%239786%3B');
        st.end();
    });

    t.test('respects an explicit charset of utf-8 (the default)', function (st) {
        st.equal(qs.stringify({ a: 'Ã¦' }, { charset: 'utf-8' }), 'a=%C3%A6');
        st.end();
    });

    t.test('`charsetSentinel` option', function (st) {
        st.equal(
            qs.stringify({ a: 'Ã¦' }, { charsetSentinel: true, charset: 'utf-8' }),
            'utf8=%E2%9C%93&a=%C3%A6',
            'adds the right sentinel when instructed to and the charset is utf-8'
        );

        st.equal(
            qs.stringify({ a: 'Ã¦' }, { charsetSentinel: true, charset: 'iso-8859-1' }),
            'utf8=%26%2310003%3B&a=%E6',
            'adds the right sentinel when instructed to and the charset is iso-8859-1'
        );

        st.end();
    });

    t.test('does not mutate the options argument', function (st) {
        var options = {};
        qs.stringify({}, options);
        st.deepEqual(options, {});
        st.end();
    });

    t.test('strictNullHandling works with custom filter', function (st) {
        var filter = function (prefix, value) {
            return value;
        };

        var options = { strictNullHandling: true, filter: filter };
        st.equal(qs.stringify({ key: null }, options), 'key');
        st.end();
    });

    t.test('strictNullHandling works with null serializeDate', function (st) {
        var serializeDate = function () {
            return null;
        };
        var options = { strictNullHandling: true, serializeDate: serializeDate };
        var date = new Date();
        st.equal(qs.stringify({ key: date }, options), 'key');
        st.end();
    });

    t.test('allows for encoding keys and values differently', function (st) {
        var encoder = function (str, defaultEncoder, charset, type) {
            if (type === 'key') {
                return defaultEncoder(str, defaultEncoder, charset, type).toLowerCase();
            }
            if (type === 'value') {
                return defaultEncoder(str, defaultEncoder, charset, type).toUpperCase();
            }
            throw 'this should never happen! type: ' + type;
        };

        st.deepEqual(qs.stringify({ KeY: 'vAlUe' }, { encoder: encoder }), 'key=VALUE');
        st.end();
    });

    t.test('objects inside arrays', function (st) {
        var obj = { a: { b: { c: 'd', e: 'f' } } };
        var withArray = { a: { b: [{ c: 'd', e: 'f' }] } };

        st.equal(qs.stringify(obj, { encode: false }), 'a[b][c]=d&a[b][e]=f', 'no array, no arrayFormat');
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: 'brackets' }), 'a[b][c]=d&a[b][e]=f', 'no array, bracket');
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: 'indices' }), 'a[b][c]=d&a[b][e]=f', 'no array, indices');
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: 'repeat' }), 'a[b][c]=d&a[b][e]=f', 'no array, repeat');
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: 'comma' }), 'a[b][c]=d&a[b][e]=f', 'no array, comma');

        st.equal(qs.stringify(withArray, { encode: false }), 'a[b][0][c]=d&a[b][0][e]=f', 'array, no arrayFormat');
        st.equal(qs.stringify(withArray, { encode: false, arrayFormat: 'brackets' }), 'a[b][][c]=d&a[b][][e]=f', 'array, bracket');
        st.equal(qs.stringify(withArray, { encode: false, arrayFormat: 'indices' }), 'a[b][0][c]=d&a[b][0][e]=f', 'array, indices');
        st.equal(qs.stringify(withArray, { encode: false, arrayFormat: 'repeat' }), 'a[b][c]=d&a[b][e]=f', 'array, repeat');
        st.equal(
            qs.stringify(withArray, { encode: false, arrayFormat: 'comma' }),
            '???',
            'array, comma',
            { skip: 'TODO: figure out what this should do' }
        );
X      Ë‰    i      ğ    Ìöå	.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     Xğ    k˜

.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     °ğ    ì¢
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ‘ğ    TÎ
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     `‘ğ    .ø
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ¸‘ğ    4'
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     ’ğ    4'
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     h’ğ    ãN2
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     À’ğ    (ã6
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     “ğ    VA
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     p“ğ    )»G
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     È“ğ    şV
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i      ”ğ    şV
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     x”ğ    Ëd
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     Ğ”ğ    Ô¸x
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     (•ğ    [gƒ
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     €•ğ    Wê„
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     Ø•ğ    è¡
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     0–ğ    ±«
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ˆ–ğ    ATº
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     à–ğ    ATº
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     8—ğ    ºÁÒ
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     —ğ    osÚ
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     è—ğ    à
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     @˜ğ    à
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ˜˜ğ    
îò
.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     ğ˜ğ    ³÷
.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     H™ğ    ë	.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i      ™ğ    ö‹.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ø™ğ    Å.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     Pšğ    [.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ¨šğ    Š“(.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i      ›ğ    Š“(.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     X›ğ    uD3.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     °›ğ    iì:.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     œğ    A.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     `œğ    A.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ¸œğ    ~@J.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     ğ    ’ÃK.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     hğ    õT.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     Àğ    õT.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰    i     ğ    ?Åb.èÚ           $    < b o o t s t a t . d a t     X      Ë‰    i     pğ    ?Åb.èÚ  €        $    < b o o t s t a t . d a t     X      Ë‰